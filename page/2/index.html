<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/myStyle.css">
  

  
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">

		<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
			<input type="text" id="st-search-input" class="st-search-input_my" maxlength="30" placeholder="搜一搜" />
		</form>
	
	<header id="header" class="inner">
		<a href="/categories/myPage/myPage.html" class="profilepic">
			
			<img src="/images/title.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/categories/myPage/myPage.html">轻刻美</a></h1>
		</hgroup>

		
		<p class="header-subtitle">因上努力,果上随缘</p>
		
		
		<nav class="header-menu">
			<ul>
			
				<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
	        
				<li><a href="/">所有文章</a></li>
	        
				<li><a href="/categories/studies">学习</a></li>
	        
				<li><a href="/categories/lives">生活</a></li>
	        
				<li><a href="/categories/essays">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/hmqqk/hmqqk.github.io" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">轻刻美</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/title.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">轻刻美</h1>
			</hgroup>
			
			<p class="header-subtitle">因上努力,果上随缘</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
		        
					<li><a href="/">所有文章</a></li>
		        
					<li><a href="/categories/studies">学习</a></li>
		        
					<li><a href="/categories/lives">生活</a></li>
		        
					<li><a href="/categories/essays">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hmqqk/hmqqk.github.io" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-计网开来-研续梦想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/计网开来-研续梦想/">计网开来，延续梦想</a>
    </h1>
  

        <a href="/2016/11/06/计网开来-研续梦想/" class="archive-article-date">
  	<time datetime="2016-11-05T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-11-06</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“计网开来，研续梦想”迎新晚会圆满落幕咯，宣传部的娃娃们真的是各种给力呢，作为部长我感觉特别的欣慰，大家都是踊跃参与到各项活动中去，无论是前期晚会筹划、宣传工作、海报、横幅、门票、视频的设计与制作、节目的审核和安排等等，每件事情都是超乎预期的完成了任务，辛苦啦，么么哒！爱你们在心口难开。<br>
        <a class="article-more-a"  href="/2016/11/06/计网开来-研续梦想/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/lives/">lives</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/11/06/计网开来-研续梦想/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-俱乐部，通通“砸”过来吧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/25/俱乐部，通通“砸”过来吧/">俱乐部，通通“砸”过来吧</a>
    </h1>
  

        <a href="/2016/09/25/俱乐部，通通“砸”过来吧/" class="archive-article-date">
  	<time datetime="2016-09-24T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-09-25</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>研一启程咯！神马？各大精英式俱乐部在呼唤着我？？那我就乖乖滴从了吧~哈哈</p>
<p>大学四年的生活充实圆满，收获多多。研究生生活也已开启，我要创造一个更加美好的青春记忆~各精英俱乐部@计算机研究生会@腾讯创新俱乐部@华为创新俱乐部，我来啦，期待后续的精彩！<br>
        <a class="article-more-a"  href="/2016/09/25/俱乐部，通通“砸”过来吧/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/lives/">lives</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/09/25/俱乐部，通通“砸”过来吧/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-加油-谢谢肯定" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/加油-谢谢肯定/">加油,谢谢肯定</a>
    </h1>
  

        <a href="/2016/09/18/加油-谢谢肯定/" class="archive-article-date">
  	<time datetime="2016-09-17T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-09-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今个真是兴奋呀，计算机研究生会又涌入了一批新鲜的血液，瞧这小鲜肉鲜的，小美女没的呀，哈哈~and今天又收获了组织的奖励，谢谢肯定,感动到crying,今后必将更加努力滴工作的。大家共同努力!<br>
        <a class="article-more-a"  href="/2016/09/18/加油-谢谢肯定/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/lives/">lives</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/09/18/加油-谢谢肯定/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-nodejs总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/nodejs总结/">nodejs总结</a>
    </h1>
  

        <a href="/2016/08/18/nodejs总结/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>问题1 ：解决node_modules目录太长无法删除的问题<br>解决：<br>使用npm里面一个专门用于删除的模块插件 ：rimraf<br>操作：<br>npm install -g rimraf<br>cd xxx<br>rimraf node_modules</p>
<p>rimraf<br>A deep deletion module for node (like rm -rf)<br>Build Status Dependency Status devDependency Status</p>
<p>The UNIX command rm -rf for node.</p>
<p>Install with npm install rimraf, or just drop rimraf.js somewhere.</p>
<p>API<br>rimraf(f, [opts], callback)</p>
<p>The first parameter will be interpreted as a globbing pattern for files. If you want to disable globbing you can do so with opts.disableGlob (defaults to false). This might be handy, for instance, if you have filenames that contain globbing wildcard characters.</p>
<p>The callback will be called with an error if there is one. Certain errors are handled for you:</p>
<p>Windows: EBUSY and ENOTEMPTY - rimraf will back off a maximum of opts.maxBusyTries times before giving up, adding 100ms of wait between each attempt. The default maxBusyTries is 3.<br>ENOENT - If the file doesn’t exist, rimraf will return successfully, since your desired outcome is already the case.<br>EMFILE - Since readdir requires opening a file descriptor, it’s possible to hit EMFILE if too many file descriptors are in use. In the sync case, there’s nothing to be done for this. But in the async case, rimraf will gradually back off with timeouts up to opts.emfileWait ms, which defaults to 1000.<br>options<br>unlink, chmod, stat, lstat, rmdir, readdir, unlinkSync, chmodSync, statSync, lstatSync, rmdirSync, readdirSync</p>
<p>In order to use a custom file system library, you can override specific fs functions on the options object.</p>
<p>If any of these functions are present on the options object, then the supplied function will be used instead of the default fs method.</p>
<p>Sync methods are only relevant for rimraf.sync(), of course.</p>
<p>For example:</p>
<p>var myCustomFS = require(‘some-custom-fs’)</p>
<p>rimraf(‘some-thing’, myCustomFS, callback)<br>maxBusyTries</p>
<p>If an EBUSY, ENOTEMPTY, or EPERM error code is encountered on Windows systems, then rimraf will retry with a linear backoff wait of 100ms longer on each try. The default maxBusyTries is 3.</p>
<p>Only relevant for async usage.</p>
<p>emfileWait</p>
<p>If an EMFILE error is encountered, then rimraf will retry repeatedly with a linear backoff of 1ms longer on each try, until the timeout counter hits this max. The default limit is 1000.</p>
<p>If you repeatedly encounter EMFILE errors, then consider using graceful-fs in your program.</p>
<p>Only relevant for async usage.</p>
<p>glob</p>
<p>Set to false to disable glob pattern matching.</p>
<p>Set to an object to pass options to the glob module. The default glob options are { nosort: true, silent: true }.</p>
<p>Glob version 6 is used in this module.</p>
<p>Relevant for both sync and async usage.</p>
<p>disableGlob</p>
<p>Set to any non-falsey value to disable globbing entirely. (Equivalent to setting glob: false.)</p>
<p>rimraf.sync<br>It can remove stuff synchronously, too. But that’s not so good. Use the async API. It’s better.</p>
<p>CLI<br>If installed with npm install rimraf -g it can be used as a global command rimraf <path></path> [<path></path> …] which is useful for cross platform support.</p>
<p>mkdirp<br>If you need to create a directory recursively, check out mkdirp.</p>
<p>问题2： nodejs mkdirp<br>能够生成创建文件夹中间所有层级</p>
<p>demo</p>
<p>var mkdirp = require(“mkdirp”);<br>mkdirp(‘/a/b/c/d’, function (err) {<br>    if (err) console.error(err)<br>    else console.log(‘pow!’)<br>});</p>
<p>问题3：node.js中的fs.rmdir方法使用说明<br>方法说明：<br>以异步的方式删除文件目录。<br>语法：<br>复制代码 代码如下:</p>
<p>fs.rmdir(path, [callback(err)])<br>由于该方法属于fs模块，使用前需要引入fs模块（var fs= require(“fs”) ）<br>接收参数：<br>path  目录路径<br>callback   回调，回调函数传递一个err异常参数。<br>例子：<br>复制代码 代码如下:</p>
<p>var fs = require(‘fs’);<br>fs.rmdir(‘deldir’, function(err){<br> if(err){<br>  console.log(err);<br> }else{<br>  console.log(“done”);<br> }<br>});<br>源码：<br>复制代码 代码如下:</p>
<p>fs.rmdir = function(path, callback) {<br>  callback = makeCallback(callback);<br>  if (!nullCheck(path, callback)) return;<br>  binding.rmdir(pathModule._makeLong(path), callback);<br>};</p>
<p>问题4:nodejs-ueditor（富文本编辑器）的实现<br>1.介绍<br>UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，<br>具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…</p>
<p>2.下载<br>下载地址 ：<a href="http://ueditor.baidu.com/website/download.html#ueditor" target="_blank" rel="external">http://ueditor.baidu.com/website/download.html#ueditor</a>.<br>选择开发版 ，因为我们使用node ,所以随便下一个版本，这里下载1.4.3.3 jsp 版本<br>下载完成解压。<br>3.webstorm下创建nodejs项目<br>4.修改index.jade界面<br>    doctype html<br>    head<br>      meta(http-equiv=”Content-Type” content=”text/html;charset=utf-8”)<br>      script(type=”text/javascript” charset=”utf-8” src=”../ueditor/ueditor.config.js”)<br>      script(type=”text/javascript” charset=”utf-8” src=”../ueditor/ueditor.all.min.js”)<br>      script(type=”text/javascript” charset=”utf-8” src=”../ueditor/lang/zh-cn/zh-cn.js”)<br>    body<br>     script(id=”editor” type=”text/plain” style=”width:1024px;height:500px;”)</p>
<pre><code>script(type=&quot;text/javascript&quot;).var ue = UE.getEditor(&apos;editor&apos;)
</code></pre><p>然后启动项目，编辑器初始化成功！（注意引入文件路径的问题，如果初始化失败可以f12查看报错进行调试）<br>4.后端配置<br>仅仅这样是不能进行上传的<br>我们需要要配置后端文件。<br>修改 ueditor.config.js 文件</p>
<p>//找到这一行代码 修改成这样，这里的url为请求的路径<br>// 服务器统一请求接口路径<br>        ,serverUrl: URL + “ue”  </p>
<p>接下来我们安装ueditor 模块<br>UEditor API <a href="http://ueditor.baidu.com/doc/" target="_blank" rel="external">http://ueditor.baidu.com/doc/</a><br>$npm install ueditor –save  </p>
<p>修改app.js：<br>//加载ueditor 模块<br>    var ueditor = require(“ueditor”);  </p>
<pre><code>//使用模块  
app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), function (req, res, next) {  
    // ueditor 客户发起上传图片请求  
    if (req.query.action === &apos;uploadimage&apos;) {  
        var foo = req.ueditor;  

        var imgname = req.ueditor.filename;  

        var img_url = &apos;/images/ueditor/&apos;;  
        res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做  
        res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);//IE8下载需要设置返回头尾text/html 不然json返回文件会被直接下载打开  
    }  
    //  客户端发起图片列表请求  
    else if (req.query.action === &apos;listimage&apos;) {  
        var dir_url = &apos;/images/ueditor/&apos;;  
        res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片  
    }  
    // 客户端发起其它请求  
    else {  
        // console.log(&apos;config.json&apos;)  
        res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);  
        res.redirect(&apos;/ueditor/jsp/config.json&apos;);  
    }  
}));        
</code></pre><p>修改完成重启一下服务即可</p>
<div align="center"><br><img src="/images/nodejs/1_1.png"><br></div>      


<p>问题：node.js模块之socket IO<br>解决：<br>Socket.IO的为了在浏览器和移动设备上创建实时应用而产生的，它可以模糊不同传输机制之间的差异。<br>Socket.IO是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用，非常方便和人性化，而且支持的浏览器最低达IE5.5，应该可以满足绝大部分需求了。</p>
<ol>
<li>安装部署<br>2.1 安装<br>首先安装非常简单，在node.js环境下只要一句：<br>npm install socket.io<br>2.2 结合express来构建服务器<br>express是一个小巧的Node.js的Web应用框架，在构建HTTP服务器时经常使用到，所以直接以Socket.IO和express为例子来讲解。<br>var express = require(‘express’)<br> , app = express()<br> , server = require(‘http’).createServer(app)<br> , io = require(‘socket.io’).listen(server);<br> server.listen(3001);<br>若不使用express，请参考socket.io/#how-to-use</li>
<li><p>基本使用方法<br>主要分为服务器端和客户端两段代码，都非常简单。<br>Server（app.js）：<br>//接上面的代码<br>app.get(‘/‘, function (req, res) {<br> res.sendfile(__dirname + ‘/index.html’);});<br>io.sockets.on(‘connection’, function (socket) {<br> socket.emit(‘news’, { hello: ‘world’ });<br> socket.on(‘other event’, function (data) {</p>
<pre><code>console.log(data);
</code></pre><p> });<br>});<br>首先io.sockets.on函数接受字符串”connection”作为客户端发起连接的事件，当连接成功后，调用带有socket参数的回调函数。我们在使用socket.IO的时候，基本上都在这个回调函数里面处理用户的请求。<br>socket最关键的是emit和on两个函数，前者提交（发出）一个事件（事件名称用字符串表示），事件名称可以自定义，也有一些默认的事件名称，紧接着是一个对象，表示向该socket发送的内容；后者接收一个事件（事件名称用字符串表示），紧接着是收到事件调用的回调函数，其中data是收到的数据。<br>在上面的例子中，我们发送了news事件和收到了other event事件，那么客户端应该会有对应的接收和发送事件。没错，客户端代码和服务器正好相反，而且非常相似。<br>Client（client.js）<br><script src="/socket.io/socket.io.js"></script><br><script><br> var socket = io.connect(‘<a href="http://localhost">http://localhost</a>‘);<br> socket.on(‘news’, function (data) {</p>
<pre><code>console.log(data);
socket.emit(&apos;other event&apos;, { my: &apos;data&apos; });
</code></pre><p> });<br></script><br>有两点要注意的：socket.io.js路径要写对，这个js文件实际放在了服务器端的node_modules文件夹中，在请求这个文件时会重定向，因此不要诧异服务器端不存在这个文件但为什么还能正常工作。当然，你可以把服务器端的socket.io.js这个文件拷贝到本地，使它成为客户端的js文件，这样就不用每次都向Node服务器请求这个js文件，增强稳定性。第二点是要用var socket = io.connect(‘网站地址或ip’);来获取socket对象，接着就可以使用socket来收发事件。关于事件处理，上面的代码表示收到“news”事件后，打印收到的数据，并向服务器发送“other event”事件。<br>注：内置默认的事件名例如“disconnect”表示客户端连接断开，“message”表示收到消息等等。自定义的事件名称，尽量不要跟Socket.IO中内置的默认事件名重名，以免造成不必要的麻烦。</p>
</li>
<li><p>其他常用API<br>1).向所有客户端广播：socket.broadcast.emit(‘broadcast message’);<br>2).进入一个房间（非常好用！相当于一个命名空间，可以对一个特定的房间广播而不影响在其他房间或不在房间的客户端）：socket.join(‘your room name’);<br>3).向一个房间广播消息（发送者收不到消息）：socket.broadcast.to(‘your room name’).emit(‘broadcast room message’);<br>4).向一个房间广播消息（包括发送者都能收到消息）（这个API属于io.sockets）：io.sockets.in(‘another room name’).emit(‘broadcast room message’);<br>5).强制使用WebSocket通信：（客户端）socket.send(‘hi’)，（服务器）用socket.on(‘message’, function(data){})来接收。</p>
</li>
<li>使用Socket.IO构建一个聊天室<br>最后，我们通过一个简单的实例来结束本篇。用Socket.IO构建一个聊天室就是50行左右的代码的事情，实时聊天效果也非常好。以下贴出关键代码：<br>Server（socketChat.js）<br>//一个客户端连接的字典，当一个客户端连接到服务器时，<br>//会产生一个唯一的socketId，该字典保存socketId到用户信息（昵称等）的映射<br>var connectionList = {};<br>exports.startChat = function (io) {<br> io.sockets.on(‘connection’, function (socket) {<pre><code>//客户端连接时，保存socketId和用户名
var socketId = socket.id;
connectionList[socketId] = {
    socket: socket
};
//用户进入聊天室事件，向其他在线用户广播其用户名
socket.on(&apos;join&apos;, function (data) {
    socket.broadcast.emit(&apos;broadcast_join&apos;, data);
    connectionList[socketId].username = data.username;
});
//用户离开聊天室事件，向其他在线用户广播其离开
socket.on(&apos;disconnect&apos;, function () {
    if (connectionList[socketId].username) {
        socket.broadcast.emit(&apos;broadcast_quit&apos;, {
            username: connectionList[socketId].username
        });
    }
    delete connectionList[socketId];
});
//用户发言事件，向其他在线用户广播其发言内容
socket.on(&apos;say&apos;, function (data) {
    socket.broadcast.emit(&apos;broadcast_say&apos;,{
        username: connectionList[socketId].username,
        text: data.text
    });
});
</code></pre> })<br>};<br>Client(socketChatClient.js)<br>var socket = io.connect(‘<a href="http://localhost" target="_blank" rel="external">http://localhost</a>‘);<br>//连接服务器完毕后，马上提交一个“加入”事件，把自己的用户名告诉别人<br>socket.emit(‘join’, {<br> username: ‘Username hehe’<br>});<br>//收到加入聊天室广播后，显示消息<br>socket.on(‘broadcast_join’, function (data) {<br> console.log(data.username + ‘加入了聊天室’);<br>});<br>//收到离开聊天室广播后，显示消息<br>socket.on(‘broadcast_quit’, function(data) {<br> console.log(data.username + ‘离开了聊天室’);<br>});<br>//收到别人发送的消息后，显示消息<br>socket.on(‘broadcast_say’, function(data) {<br> console.log(data.username + ‘说: ‘ + data.text);<br>});<br>//这里我们假设有一个文本框textarea和一个发送按钮.btn-send<br>//使用jQuery绑定事件<br>$(‘.btn-send’).click(function(e) {<br> //获取文本框的文本<br> var text = $(‘textarea’).val();<br> //提交一个say事件，服务器收到就会广播<br> socket.emit(‘say’, {<pre><code>username: &apos;Username hehe&apos;
text: text
</code></pre> });<br>});<br>这就是一个简单的聊天室DEMO，你可以根据你的需要随意扩展。Socket.IO基本上就是各种事件的提交和接收处理，思想非常简单。</li>
</ol>
<p>问题：npm发布自己的代码<br>解决：<br>1.验证npm<br>新建一个文件夹用来存包，进入该文件夹（windows的同学可以按住shift键+右键，选择’在此处打开命令窗口‘来快速调出控制台）。<br>首先需要验证一下你是否安装了npm，如果确认已装请跳过此步,在控制台输入命令:<br>npm -v<br>2.新建package.json<br>在项目根目录下新建一个package.json，这是一个用来描述你的包的json文件，例如包名，依赖的其他包，作者等等。<br>借助npm来初始化可快速新建，在根目录下输入命令：<br>npm init<br>接着npm会提示你输入一些关于你的包的信息，如果你暂时不知道怎么填那一项就直接按回车就好：<br>你会发现你的根目录下多了一个package.json文件。<br>当然’name’要注意填，它将是你发布出去的npm包名，如果不小心填错了，可以直接在新建好的package.json修改’name’字段。<br>3.编写代码<br>虽然npm是允许发布一个空包（只含有package.json的包），但是这样的一个包是没有意义的。<br>我们如果没有代码，可以先加一个README.md（给使用者看的说明书）来说明一下自己的包：<br>在根目录下新建一个README.md文件，输入如下内容：</p>
<h1 id="这是我的一个npm包"><a href="#这是我的一个npm包" class="headerlink" title="这是我的一个npm包"></a>这是我的一个npm包</h1><p>未完待续…<br>如果你想好了写说明代码(js,html,css等)请试着放进来。</p>
<p>4.创建npm账号<br>如果你没有创建过npm账号，可输入如下命令添加一个npm账号，并跟着提示填写要注册的账号和密码：<br>npm adduser</p>
<p>5.发布！<br>现在可以发布了。还是在根目录下输入命令：<br>npm publish<br>这样你就可以在<a href="https://www.npmjs.com/搜索并找到你刚才发布的npm包名（例如我的是：article-npm-publish，如果需要登录，请使用刚才你在控制台注册的账号）：" target="_blank" rel="external">https://www.npmjs.com/搜索并找到你刚才发布的npm包名（例如我的是：article-npm-publish，如果需要登录，请使用刚才你在控制台注册的账号）：</a><br>现在，你可以试着使用npm install xxx（xxx为你的包名）来安装自己的包啦。</p>
<p>常见问题<br>1.如果需要更新包，在修改完代码后请记得修改package.json包的’version’字段，然后 npm publish。否则会无法发布；<br>2.如果在发布中显示类似’请确认你是否有权限更新xxx包’的英文提示，这就说明你的包名有人使用了。换个名字就好啦。<br>3.如果你想删除一个自己发布过的包，请使用命令 npm unpublish –force xxx （xxx为包名），一些没有意义的包还是建议删掉。</p>
<p>问题：Node.js监控工具：nodemon<br>解决：<br>Nodemon 是一款非常实用的工具，用来监控你 node.js 源代码的任何变化和自动重启你的服务器。 Nodemon 是一款完美的开发工具，可以使用 npm 安装。<br>npm install -g nodemon<br>在doc下输入上面的，就安装成功了，以后我们启动我们的项目的时候，就输入nodemon server.js</p>
<p>以前是node server.js<br>这样，每次我们的js文件修改后，node就会自动重启，就省的我们手动去重启了，这样方便了很多。<br>还有一个工具也可以实现同样的需求——supervisor</p>
<p>例如测试结果如下：</p>
<div align="center"><br><img src="/images/nodejs/1_2.png" <="" div="">

<p>P.S. 这里有一个坑：我一直使用下面的方法启动node: node<br>这样启动是没有问题的，因为环境变量中配置了node了嘛，但是如果nodemon d:/js/node/app.js<br>这样nodemon监视的是启动目录，而不是d:/js/node这个目录，比如 c:\program&gt;nodemon d:/js/node/app.js<br>他实际上监视的是c:\program这个目录，你需要修改启动目录里才可以。<br>[热启动需要全局安装nodemon 另外nodeJS最好安装稳定版本]</p>
<p>问题：<br>解决：<br>背景<br>一个网站必然会涉及很多功能，tab选项卡、slide轮播图、pop弹出层、美化alert、paging分页等等等等，如果是企业网站那整合成一个js文件就够了，即 插件库 。</p>
<p>但是对于一个大的网站平台来说需要的功能可能会有很多，而且随着平台的发展，功能会越来越多。到最后会发展成怎样的情况呢？<br>我们希望一个页面按需引入，这个页面需要什么功能就引入什么功能。现在主流的工具有两种，amd规范的RequireJS、cmd规范的Seajs。<br>什么是Seajs<br>Seajs是一个加载器 <a href="http://kb.cnblogs.com/page/211942/" target="_blank" rel="external">http://kb.cnblogs.com/page/211942/</a><br>遵循 CMD 规范模块化开发，依赖的自动加载、配置的简洁清晰。<br>兼容性</p>
<p>Chrome 3+<br>Firefox 2+<br>Safari 3.2+<br>Opera 10+<br>IE 5.5+<br>基本应用<br>导入Seajs库<br>去官网下载最新的seajs文件， <a href="http://seajs.org/docs/#downloads" target="_blank" rel="external">http://seajs.org/docs/#downloads</a><br>在页尾引入seajs： </p>
<p><script src="/site/script/sea.js"></script><br>然后在它下面写模块的配置和入口。</p>
<p>// seajs 的简单配置<br>seajs.config({<br>  base: “../sea-modules/“,<br>  alias: {<br>    “jquery”: “jquery/jquery/1.10.1/jquery.js”<br>  }<br>});</p>
<p>// 加载入口模块<br>seajs.use(“../static/hello/src/main”);<br>配置和入口<br>这里解释下配置和入口的意思。</p>
<p>配置</p>
<p>通常在配置上修改seajs的路径和别名。</p>
<p>seajs的 路径是相对于前面引入的seajs文件的 。假如是这样的目录结构：<br>examples/<br>  |– index.html<br>  |<br>  <code>--about
  |     |-- news.html
  |</code>– script<br>        |– seajs.js<br>        |– jquery.js<br>        `– main.js</p>
<p>我们平时如果我们在index.html上引用main.js路径应该是这样写的 script/main.js ，从news.html引用main.js就要这样写， ../script/main.js 。</p>
<p>而在seajs是相对于seajs文件的，一律直接使用 main.js 就OK了，是不是很方便呢？</p>
<p>既然这么方便那在什么情况需要配置呢？一般情况是用不到的。但是假如你的路径特别深 或者要做路径映射的时候它的作用就来了。下面介绍下常用的几个配置。</p>
<p>seajs.config({<br>    // Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了）<br>    base: ‘<a href="http://example.com/path/to/base/" target="_blank" rel="external">http://example.com/path/to/base/</a>‘,<br>    // 别名配置（用变量表示文件，解决路径层级过深和实现路径映射）<br>    alias: {<br>        ‘es5-safe’: ‘gallery/es5-safe/0.9.3/es5-safe’,<br>        ‘json’: ‘gallery/json/1.0.2/json’,<br>        ‘jquery’: ‘jquery/jquery/1.10.1/jquery’<br>    },<br>    // 路径配置（用变量表示路径，解决路径层级过深的问题）<br>    paths: {<br>        ‘gallery’: ‘<a href="https://a.alipayobjects.com/gallery" target="_blank" rel="external">https://a.alipayobjects.com/gallery</a>‘<br>    }<br>});</p>
<p>入口</p>
<p>入口即加载，需要加载什么文件（模块加载器）就在这里引入。 sea.js 在下载完成后，会自动加载入口模块。</p>
<p>seajs.use(“abc/main”);  //导入seajs.js同级的abc文件夹下的main.js模块的（后缀名可略去不写）<br>seajs.use()还有另外一种用法。</p>
<p>有时候我们写一个简单的单页并不想为它单独写一个js文件，选择在直接把js代码写在页面上，seajs通过 seajs.use() 实现了这个。 接收两个参数第一个是文件依赖(单个用字符串数组都可以，多个需用数组表示)，第二个是回调函数。</p>
<p>加载单个依赖</p>
<p>//加载模块 main，并在加载完成时，执行指定回调<br>seajs.use(‘./main’, function(main) {<br>  main.init();<br>});<br>加载多个依赖</p>
<p>//并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调<br>seajs.use([‘./a’, ‘./b’], function(a, b) {<br>  a.init();<br>  b.init();<br>});<br>这里回掉函数中的a和b参数是与前面的模块暴露出来的接口一一对应的。有时候也许只需要使用b的接口，但是也要把a参数写上。什么是暴露接口下面会解释。</p>
<p>模块开发<br>这里才是重点，其实也很简单就是一个书写规范（CMD）而已。</p>
<p>// 所有模块都通过 define 来定义<br>define(function(require, exports, module) {</p>
<p>  // 通过 require 引入依赖<br>  var $ = require(‘jquery’);<br>  var Spinning = require(‘./spinning’);</p>
<p>  // 通过 exports 对外提供接口<br>  exports.doSomething = …</p>
<p>  // 或者通过 module.exports 提供整个接口<br>  module.exports = …</p>
<p>});<br>模块是通过define()方法包装的，然后内部痛过require()方法引入需要的依赖文件(模块)。（也可以引入.css文件哦~）</p>
<p>模块最好是面向对象开发的，这样最后可以方便的通过 exports.doSomething 或 module.exports 把模块的接口给暴露出来。如果你是写的是jq插件的话就不需要这个功能了，因为你的接口是写在jquery的对象里的。如果你不需要提供接口的话也可以不使用这两个属性哦！</p>
<p>事实上define方法还有另外几个参数，一般情况我们用不到。具体看 官方API 。</p>
<p>小结<br>其实Seajs的基本使用就这么简单，日常使用足够了，之前看官网的 5分钟教程 楞是没看懂，后来想想真的是5分钟学会啊,悟性太低- -||</p>
<p>注意事项<br>模块内的函数依赖必须交代清楚，防止模块在函数依赖加载前先加载出来。而且还增强了模块的独立性。<br>引入seajs的时候最好给 <script> 标签加个id，可以快速访问到这个标签（我是在模块合并时用到它的）<br>还有前面提到的使用 seajs.use() 在.html页面上写js时如果有多个模块依赖，需要使用暴露出来的接口就要让参数与它一一对应。</p>
<p>5分钟上手sea.js  <a href="http://seajs.org/docs/#quick-start">http://seajs.org/docs/#quick-start</a><br>sea.js官网 <a href="http://seajs.org/docs/">http://seajs.org/docs/</a></p>
<p>问题：gulp（自动化构建工具）<br>解决：<br>PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。<br>简介：<br>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。<br>gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。<br>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。<br>本示例以gulp-less为例（将less编译成css的gulp插件）展示gulp的常规用法，只要我们学会使用一个gulp插件后，其他插件就差看看其帮助文档了。让我们一起来学习gulp吧！ ^_^</p>
<p>gulp常用地址：<br>gulp官方网址：<a href="http://gulpjs.com">http://gulpjs.com</a><br>gulp插件地址：<a href="http://gulpjs.com/plugins">http://gulpjs.com/plugins</a><br>gulp 官方API：<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a><br>gulp 中文API：<a href="http://www.ydcss.com/archives/424">http://www.ydcss.com/archives/424</a><br>目录：<br>1、安装nodejs<br>2、使用命令行<br>3、npm介绍<br>4、选装cnpm<br>5、全局安装gulp<br>6、新建package.json文件<br>7、本地安装gulp插件<br>8、新建gulpfile.js文件<br>9、运行gulp<br>10、使用webstorm运行gulp任务<br>11、总结<br>在学习前，先谈谈大致使用gulp的步骤，给读者以初步的认识。首先当然是安装nodejs，通过nodejs的npm全局安装和项目安装gulp，其次在项目里安装所需要的gulp插件，然后新建gulp的配置文件gulpfile.js并写好配置信息（定义gulp任务），最后通过命令提示符运行gulp任务即可。<br>安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</p>
<p>1、安装nodejs<br>1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs；<br>1.2、安装：打开nodejs官网，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意）。<br>2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）<br>2.1、说明：什么是命令行？命令行在OSX是终端（Terminal），在windows是命令提示符（Command Prompt）；<br>2.2、注：之后操作都是在windows系统下；<br>2.3、简单介绍gulp在使用过程中常用命令，打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）：<br>node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。PS：未能出现版本号，请尝试注销电脑重试；<br>npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器，那它有什么用呢？稍后解释；<br>cd定位到目录，用法：cd + 路径 ；<br>dir列出文件列表；<br>cls清空命令提示符窗口内容。<br>3、npm介绍<br>3.1、说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）；<br>3.2、使用npm安装插件：命令提示符执行npm install <name> [-g] [–save-dev]；<br>3.2.1、<name>：node插件名称。例：npm install gulp-less –save-dev<br>3.2.2、-g：全局安装。将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量；  非全局安装：将会安装在当前定位目录；  全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用；<br>3.2.3、–save：将保存配置信息至package.json（package.json是nodejs项目配置文件）；<br>3.2.4、-dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；一般保存在dependencies的像这些express/ejs/body-parser等等。<br>3.2.5、为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install –production只下载dependencies节点的包）。<br>3.3、使用npm卸载插件：npm uninstall <name> [-g] [–save-dev]  PS：不要直接删除本地插件包<br>3.3.1、删除全部插件：npm uninstall gulp-less gulp-uglify gulp-concat ……???太麻烦<br>3.3.2、借助rimraf：npm install rimraf -g 用法：rimraf node_modules<br>3.4、使用npm更新插件：npm update <name> [-g] [–save-dev]<br>3.4.1、更新全部插件：npm update [–save-dev]<br>3.5、查看npm帮助：npm help<br>3.6、当前目录已安装插件：npm list<br>PS：npm安装插件过程：从<a href="http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。">http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。</a><br>4、选装cnpm<br>4.1、说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”；<br>4.2、官方网址：<a href="http://npm.taobao.org；">http://npm.taobao.org；</a><br>4.3、安装：命令提示符执行npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org；">https://registry.npm.taobao.org；</a>  注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；<br>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。<br>5、全局安装gulp<br>5.1、说明：全局安装gulp目的是为了通过她执行gulp任务；<br>5.2、安装：命令提示符执行cnpm install gulp -g；<br>5.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。<br>6、新建package.json文件<br>6.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；<br>6.2、它是这样一个json文件（注意：json文件内是不能写注释的，复制下列内容请删除注释）：<br>JavaScript<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>{<br>  “name”: “test”,   //项目名称（必须）<br>  “version”: “1.0.0”,   //项目版本（必须）<br>  “description”: “This is for study gulp project !”,   //项目描述（必须）<br>  “homepage”: “”,   //项目主页<br>  “repository”: {    //项目资源库<br>    “type”: “git”,<br>    “url”: “<a href="https://git.oschina.net/xxxx">https://git.oschina.net/xxxx</a>“<br>  },<br>  “author”: {    //项目作者信息<br>    “name”: “surging”,<br>    “email”: “surging2@qq.com”<br>  },<br>  “license”: “ISC”,    //项目许可协议<br>  “devDependencies”: {    //项目依赖的插件<br>    “gulp”: “^3.8.11”,<br>    “gulp-less”: “^3.0.0”<br>  }<br>}<br>6.3、当然我们可以手动新建这个配置文件，但是作为一名有志青年，我们应该使用更为效率的方法：命令提示符执行cnpm init<br>6.4、查看package.json帮助文档，命令提示符执行cnpm help package.json<br>特别注意：package.json是一个普通json文件，所以不能添加任何注释。参看 <a href="http://www.zhihu.com/question/23004511">http://www.zhihu.com/question/23004511</a><br>7、本地安装gulp插件<br>7.1、安装：定位目录命令后提示符执行cnpm install –save-dev；<br>7.2、本示例以gulp-less为例（编译less文件），命令提示符执行cnpm install gulp-less –save-dev；<br>7.3、将会安装在node_modules的gulp-less目录下，该目录下有一个gulp-less的使用帮助文档README.md；<br>7.4、为了能正常使用，我们还得本地安装gulp：cnpm install gulp –save-dev；<br>PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。<br>8、新建gulpfile.js文件（重要）<br>8.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。<br>8.2、它大概是这样一个js文件（更多插件配置请查看这里）：<br>JavaScript<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>//导入工具包 require(‘node_modules里对应模块’)<br>var gulp = require(‘gulp’), //本地安装gulp所用到的地方<br>    less = require(‘gulp-less’);</p>
<p>//定义一个testLess任务（自定义任务名称）<br>gulp.task(‘testLess’, function () {<br>    gulp.src(‘src/less/index.less’) //该任务针对的文件<br>        .pipe(less()) //该任务调用的模块<br>        .pipe(gulp.dest(‘src/css’)); //将会在src/css下生成index.css<br>});</p>
<p>gulp.task(‘default’,[‘testLess’, ‘elseTask’]); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务</p>
<p>//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数<br>//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组)<br>//gulp.dest(path[, options]) 处理完后文件生成路径<br>8.3、该示例文件请下载查看<br>9、运行gulp<br>9.1、说明：命令提示符执行gulp 任务名称；<br>9.2、编译less：命令提示符执行gulp testLess；<br>9.3、当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。<br>10、使用webstorm运行gulp任务<br>10.1、说明：使用webstorm可视化运行gulp任务；<br>10.2、使用方法：将项目导入webstorm，右键gulpfile.js 选择”Show Gulp Tasks”打开Gulp窗口，若出现”No task found”，选择右键”Reload tasks”，双击运行即可。<br>11、总结<br>11.1、安装nodejs；<br>11.2、新建package.json文件；<br>11.3、全局和本地安装gulp；<br>11.4、安装gulp插件；<br>11.5、新建gulpfile.js文件；<br>11.6、通过命令提示符运行gulp任务。</p>
<p>P.S. 学习网址 <a href="http://www.ydcss.com/">http://www.ydcss.com/</a></p>
<p>gulp再总结<br>gulp作为前端构建项目的一个工具，自己理解gulp主要方面的作用：<br>1.构建本地服务器。<br>2.快速构建项目。<br>3.对代码进行压缩合并，使代码简洁，减少频繁的请求工作。</p>
<p>gulp学习地址： gulp中文网：<a href="http://www.gulpjs.com.cn/。">http://www.gulpjs.com.cn/。</a></p>
<p>一、gulp安装<br>1.1 全局安装gulp，前提是必须安装了node.js/npm;<br>npm install –global gulp<br>1.2作为项目的开发依赖（需要在项目目录下）<br>npm install –save-dev gulp<br>1.3 根据自己的项目需求，安装其他开发依赖<br>npm  install gulp-connect gulp-concat gulp-uglify –save-dev<br>1.4在项目根目录创建一个名为gulpfile.js文件，看项目需要依赖哪些开发项，进行依赖注入在gulpfile.js中，并创建gulp任务。<br>var gulp=require(‘gulp’);<br>var connnect=require(‘gulp-connect’);<br>……<br>gulp.task(‘kathie’,function(){<br>//此任务要做的事情。<br>})；<br>gulp.task(‘default’,[‘kathie’]);//默认执行的任务<br>1.5在项目跟目录创建一个package.json的文件，这个文件是一个严格的json文件。主要是项目的配置文件。其中很多属性可以通过npm-config来生成。主要信息有以下。其中除了devDependencies之外，可以通过npm init来配置；devDependencies依赖的插件需要通过npm install gulp-connect –save-dev 来安装。<br>1.6 package.json 配置详解：<a href="http://www.cnblogs.com/tzyy/p/5193811.html#_h1_27">http://www.cnblogs.com/tzyy/p/5193811.html#_h1_27</a></p>
<p>[图片]<br>二、npm中的开发依赖项学习。<br>2.1 gulp-connect：  run a webserver。具体用法：<br>//1.引入插件：<br>var gulp = require(‘gulp’);<br>    var connect = require(‘gulp-connect’);<br>//2.创建watch任务去检测html文件，其定义了一个当html改动之后，去调用一个gulp的task<br>gulp.task(‘watch’,function(){<br>        gulp.watch([‘./www/<em>.html’],[‘html’]);<br>})<br>//3.使用connect启动一个web服务器<br>gulp.task(‘connect’,function(){<br>        connect.server({<br>                root: “www”,<br>                livereload : true,<br>                //port:8090,   可以更改本地默认端口号<br>                //host:’gulp.dev’<br>        });<br>});<br>//4.加载www中的一个主页面<br>gulp.task(‘html’,function(){<br>        gulp.src(‘./www/</em>.html’)<br>                .pipe(connect.reload());<br>});<br>//5.设置默认任务<br>gulp.task(‘default’,[‘connect’,’watch’]);<br>//6.不要关闭dos命令行，如果没有修改端口号，直接浏览器输入<a href="http://localhost:8080">http://localhost:8080</a></p>
<p>2.2 browser-sync ：<br>启动一个本地服务器，配置启动页面；同时修改代码之后能自动刷新页面，免按F5；<br>browser-sync与gulp一起使用方法。<br>//1.引入插件：<br>var browserSync=require(‘browser-sync’).create();<br>//2.创建任务，并使用browserSync创建服务器。</p>
<p>gulp.task(‘serve’,function(){<br>        browserSync.init({<br>                server:{<br>                        basedir : ‘./‘      //初始化项目根目录为“./”<br>                },<br>                files:[<br>                        ‘www/css/<em>.css’,<br>                        ‘www</em>.js’,<br>                        ‘www<em>.html’,<br>                        ‘www/img/</em>‘,<br>                        ‘www/fonts/*’</p>
<pre><code>        ]        });
gulp.watch([&apos;./www/*.html&apos;],[&apos;html&apos;]);
gulp.watch(&quot;www*.html&quot;).on(&quot;change&quot;,browserSync.reload);
</code></pre><p>//3.watch这个api是监控当前文件发生变化时触发的任务；这里是当html文档发生变化时，浏览器会自动reload。</p>
<p>});</p>
<p>以下为案例：<br>//引入gulp、gulp插件以及browser-sync<br>        var gulp = require(‘gulp’),<br>                   browserSync = require(‘browser-sync’).create(),<br>                    less = require(‘gulp-less’);<br>        //创建一个新的gulp任务<br>        gulp.task(‘serve’,[‘less’],function(){<br>              //初始化项目跟目录为’./‘（也可以使用代理proxy: “yourlocal.dev”）<br>           browserSync.init({<br>                                server: ‘./‘<br>              });<br>            //创建gulp监听器，监听less文件的变化，自动执行’less’任务，编译less并生成css文件<br>            gulp.watch(‘./less/<em>.less’, [‘less’]).on(‘change’, function(event){<br>                 console.log(‘File ‘ + event.path + ‘ was ‘ + event.type + ‘, running       tasks…’);<br>          });<br>           //监听html文件的变化，自动重新载入<br>          gulp.watch(‘./</em>.html’).on(‘change’, browserSync.reload);<br>      });<br>//创建自动编译less的任务，这边需要return stream以保证browserSync.reload在正确的时机调用<br>gulp.task(‘less’, function(){<br>    return gulp.src(‘./less/*.less’)<br>        .pipe(less())<br>        .pipe(gulp.dest(‘./css’))<br>        .pipe(browserSync.stream());<br>});<br>//默认启动的gulp任务数组[‘serve’]gulp.task(‘default’, [‘serve’]);</p>
<p>2.3 gulp-rev  and  gulp-rev-collector<br>目的是对css和js文件命名进行加密处理；同时在对应的html中的路径进行更新。<br>var gulp = require(‘gulp’);</p>
<p>var concat = require(‘gulp-concat’);                            //- 多个文件合并为一个；<br>var minifyCss = require(‘gulp-minify-css’);                     //- 压缩CSS为一行；<br>var rev = require(‘gulp-rev’);                                  //- 对文件名加MD5后缀<br>var revCollector = require(‘gulp-rev-collector’);               //- 路径替换</p>
<p>gulp.task(‘cssConcat’, function() {        //- 创建一个名为 concat 的 task<br>    gulp.src(‘www/css/*.css’)    //- 需要处理的css文件，放到一个字符串数组里<br>        .pipe(minifyCss())                           //- 压缩处理成一行<br>        .pipe(rev())                               //- 文件名加MD5后缀<br>        .pipe(gulp.dest(‘dist/css’))         //- 输出文件本地<br>        .pipe(rev.manifest())       //- 生成一个rev-manifest.json<br>        .pipe(gulp.dest(‘./rev’));    //- 将 rev-manifest.json 保存到 rev 目录内<br>});</p>
<p>gulp.task(‘rev’,[‘cssConcat’],function() {console.log(111)<br>    gulp.src([‘./rev/rev-manifest.json’, ‘dist/index.html’])<br>//- 读取 rev-manifest.json 文件以及需要进行css名替换的文件<br>        .pipe(revCollector())                                   //- 执行文件内css名的替换<br>        .pipe(gulp.dest(‘dist’));                     //- 替换后的文件输出的目录<br>});<br>gulp.task(‘default’, [ ‘rev’]);</p>
<p>这里踩的坑：<br>2.3.1  第一个坑：只能对同名的css或者js文件进行md5加密，然后进行替换。对于先拷贝再修改名再加密的情况，html中的引用无法更新。<br>我存在的问题：<br>  ● 源文件www/index.html中引用的是<link rel="stylesheet" href="css/bootstrap.css"><br>  ● 对css进行了拷贝，再rename并加密。<br>gulp.task(‘cssConcat’,function(){<br>        return gulp.src(‘www/css/*.css’)<br>                        .pipe(minifyCss({     //先对源文件进行压缩<br>                            keepSpecialComments: 0<br>                }))<br>                .pipe(rename({<br>                            extname: ‘.min.css’   //再重命名<br>                        }))<br>                .pipe(rev())         //再加密<br>                .pipe(gulp.dest(‘dist/css’)) //输出到dist文件中<br>                .pipe(rev.manifest())<br>                .pipe(gulp.dest(‘./rev’)); //将rev-manifest.json文件放到rev文件夹<br>});<br>  ● 此时dist中的css文件名是bootstrap-87we8fuiehfjhdj.min.css<br>  ● 但拷贝过来的html中的css文件还是<link rel="stylesheet" href="css/bootstrap.css"><br>  ● 尽管此时生产了rev-manifest.json文件；但还是无法替换html中的css引用名称。<br>  ● 解决办法：  不要先对其rename。注释掉.pipe(rename({  extname: ‘.min.css’ }))<br>2.3.2 第二个坑： 目前不能同时对css和js进行加密。后面的会覆盖掉前面的rev-manifest.json文件。<br>[图片][图片]如图： 这样rev-manifest.json文件只有对js的加密的文件；没有css的。<br>解决办法：<br>在网上看到可以使用.pipe(rev.manifest({     merge: true  }))，但实际操作过了，不行；<br>目前的解决办法就是将css和js分别备份到rev存两个文件夹；一个css；一个js。如下：<br>[图片]<br>2.4 gulp-uglify<br>对js进行压缩；这里踩的坑—–对js进行压缩之后，启动项目，发现报错。<br>原因： gulpfile.js必须是严格模式的。第一行必须写“use strict”。所以压缩的文件也必须按照严格模式来写。所以angular中的写法都必须定义变量。采用严格模式：<br>angular.module(‘app’,[]).controller(‘myCtrl’,function($scope){})—-这个写法是错误的，必须变成加中括号，定义变量：<br>angular.module(‘app’,[]).controller(‘myCtrl’,[‘$scope’,function($scope){}])–正确写法</p>
<p>如果不使用严格模式的写法；针对angularJs的js文件；也可以使用gulp-ng-annotate插件。此插件的作用是：使用ng-annotate进行angular模块依赖自动注入, 引入模块自动加[],防止被混淆</p>
<p>2.5 gulp-dom-src  and  gulp-cheerio<br>gulp-dom-src  可以对html中的script和link进行操作。<br>eg：–这样可以直接操作index.html中的script 和link的引用文件。<br>[图片]因为我们要复制一个dist文件出来，对原有的www的文件不要做变更；所以我们还是不是直接对index.html中的文件进行操作。<br>gulp-cheerio有点强大；他可以帮忙我们操作html中的dom元素；我们在合并了js、css之后，要修改index.html中的引用文件；可以直接使用gulp-cheerio进行操作；其使用的还是jq中的方法。<br>eg：<br>[图片]如上；可以使用append()进行插入；但因为append()只是插入到当前元素内部最后一个；害怕位置不一样的话导致引用效果不一样的话，我们可以变更引用的位置。如：<br>$(‘<link rel="stylesheet" href="css/bootstrap.min.css">‘).insertBefore(‘head&gt;style’);</p>
<p>还有一个坑需要注意下：index.html中引用的文件是有顺序的，合并的时候是否需要按照顺序来合并？<br>  ● 普通的只使用gulp-src目前就是按照文件的顺序(在文件夹中的首字母排序)进行合并的；这样访问页面有错误；<br>  ● 使用gulp-src([‘a.js’,’b.js’,’c.js’]).pipe(concat())可以实现按照自己想要的顺序进行排序，这样js依赖就不会出错；<br>  ● 看网上有介绍gulp-order可以进行排序；实验了下，不能按照自己想要的顺序进行排序。至于为什么不能排序；以后再研究。</p>
<p>2.6 gulp-src<br>gulp-src 中匹配对应的文件；可使用正则。<br>排除kaifanla.js的写法如下：<br>gulp.src([‘www/js/*.js’,’!kaifanla.js’]);<br>2.7 gulp-ng-html2js<br>gulp-ng-html2js是对angularjs中的templates html片段整合成js文件；angular项目的混淆作用。</p>
<p>用法步骤如下：<br>  ● 先复制index.html  和 aaa.js文件到dist文件；<br>  ● 合并外部js文件到dist。—all.min.js文件；<br>  ● 使用ng-html2js插件，对tpl中的html文档进行整合。<br>gulp.task(‘html2js’, function () {<br>  return gulp.src(“www/tpl/*.html”)//原路径<br>                            .pipe(html2js({<br>                             moduleName: “template”<br>    }))//html模板转js文件<br>    .pipe(concat(“templates.js”))//合并<br>//  .pipe(uglify({compress:false}))//压缩<br>    .pipe(gulp.dest(“dist/js/“));//目标路径<br>});<br>  ● 这样dist的目录是这样的：<br>[图片]  ●   修改index.html中文件的引用为：</p>
<p><script src="js/libs.min.js"></script></p>
<p><script src="js/aaa.js"></script></p>
<p><script src="js/templates.js"></script><br>  ● 接下来修改aaa.js文件：<br>第一处：因为templates.js中的module为template；所以aaa.js中的module就要依赖template<br>[图片]第二处： 修改路由。<br>[图片]按照如上的这个方法；找到templates.js中查看a,b分别代表什么；将aaa.js中的路由都替换成a。<br>[图片][图片][图片]</p>
<p>问题：Handlebars.js 模板引擎<br>解决：<br>Handlebars.js同jade和ejs一样都是模板引擎。<br>Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用”Logic-less template”（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。Handlebars兼容Mustache，你可以在Handlebars中导入Mustache模板。 </p>
<p>问题：Node批量处理文件名<br>解决：<br>node使用fs模块进行批量修改文件名<br>注意：需要node环境</p>
<p>使用：1：代码目录新建src文件夹<br>           2：需要处理的文件存入src文件夹<br>           3：当前目录运行node rename -n 文件名 -i 文件名增量</p>
<pre><code>var fs = require(&apos;fs&apos;),
    src = &apos;src&apos;,
    dist = &apos;dist&apos;,
    stat = fs.stat;

var args = process.argv.slice(2),name,index=0;

//show help
if (args.length === 0 || args[0].match(&apos;help&apos;)) {
    console.log(&apos;--help\n\t-n  file name 文件名\n\t-i  file name index 文件索引\n&apos;);
}

args.forEach(function (item, _index) {
    if (item.match(&apos;-n&apos;)) {
        name = args[_index + 1];
    } else if (item.match(&apos;-i&apos;)) {
        index = args[_index + 1];
    }
});

//read file directors
fs.readdir(src, function (err, files) {
    if (err) {
        console.log(err);
    } else {
        fs.exists(dist, function (exist) {
            if (exist) {
                copy(files);
            } else {
                fs.mkdir(dist, function () {
                    copy(files);
                })
            }
        });
    }

    function copy(_files) {
        //foreach files
        _files.forEach(function (filename) {
            var readStream, writeStream;
            var arr = filename.split(&apos;.&apos;);
            var oldPath = src + &apos;/&apos; + filename,
                newPath = dist + &apos;/&apos; + name + index + &apos;.&apos; + arr[arr.length - 1];
            stat(oldPath, function (err, file) {
                if (err) {
                    console.log(err);
                } else if (file.isFile()) {
                    //create read stream
                    readStream = fs.createReadStream(oldPath);
                    //create write stream
                    writeStream = fs.createWriteStream(newPath);
                    //pipe copy
                    readStream.pipe(writeStream);
                }
            });
            index++;
        })
    }
});           
</code></pre><p>效果：</p>
<div align="center"><br><img src="/images/nodejs/1_3.png"><br><img src="/images/nodejs/1_4.png"><br></div>


<p>问题：Grunt讲解<br>解决：<br>Grunt和Grunt的插件都是通过Node.js的包管理器npm来安装和管理的。</p>
<p>Grunt 0.4.x要求Node.js的版本&gt;=0.8.0(也就是0.8.0及以上版本的Node.js才能很好的运行Grunt)。</p>
<p>安装Grunt之前，可以在命令行中运行node -v查看你的Node.js版本。<br>安装CLI<br>如果你是从Grunt 0.3升级而来的，请查看Grunt 0.3的说明。(在这篇文档的底部)</p>
<p>为了方便使用Grunt，你应该在全局范围内安装Grunt的命令行接口(CLI)。要做到这一点，你可能需要使用sudo(OS X，*nix，BSD等平台中)权限或者作为超级管理员(Windows平台)来运行shell命令。</p>
<p>npm install -g grunt-cli<br>这条命令将会把grunt命令植入到你的系统路径中，这样就允许你从任意目录来运行它(定位到任意目录运行grunt命令)。</p>
<p>注意，安装grunt-cli并不等于安装了grunt任务运行器！Grunt CLI的工作很简单：在Gruntfile所在目录调用运行已经安装好的相应版本的Grunt。这就意味着可以在同一台机器上同时安装多个版本的Grunt。</p>
<p>CLI如何工作<br>每次运行grunt时，它都会使用node的require()系统查找本地已安装好的grunt。正因为如此，你可以从你项目的任意子目录运行grunt。</p>
<p>如果找到本地已经安装好的Grunt，CLI就会加载这个本地安装好的Grunt库，然后应用你项目中的Gruntfile中的配置(这个文件用于配置项目中使用的任务，Grunt也正是根据这个文件中的配置来处理相应的任务)，并执行你所指定的所有任务。</p>
<p>想要真正的了解这里发生了什么，可以阅读源码。这份代码很短。</p>
<p>用一个现有的Grunt项目进行工作<br>假设已经安装好Grunt CLI并且项目也已经使用一个package.json和一个Gruntfile文件配置好了，那么接下来用Grunt进行工作就非常容易了：</p>
<p>进入到项目的根目录(在命令行面板定位到项目根目录。在windows系统下，也可以进入项目根目录的文件夹后，按Shift+鼠标右键，打开右键菜单，选择“在此处打开命令窗口(W)”)。<br>运行npm install安装项目相关依赖(插件，Grunt内置任务等依赖)。<br>使用grunt(命令)运行Grunt。<br>就是这么简单。已经安装的Grunt任务可以通过运行grunt –help列出来，但是通常最好还是先查看一下项目的文档。</p>
<p>准备一个新的Grunt项目<br>一个典型的配置过程通常只涉及到两个文件：package.json和Gruntfile。</p>
<p>package.json：这个文件被用来存储已经作为npm模块发布的项目元数据(也就是依赖模块)。你将在这个文件中列出你的项目所依赖的Grunt(通常我们在这里配置Grunt版本)和Grunt插件(相应版本的插件)。</p>
<p>Gruntfile：通常这个文件被命名为Gruntfile.js或者Gruntfile.coffee，它用于配置或者定义Grunt任务和加载Grunt插件。</p>
<p>package.json</p>
<p>package.json与Gruntfile相邻，它们都应该归属于项目的根目录中，并且应该与项目的源代码一起被提交。在上述目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖。</p>
<p>这里有一些为项目创建package.json文件的方式：</p>
<p>大多数的grunt-init模板都会自动创建一个项目特定的package.json文件。</p>
<p>npm init命令会自动创建一个基本的package.json文件。</p>
<p>从下面的例子开始并根据规范来按需扩展。</p>
<p>{<br>    “name”: “my-project-name”, // 项目名称<br>    “version”: “0.1.0”, // 项目版本<br>    “devDependencies”: { // 项目依赖<br>        “grunt”: “~0.4.1”, // Grunt库<br>        “grunt-contrib-jshint”: “~0.6.0”, //以下三个是Grunt内置任务<br>        “grunt-contrib-nodeunit”: “~0.2.0”,<br>        “grunt-contrib-uglify”: “~0.2.2”<br>    }<br>}<br>原文中注释仅作说明，使用时请自行检查编辑。其他地方如有雷同，参考这条提示。<br>安装Grunt和grunt插件</p>
<p>添加Grunt和Grunt插件到一个现有的package.json中最简单的方式就是使用npm install <module> –save-dev命令。这不仅会在本地安装<module>，它还会使用一个波浪形字符的版本范围自动将所安装的<module>添加到项目依赖中。</module></module></module></p>
<p>例如使用下面的命令将会安装最新版的Grunt到你的项目中，并自动将它添加到你的项目依赖中：</p>
<p>npm install grunt –save-dev<br>上述命令也可以用于Grunt插件和其他的node模块的安装。当完成操作后请确保更新后的package.json文件也要与你的项目一起提交。</p>
<p>Gruntfile</p>
<p>Gruntfile.js或者Gruntfile.coffee文件都是归属于你项目根目录中的一个有效的JavaScript或者CoffeeScript文件(和package.json文件一样都在根目录中)，并且它(Gruntfile)也应该与你的项目源文件一起提交。</p>
<p>一个Gruntfile由下面几部分组成：</p>
<p>“wrapper”函数(包装函数)<br>项目和任务配置<br>加载的Grunt插件和任务<br>自定义任务<br>一个Gruntfile示例</p>
<p>在下面的Gruntfile中，项目的元数据会从项目的package.json文件中导入到grunt配置中，同时grunt-contrib-uglify插件的uglify任务被配置用于压缩一个源文件，同时使用该元数据(导入的元数据)动态的生成一个标语(banner)注释。在命令行运行grunt时默认会运行uglify任务。</p>
<p>module.exports = function(grunt){</p>
<pre><code>// 项目配置
grunt.initConfig({
    pkg: grunt.file.readJSON(&apos;package.json&apos;),
    uglify: {
        options: {
            banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n&apos;
        },
        build: {
            src: &apos;src/&lt;%=pkg.name %&gt;.js&apos;,
            dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos;
        }               
    }
});

// 加载提供&quot;uglify&quot;任务的插件
grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);

// 默认任务
grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);
</code></pre><p>}<br>现在你已经看到到了一个完整的Gruntfile，下面让我们来看看它的各个组成部分：</p>
<p>”wrapper”函数</p>
<p>每个Gruntfile(和Grunt插件)都使用这个基本格式，并且所有你的Grunt代码都必须指定在这个函数里面：</p>
<p>module.exports = function(grunt) {<br>    // 在这里处理Grunt相关的事情<br>}<br>项目和任务配置</p>
<p>大多数Grunt任务所依赖的配置数据都被定义在传递给grunt.initConfig方法的一个对象中。</p>
<p>在这个例子中，grunt.file.readJSON(‘package.json’)会把存储在package.json中的JSON元数据导入到Grunt配置中。由于&lt;% %&gt;模板字符串可以引用任意的配置属性，因此可以通过这种方式来指定诸如文件路径和文件列表类型的配置数据，从而减少一些重复的工作(比如我们通常需要通过复制粘贴的方式来在不同的地方引用同一属性, 使用&lt;% %&gt;的方式可以简单的理解为将某些特定的数据存储在变量中，然后在其他地方像使用变量一样就可以使用这些数据属性)。</p>
<p>你可以在这个配置对象中(传递给initConfig()方法的对象)存储任意的数据，只要它不与你任务配置所需的属性冲突，否则会被忽略。此外，由于这本身就是JavaScript，你不仅限于使用JSON；你可以在这里使用任意的有效的JS代码。如果有必要，你甚至可以以编程的方式生成配置。</p>
<p>与大多数任务一样，grunt-contrib-uglify插件的uglify任务要求它的配置被指定在一个同名属性中。在这里有一个例子, 我们指定了一个banner选项(用于在文件顶部生成一个注释)，紧接着是一个单一的名为build的uglify目标，用于将一个js文件压缩为一个目标文件(比如将src目录jquery-1.9.0.js压缩为jquery-1.9.0.min.js然后存储到dest目录)。</p>
<p>// 项目配置<br>grunt.initConfig({<br>    pkg: grunt.file.readJSON(‘package.json’),<br>    uglify: {<br>        options: {<br>            banner: ‘/<em>! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(“yyyy-mm-dd”) %&gt; </em>/\n’<br>        },<br>        build: {<br>            src: ‘src/&lt;%=pkg.name %&gt;.js’,<br>            dest: ‘build/&lt;%= pkg.name %&gt;.min.js’<br>        }<br>    }<br>});<br>加载grunt插件和任务</p>
<p>许多常用的任务像concatenation，minification和linting都被作为grunt插件来使用。只要一个插件被作为一个依赖指定在项目的package.json文件中，并且已经通过npm install安装好，都可以在你的Gruntfile文件中使用下面这个简单的命令启用它(所依赖的任务)。</p>
<p>// 加载提供”uglify”任务的插件<br>grunt.loadNpmTasks(‘grunt-contrib-uglify’);<br>注意: grunt –help命令可以列出所有可用的任务。</p>
<p>自定义任务</p>
<p>你可以通过定义一个default任务来配置Grunt，让它默认运行一个或者多个任务。在下面的例子中，在命令行中运行grunt而不指定特定的任务将自动运行uglify任务。这个功能与显示的运行grunt uglify或者等价的grunt default一样。你可以在任务参数数组中指定任意数量的任务(这些任务可以带参数，也可以不带参数)。</p>
<p>// 默认任务<br>grunt.registerTask(‘default’, [‘uglify’]);<br>如果你的项目所需的任务没有对应的Grunt插件提供相应的功能，你可以在Gruntfile内定义自定义的任务。例如，下面的Gruntfile就定义了一个完整的自定义的default任务，它甚至没有利用任务配置(没有使用grunt.initConfig()方法)：</p>
<p>module.exports = function(grunt) {<br>    // 一个非常基础的default任务<br>    grunt.registerTask(‘default’, ‘Log some stuff.’, function() {<br>        grunt.log.write(‘Logging some stuff…’).ok();<br>    });<br>};<br>自定义的项目特定的任务可以不定义在Gruntfile中；它们可以定义在一个外部.js文件中，然后通过grunt.loadTasks方法来加载。</p>
<p>扩展阅读<br>安装Grunt指南中有关于安装特定版本的，发布的或者开发中版本的Grunt和Grunt-cli的详细信息。</p>
<p>配置任务指南中有对于如何在Gruntfile中配置任务，目标，选项和文件的详细解释，还有模板，匹配模式和导入外部数据相关的说明。</p>
<p>创建任务指南列出了Grunt任务类型之间的不同，还展示了许多实例任务和配置。</p>
<p>对于关于编写自定义任务或者Grunt插件的更多信息，请参考开发者文档。</p>
<p>Grunt 0.3说明<br>如果你从Grunt 0.3升级而来的，请确保先卸载全局的grunt(使用下面的命令)：</p>
<p>npm uninstall -g grunt<br>上面这些说明文档是针对Grunt 0.4.x编写的，但仍然适用于Grunt 0.3.x。只是注意0.3.x版本中的插件名称和任务配置选项可能与上面的”Gruntfile”中所展示的不同。</p>
<p>对于0.3.x版本的Grunt, Grunfile名为grunt.js。</p>
<p>问题：</p>
<ul>
<li>解决：<br>目前主流的node版本管理工具有两种，nvm和n。<br>管理 node 版本，选择 nvm 还是 n？总的来说，nvm有点类似于 Python 的 virtualenv 或者 Ruby 的 rvm，每个node版本的模块都会被安装在各自版本的沙箱里面（因此切换版本后模块需重新安装），因此考虑到需要时常对node版本进行切换测试兼容性和一些模块对node版本的限制，我选择了使用nvm作为管理工具，下面就来说说nvm的安装和使用过程。</li>
</ul>
<p>问题：node之assert<br>node.js 组件 – assert</p>
<p>概念<br>assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。该模块提供11个方法，但只有少数几个是常用的。</p>
<ol>
<li><p>assert()<br>assert方法接受两个参数，当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。</p>
<p> // 格式<br> assert(value, message)</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> function add (a, b) {<br>   return a + b;<br> }</p>
<p> var expected = add(1,2);<br> assert( expected === 3, ‘预期1加2等于3’);</p>
</li>
</ol>
<p>上面代码不会有任何输出，因为assert方法的第一个参数是true。</p>
<pre><code>assert( expected === 4, &apos;预期1加2等于3&apos;)
// AssertionError: 预期1加2等于3
</code></pre><p>上面代码会抛出一个错误，因为assert方法的第一个参数是false。</p>
<ol>
<li><p>assert.ok()<br>ok是assert方法的另一个名字，与assert方法完全一样。</p>
</li>
<li><p>assert.equal()<br>equal方法接受三个参数，第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。</p>
<p> // 格式<br> assert.equal(actual, expected, [message])</p>
<p> assert.equal(true, value, message);<br> // 等同于<br> assert(value, message);</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> function add (a, b) {<br>   return a + b;<br> }</p>
<p> var expected = add(1,2);</p>
<p> // 以下三句效果相同<br> assert(expected == 3, ‘预期1+2等于3’);<br> assert.ok(expected == 3, ‘预期1+2等于3’);<br> assert.equal(expected, 3, ‘预期1+2等于3’);    </p>
</li>
</ol>
<p>equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。</p>
<ol>
<li><p>assert.notEqual()<br>notEqual方法的用法与equal方法类似，但只有在实际值等于预期值时，才会抛出错误。</p>
<p> // 格式<br> assert.equal(actual, expected, [message])</p>
<p> assert.equal(true, value, message);<br> // 等同于<br> assert(value, message);</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> function add (a, b) {<br>   return a + b;<br> }</p>
<p> var expected = add(1,2);</p>
<p> // 以下三句效果相同<br> assert(expected == 3, ‘预期1+2等于3’);<br> assert.ok(expected == 3, ‘预期1+2等于3’);<br> assert.equal(expected, 3, ‘预期1+2等于3’);    </p>
</li>
</ol>
<p>equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。</p>
<ol>
<li><p>assert. deepEqual()<br>deepEqual方法用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。</p>
<p> // 格式<br> assert.deepEqual(actual, expected, [message])</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> var list1 = [1, 2, 3, 4, 5];<br> var list2 = [1, 2, 3, 4, 5];</p>
<p> assert.deepEqual(list1, list2, ‘预期两个数组应该有相同的属性’);</p>
<p> var person1 = { “name”:”john”, “age”:”21” };<br> var person2 = { “name”:”john”, “age”:”21” };</p>
<p> assert.deepEqual(person1, person2, ‘预期两个对象应该有相同的属性’);    </p>
</li>
<li><p>assert. notDeepEqual()<br>notDeepEqual方法与deepEqual方法正好相反，用来断言两个对象是否不相等。</p>
<p> // 格式<br> assert.notDeepEqual(actual, expected, [message])</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> var list1 = [1, 2, ,3, 4, 5];<br> var list2 = [1, 2, 3, 4, 5];</p>
<p> assert.notDeepEqual(list1, list2, ‘预期两个对象不相等’);</p>
<p> var person1 = { “name”:”john”, “age”:”21” };<br> var person2 = { “name”:”jane”, “age”:”19” };</p>
<p> // deepEqual checks the elements in the objects are identical<br> assert.notDeepEqual(person1, person2, ‘预期两个对象不相等’);    </p>
</li>
<li><p>assert. strictEqual()<br>strictEqual方法使用严格相等运算符（===），比较两个表达式。</p>
<p> // 格式<br> assert.strictEqual(actual, expected, [message])</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> assert.strictEqual(1, ‘1’, ‘预期严格相等’);<br> // AssertionError: 预期严格相等    </p>
</li>
<li><p>assert. notStrictEqual()<br>assert.notStrictEqual方法使用严格不相等运算符（!==），比较两个表达式。</p>
<p> // 格式<br> assert.notStrictEqual(actual, expected, [message])</p>
<p> // 例子<br> var assert = require(‘assert’);</p>
<p> assert.notStrictEqual(1, true, ‘预期严格不相等’);    </p>
</li>
<li><p>assert. throws()<br>throws方法预期某个代码块会抛出一个错误，且抛出的错误符合指定的条件。</p>
<p> // 格式<br> assert.throws(block, [error], [message])</p>
<p> // 例一，抛出的错误符合某个构造函数<br> assert.throws(<br>   function() {</p>
<pre><code>throw new Error(&quot;Wrong value&quot;);
</code></pre><p>   },<br>   Error,<br>   ‘不符合预期的错误类型’<br> );</p>
<p> // 例二、抛出错误的提示信息符合正则表达式<br> assert.throws(<br>   function() {</p>
<pre><code>throw new Error(&quot;Wrong value&quot;);
</code></pre><p>   },<br>   /value/,<br>   ‘不符合预期的错误类型’<br> );</p>
<p> // 例三、抛出的错误符合自定义函数的校验<br> assert.throws(<br>   function() {</p>
<pre><code>throw new Error(&quot;Wrong value&quot;);
</code></pre><p>   },<br>   function(err) {</p>
<pre><code>if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
  return true;
}
</code></pre><p>   },<br>   ‘不符合预期的错误类型’<br> );    </p>
</li>
<li><p>assert. doesNotThrow()<br>doesNotThrow方法与throws方法正好相反，预期某个代码块不抛出错误。</p>
<p>// 格式<br>assert.doesNotThrow(block, [message])</p>
<p>// 用法<br>assert.doesNotThrow(<br>  function() {</p>
<pre><code>console.log(&quot;Nothing to see here&quot;);
</code></pre><p>  },<br>  ‘预期不抛出错误’<br>);    </p>
</li>
<li><p>assert. ifError()<br>ifError方法断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。</p>
<p>// 格式<br>assert.ifError(value)</p>
<p>// 用法<br>function sayHello(name, callback) {<br>  var error = false;<br>  var str   = “Hello “+name;<br>  callback(error, str);<br>}</p>
<p>// use the function<br>sayHello(‘World’, function(err, value){<br>  assert.ifError(err);<br>  // …<br>})    </p>
</li>
<li><p>assert. fail()<br>fail方法用于抛出一个错误。</p>
<p>// 格式<br>assert.fail(actual, expected, message, operator)</p>
<p>// 例子<br>var assert = require(‘assert’);</p>
<p>assert.fail(21, 42, ‘Test Failed’, ‘###’)<br>// AssertionError: Test Failed<br>assert.fail(21, 21, ‘Test Failed’, ‘###’)<br>// AssertionError: Test Failed<br>assert.fail(21, 42, undefined, ‘###’)<br>// AssertionError: 21 ### 42</p>
</li>
</ol>
<p>该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”    </p>
<p>问题：node之buffer<br>Buffer对象是Node处理二进制数据的一个接口。它是Node原生提供的全局对象，可以直接使用，不需要require(‘buffer’)。<br>JavaScript比较擅长处理字符串，对于处理二进制数据（比如TCP数据流），就不太擅长。Buffer对象就是为了解决这个问题而设计的。它是一个构造函数，生成的实例代表了V8引擎分配的一段内存，是一个类似数组的对象，成员都为0到255的整数值，即一个8位的字节。<br><a href="http://www.qdfuns.com/notes/15571/0f382a1878c9716eabc486ac853a8cba.html" target="_blank" rel="external">http://www.qdfuns.com/notes/15571/0f382a1878c9716eabc486ac853a8cba.html</a></p>
<p>问题:webpack<br>细说 webpack 之流程篇<br>目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。<br>Webpack 是一个前端资源加载/打包工具，React 是一个Facebook 和Instagram 用来创建用户界面的JavaScript 库。两个都是非常有用的技术，如果同时使用他们，前端开发会更加有趣。<br>问题：node之node-schedule<br>node-schedule实现定时任务</p>
<p>问题；node之nodemailer<br>nodemailer发送邮件</p>
<p>问题：node之Events<br>Events模块是Node对“发布/订阅”模式（publish/subscribe）的实现。一个对象通过这个模块，向另一个对象传递消息。<br><a href="http://www.qdfuns.com/notes/15571/ab98cf32de6e4258b75204b2027942f9.html" target="_blank" rel="external">http://www.qdfuns.com/notes/15571/ab98cf32de6e4258b75204b2027942f9.html</a></p>
<p>问题：node之mime<br>概述<br>先说说什么是mime类型？ 然后介绍两种设置mime类型的方法，第一种是通过后缀名判断文件类型，从而进行响应；第二种是使用第三方mime模块进行响应。<br>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。（百度百科）<br>简单点说，mime是一个互联网标准，通过设定它就可以设定文件在浏览器的打开方式。<br><a href="http://www.qdfuns.com/notes/15571/042cfeed2e04a4158d630bfcabb0cb13.html" target="_blank" rel="external">http://www.qdfuns.com/notes/15571/042cfeed2e04a4158d630bfcabb0cb13.html</a></p>
<p>问题：node之child Process<br>child_process模块用于新建子进程。子进程的运行结果储存在系统缓存之中（最大200KB），等到子进程运行结束以后，主进程再用回调函数读取子进程的运行结果<br>通过child_process模块可以创建子进程，从而实现多进程模式，更好地利用CPU多核计算资源。该模块提供了四种方法创建子进程，分别是child_process.spawn()、child_process.exec()、child_process.execFile()，child_process.fork()，这四个方法都返回一个childProcess对象，该对象实现了EventEmitter的接口，带有stdout，stdin，stderr的对象。<br><a href="http://www.qdfuns.com/notes/15571/bcdd087c62122c9f9923a1967889a2c1.html" target="_blank" rel="external">http://www.qdfuns.com/notes/15571/bcdd087c62122c9f9923a1967889a2c1.html</a></p>
<p>问题：node之cluster<br>. 概述<br>1.1 基本用法<br>Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。<br>cluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。worker之间采用进程间通信交换消息，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个worker进程之间的负载。运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。<br>Node.js是单线程运行的，不管你的机器有多少个内核，只能用到其中的一个，为了能利用多核计算资源，需要使用多进程来处理应用。cluster模块让我们可以很容易地创建一个负载均衡的集群，自动分配CPU多核资源。<br>    var cluster = require(‘cluster’);<br>    var os = require(‘os’);</p>
<pre><code>if (cluster.isMaster){
  for (var i = 0, n = os.cpus().length; i &lt; n; i += 1){
    cluster.fork();
  }
} else {
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}
</code></pre><p>上面代码先判断当前进程是否为主进程（cluster.isMaster），如果是的，就按照CPU的核数，新建若干个worker进程；如果不是，说明当前进程是worker进程，则在该进程启动一个服务器程序。<br>上面这段代码有一个缺点，就是一旦work进程挂了，主进程无法知道。为了解决这个问题，可以在主进程部署online事件和exit事件的监听函数。</p>
<pre><code>var cluster = require(&apos;cluster&apos;);

if(cluster.isMaster) {
  var numWorkers = require(&apos;os&apos;).cpus().length;
  console.log(&apos;Master cluster setting up &apos; + numWorkers + &apos; workers...&apos;);

  for(var i = 0; i &lt; numWorkers; i++) {
    cluster.fork();
  }

  cluster.on(&apos;online&apos;, function(worker) {
    console.log(&apos;Worker &apos; + worker.process.pid + &apos; is online&apos;);
  });

  cluster.on(&apos;exit&apos;, function(worker, code, signal) {
    console.log(&apos;Worker &apos; + worker.process.pid + &apos; died with code: &apos; + code + &apos;, and signal: &apos; + signal);
    console.log(&apos;Starting a new worker&apos;);
    cluster.fork();
  });
}
</code></pre><p>上面代码中，主进程一旦监听到worker进程的exit事件，就会重启一个worker进程。worker进程一旦启动成功，可以正常运行了，就会发出online事件。<br>1.2 worker对象<br>worker对象是cluster.fork()的返回值，代表一个worker进程。<br>它的属性和方法如下。<br>（1）worker.id<br>worker.id返回当前worker的独一无二的进程编号。这个编号也是cluster.workers中指向当前进程的索引值。</p>
<p>（2）worker.process<br>所有的worker进程都是用child_process.fork()生成的。child_process.fork()返回的对象，就被保存在worker.process之中。通过这个属性，可以获取worker所在的进程对象。<br>（3）worker.send()<br>该方法用于在主进程中，向子进程发送信息。    </p>
<pre><code>if (cluster.isMaster) {
  var worker = cluster.fork();
  worker.send(&apos;hi there&apos;);
} else if (cluster.isWorker) {
  process.on(&apos;message&apos;, function(msg) {
    process.send(msg);
  });
}
</code></pre><p>上面代码的作用是，worker进程对主进程发出的每个消息，都做回声。<br>在worker进程中，要向主进程发送消息，使用process.send(message)；要监听主进程发出的消息，使用下面的代码。</p>
<pre><code>process.on(&apos;message&apos;, function(message) {
  console.log(message);
});    
</code></pre><p>发出的消息可以字符串，也可以是JSON对象。下面是一个发送JSON对象的例子。</p>
<pre><code>worker.send({
  type: &apos;task 1&apos;,
  from: &apos;master&apos;,
  data: {
    // the data that you want to transfer
  }
});    
</code></pre><p>1.3 cluster.workers对象<br>该对象只有主进程才有，包含了所有worker进程。每个成员的键值就是一个worker进程对象，键名就是该worker进程的worker.id属性。</p>
<pre><code>function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id]);
  }
}
eachWorker(function(worker) {
  worker.send(&apos;big announcement to all workers&apos;);
});
</code></pre><p>上面代码用来遍历所有worker进程。<br>当前socket的data事件，也可以用id属性识别worker进程。    </p>
<pre><code>socket.on(&apos;data&apos;, function(id) {
  var worker = cluster.workers[id];
});
</code></pre><ol>
<li>cluster模块的属性与方法<br>2.1 isMaster，isWorker<br>isMaster属性返回一个布尔值，表示当前进程是否为主进程。这个属性由process.env.NODE_UNIQUE_ID决定，如果process.env.NODE_UNIQUE_ID为未定义，就表示该进程是主进程。</li>
</ol>
<p>isWorker属性返回一个布尔值，表示当前进程是否为work进程。它与isMaster属性的值正好相反。</p>
<p>2.2 fork<br>fork方法用于新建一个worker进程，上下文都复制主进程。只有主进程才能调用这个方法。</p>
<p>该方法返回一个worker对象。</p>
<p>2.3 kill<br>kill方法用于终止worker进程。它可以接受一个参数，表示系统信号。</p>
<p>如果当前是主进程，就会终止与worker.process的联络，然后将系统信号法发向worker进程。如果当前是worker进程，就会终止与主进程的通信，然后退出，返回0。</p>
<p>在以前的版本中，该方法也叫做 worker.destroy() 。</p>
<p>2.4 listening事件<br>worker进程调用listening方法以后，“listening”事件就传向该进程的服务器，然后传向主进程。</p>
<p>该事件的回调函数接受两个参数，一个是当前worker对象，另一个是地址对象，包含网址、端口、地址类型（IPv4、IPv6、Unix socket、UDP）等信息。这对于那些服务多个网址的Node应用程序非常有用。</p>
<pre><code>cluster.on(&apos;listening&apos;, function (worker, address) {
  console.log(&quot;A worker is now connected to &quot; + address.address + &quot;:&quot; + address.port);
});    
</code></pre><ol>
<li>不中断地重启Node服务<br>3.1 思路<br>重启服务需要关闭后再启动，利用cluster模块，可以做到先启动一个worker进程，再把原有的所有work进程关闭。这样就能实现不中断地重启Node服务。</li>
</ol>
<p>首先，主进程向worker进程发出重启信号。</p>
<p>workers[wid].send({type: ‘shutdown’, from: ‘master’});</p>
<p>worker进程监听message事件，一旦发现内容是shutdown，就退出。</p>
<p>process.on(‘message’, function(message) {<br>  if(message.type === ‘shutdown’) {<br>    process.exit(0);<br>  }<br>});</p>
<p>下面是一个关闭所有worker进程的函数。</p>
<pre><code>function restartWorkers() {
  var wid, workerIds = [];
  for(wid in cluster.workers) {
    workerIds.push(wid);
  }

  workerIds.forEach(function(wid) {
    cluster.workers[wid].send({
      text: &apos;shutdown&apos;,
      from: &apos;master&apos;
     });
    setTimeout(function() {
      if(cluster.workers[wid]) {
        cluster.workers[wid].kill(&apos;SIGKILL&apos;);
      }
    }, 5000);
  });
};    
</code></pre><p>3.2 实例<br>下面是一个完整的实例，先是主进程的代码master.js。</p>
<p>var cluster = require(‘cluster’);</p>
<p>console.log(‘started master with ‘ + process.pid);</p>
<p>// 新建一个worker进程<br>cluster.fork();</p>
<p>process.on(‘SIGHUP’, function () {<br>  console.log(‘Reloading…’);<br>  var new_worker = cluster.fork();<br>  new_worker.once(‘listening’, function () {<br>    // 关闭所有其他worker进程<br>    for(var id in cluster.workers) {<br>      if (id === new_worker.id.toString()) continue;<br>      cluster.workers[id].kill(‘SIGTERM’);<br>    }<br>  });<br>});</p>
<p>上面代码中，主进程监听SIGHUP事件，如果发生该事件就关闭其他所有worker进程。之所以是SIGHUP事件，是因为nginx服务器监听到这个信号，会创造一个新的worker进程，重新加载配置文件。另外，关闭worker进程时，主进程发送SIGTERM信号，这是因为Node允许多个worker进程监听同一个端口。</p>
<p>下面是worker进程的代码server.js。</p>
<pre><code>var cluster = require(&apos;cluster&apos;);

if (cluster.isMaster) {
  require(&apos;./master&apos;);
  return;
}

var express = require(&apos;express&apos;);
var http = require(&apos;http&apos;);
var app = express();

app.get(&apos;/&apos;, function (req, res) {
  res.send(&apos;ha fsdgfds gfds gfd!&apos;);
});

http.createServer(app).listen(8080, function () {
  console.log(&apos;http://localhost:8080&apos;);
});
</code></pre><p>使用时代码如下。</p>
<pre><code>$ node server.js
started master with 10538
http://localhost:8080      
</code></pre><p>然后，向主进程连续发出两次SIGHUP信号。</p>
<pre><code>$ kill -SIGHUP 10538
$ kill -SIGHUP 10538    
</code></pre><p>主进程会连续两次新建一个worker进程，然后关闭所有其他worker进程，显示如下。</p>
<pre><code>Reloading...
http://localhost:8080
Reloading...
http://localhost:8080    
</code></pre><p>最后，向主进程发出SIGTERM信号，关闭主进程。</p>
<pre><code>$ kill 10538
</code></pre><ol>
<li><p>PM2模块<br>PM2模块是cluster模块的一个包装层。它的作用是尽量将cluster模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。</p>
<p> // app.js<br> var http = require(‘http’);</p>
<p> http.createServer(function(req, res) {<br>   res.writeHead(200);<br>   res.end(“hello world”);<br> }).listen(8080);    </p>
</li>
</ol>
<p>上面代码是标准的Node架设Web服务器的方式，然后用PM2从命令行启动这段代码。</p>
<pre><code>$ pm2 start app.js -i 4    
</code></pre><p>上面代码的i参数告诉PM2，这段代码应该在cluster_mode启动，且新建worker进程的数量是4个。如果i参数的值是0，那么当前机器有几个CPU内核，PM2就会启动几个worker进程。<br>如果一个worker进程由于某种原因挂掉了，会立刻重启该worker进程。    </p>
<pre><code># 重启所有worker进程
$ pm2 reload all
</code></pre><p>每个worker进程都有一个id，可以用下面的命令查看单个worker进程的详情。</p>
<pre><code>$ pm2 show &lt;worker id&gt;    
</code></pre><p>正确情况下，PM2采用fork模式新建worker进程，即主进程fork自身，产生一个worker进程。pm2 reload命令则会用spawn方式启动，即一个接一个启动worker进程，一个新的worker启动成功，再杀死一个旧的worker进程。采用这种方式，重新部署新版本时，服务器就不会中断服务。</p>
<pre><code>$ pm2 reload &lt;脚本文件名&gt;    
</code></pre><p>关闭worker进程的时候，可以部署下面的代码，让worker进程监听shutdown消息。一旦收到这个消息，进行完毕收尾清理工作再关闭。</p>
<pre><code>process.on(&apos;message&apos;, function(msg) {
  if (msg === &apos;shutdown&apos;) {
    close_all_connections();
    delete_logs();
    server.close();
    process.exit(0);
  }
});    
</code></pre><p>问题：gulp.spritesmith<br>使用gulp.spritesmith插件制作雪碧图<br>注意：插件是gulp.spritesmith，不是gulp-spritesmith<br>插件地址：<a href="https://github.com/twolfson/gulp.spritesmith" target="_blank" rel="external">https://github.com/twolfson/gulp.spritesmith</a></p>
<pre><code>//javascript代码
const gulp = require(&apos;gulp&apos;);
const spritesmith = require(&apos;gulp.spritesmith&apos;);
const dirname = __dirname;

gulp.task(&apos;spritesmith&apos;, function(){
    gulp.src(dirname + &apos;/src/*.png&apos;)
        .pipe(spritesmith({
            imgName: &apos;icons.png&apos;,     // 生成的图片
            cssName: &apos;icons.sass&apos;,    // 生成的sass文件
            padding: 20,              // 图标之间的距离
            algorithm: &apos;binary-tree&apos;, // 图标的排序方式
            cssTemplate: &apos;./handlebarsInheritance.sass.handlebars // 模板
        }))
        .pipe(gulp.dest(dirname + &apos;/build&apos;));
});

gulp.task(&apos;default&apos;, [&apos;spritesmith&apos;]);    

//sass模板
{
// Default options
&apos;functions&apos;: true,
&apos;variableNameTransforms&apos;: [&apos;dasherize&apos;]
}

{{#extend "sass"}}
    {{#content "sprites"}}
.syin
  display: inline-block
$imageurl: &apos;&apos;
        {{#each sprites}}
${{strings.name}}: ({{px.x}}, {{px.y}}, {{px.offset_x}}, {{px.offset_y}}, {{px.width}}, {{px.height}}, {{px.total_width}}, {{px.total_height}}, ($imageurl + &apos;{{{escaped_image}}}&apos;), &apos;syin-{{name}}&apos;)
        {{/each}}
    {{/content}}
    {{#content "spritesheet"}}
${{spritesheet_info.strings.name_sprites}}: ({{#each sprites}}${{strings.name}}, {{/each}})
    {{/content}}
{{/extend}}
</code></pre><p>问题：forever(守护进程)<br>forever作为node的守护进程而存在的，因为node服务端很容易遇到异常就崩溃，在用这个的时候最好给系统添加 异常报警，异常记录之类的措施，不然用了forver也没有起到任何真正的作用， 不能因为有了forever就忽略了try catch，代码里应该多加异常捕捉，防止程序经常出现崩溃的情况。让程序更加健壮。<br>1.下载地址<br><a href="https://github.com/foreverjs/forever" target="_blank" rel="external">https://github.com/foreverjs/forever</a><br>2.安装</p>
<pre><code>npm install forever -gd
</code></pre><p>3.操作</p>
<pre><code>forever --help  //帮助
forever start app.js //启动
forever stop app.js  //停止
forever list  //列表
forever stopall //关闭所有
forever restartall //重启所有    
</code></pre><p>4.日志输出</p>
<pre><code>//指定app.js中的日志信息和错误日志输出文件，  
//  -o 就是console.log输出的信息，-e 就是console.error输出的信息
forever start -o out.log -e err.log app.js 

// 追加日志，forever默认是不能覆盖上次的启动日志，  
//  所以如果第二次启动不加-a，则会不让运行  
forever start -l forever.log -a app.js     
</code></pre><p>5.查看进程</p>
<pre><code>ps -ef|grep node    
</code></pre></div>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/nodejs总结/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-css之光晕效果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/css之光晕效果/">CSS之光晕效果</a>
    </h1>
  

        <a href="/2016/08/18/css之光晕效果/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div align="center"><br> <img src="/images/css/1_1.png" /><br></div>
        <a class="article-more-a"  href="/2016/08/18/css之光晕效果/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/css之光晕效果/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-hexo总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/hexo总结/">hexo</a>
    </h1>
  

        <a href="/2016/08/18/hexo总结/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="问题1-使用localhost-4000访问本地blog一直无响应-但是hexo-server是成功响应的？"><a href="#问题1-使用localhost-4000访问本地blog一直无响应-但是hexo-server是成功响应的？" class="headerlink" title="问题1:使用localhost:4000访问本地blog一直无响应,但是hexo server是成功响应的？"></a>问题1:使用localhost:4000访问本地blog一直无响应,但是hexo server是成功响应的？</h5><p>  答：有可能是端口号被占用，修改端口号  $ hexo server -p 5000</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/hexo总结/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jquery-2.0.3源码及解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/jquery-2.0.3源码及解析/">jquery2.0.3源码及解析</a>
    </h1>
  

        <a href="/2016/08/18/jquery-2.0.3源码及解析/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>/*!
 * jQuery JavaScript Library v2.0.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:30Z
 */
 //匿名函数，(function(){})()叫做匿名函数自执行，防止冲突。undefined我们在传参的时候任意指定的，它就是一个属性
(function( window, undefined ) {

// Can&apos;t do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through &quot;use strict&quot; call chains. (#13335)
// Support: Firefox 18+
//&quot;use strict&quot;;
var
    // A central reference to the root jQuery(document)它和$、jquery是一样的，只是目前我们还没出现$\jquery的定义而已，rootjQuery=$(document)
    rootjQuery,

    // The deferred(延迟) used on DOM ready
    readyList,//延迟列表

    // Support: IE9
    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`，我们得到一个字符串形式的undefined  typeof undefined=&quot;undefined&quot;
    core_strundefined = typeof undefined,

    // Use the correct document accordingly with window argument (sandbox)，window下的变量存储，其实不存储我们也是直接拿过来就可以用的，但是就是有利于压缩的情况
    location = window.location,
    document = window.document,
    //存的就是html标签  var doc=document.documentElement; doc.lastChild;doc.childNodes[0].nodeName
    docElem = document.documentElement,

    // Map over jQuery in case of overwrite，下面2个都是防止命名冲突,在jQuery初始化的时候保存了外部的$和jQuery
    _jQuery = window.jQuery,

    // Map over the $ in case of overwrite
    _$ = window.$,

    // [[Class]] -&gt; type pairs，使用$.type()时候用到,class2type={&apos;[Object String]&apos;:&apos;string&apos;,&apos;[Object Array]&apos;:&apos;array&apos;}
    class2type = {},

    // List of deleted data cache ids, so we can reuse them，以前版本和缓存数据是有关的，but从现在开始已经没什么用处了，just a 空数组
    core_deletedIds = [],

    core_version = &quot;2.0.3&quot;,

    // Save a reference to some core methods，数组的一些操作，方便压缩和后续处理
    core_concat = core_deletedIds.concat,
    core_push = core_deletedIds.push,
    core_slice = core_deletedIds.slice,
    core_indexOf = core_deletedIds.indexOf,
    core_toString = class2type.toString,
    core_hasOwn = class2type.hasOwnProperty,
    core_trim = core_version.trim,

    // Define a local copy of jQuery（局部的，window.jQuery = window.$ = jQuery;使其对外了）
    jQuery = function( selector, context ) {


        // The jQuery object is actually just the init constructor &apos;enhanced&apos;（Jquery.fn.init是这里的构造函数），jQuery.fn就是jQuery的原型，则下面这个语句就是让我们的jquery.prototype下去找init方法
        //这样做的原因主要是和传统的方法比较的，它可以让我们不必手动去先进行初始化操作，直接就初始化了，对于我们调用后续的方法是非常便利的。
        return new jQuery.fn.init( selector, context, rootjQuery );
    },

    // Used for matching numbers，查找匹配数字
    core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

    // Used for splitting on whitespace，匹配单词的
    core_rnotwhite = /\S+/g,

    // A simple way to check for HTML strings
    // Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with &lt;)
    //匹配标签|id
    rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,

    // Match a standalone tag（匹配单标签,例如，&lt;p&gt;&lt;/p&gt;或者&lt;div&gt;&lt;/div&gt;）
    rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/,

    // Matches dashed string for camelizing（IE前缀）
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,//-加上字母或数字的组合转大写，数字虽然不能转为大写，但是可以把-去掉

    // Used by jQuery.camelCase as callback to replace()（驼峰命名）
    fcamelCase = function( all, letter ) {
        return letter.toUpperCase();
    },

    // The ready event handler and self cleanup method（DOM加载完成后执行相应操作）
    completed = function() {
        //load事件：页面资源全部载入（JS/CSS/图片等全部加载完）触发
        //ready事件：原生无ready事件，只有DOMContentLoaded事件。jQuery中的ready事件为，当DOM加载完成触发，此时引用的资源未必已加载完成。
        //
        document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false );
        window.removeEventListener( &quot;load&quot;, completed, false );
        jQuery.ready();
    };

jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used，jQuery的版本
    jquery: core_version,

    constructor: jQuery,//修正指向 不写这个的话， constructor会指向Object,因此你重写了JQuery的prototype。
    /*
    //新建一个构造函数时，会自动在构造函数的prototype对象中新添constructor属性（指向构造函数）。
    但是为了防止原型对象的覆盖，比如：Person.prototype = {};这时里面的constructor指向会出问题，
    需要修正，Person.prototype = { constructor: Person}
    */
    init: function( selector, context, rootjQuery ) {
        var match, elem;

        // HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)，这些都是不正确的选择器
        if ( !selector ) {
            //直接返回，则程序不会往下执行了
            return this;
        }

        // Handle HTML strings($(&apos;#div1&apos;),$(&apos;.box&apos;),$(&apos;div&apos;),$(&apos;#div1 div.box&apos;),$(&apos;&lt;li&gt;&apos;),$(&apos;&lt;li&gt;&lt;/li&gt;&apos;))
        if ( typeof selector === &quot;string&quot; ) {
            if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) {
                // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
                /*
                // $(&quot;&lt;li&gt;&quot;) -&gt;   match = [ null, &quot;&lt;li&gt;&quot;, null ];
        // $(&quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&quot;) -&gt;   match = [ null, &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&quot;, null ];
                *//设定不同类型的选择器所对应的match是不同的，这样才能方便后续处理。
                match = [ null, selector, null ];

            } else {
                /*
                match=null //$(&apos;.box&apos;)
                match=[&apos;#div1&apos;,null,&apos;div1&apos;] //$(&apos;#div1&apos;)
                match=[&apos;&lt;li&gt;hello&apos;,&apos;&lt;li&gt;&apos;,null]  //$(&apos;&lt;li&gt;hello&apos;)

                //   此正则rquickExpr匹配后，会出现以下几种情况：

        // 1. match = null; $(&quot;.box&quot;), $(&quot;div&quot;), $(&quot;#div1 div.box&quot;)

        // 2. match = [&quot;#div1&quot;,null,&quot;div1&quot;];  $(&quot;#div1&quot;)

        // 3. match = [&quot;&lt;li&gt;aaa&quot;,&quot;&lt;li&gt;&quot;,null]; $(&quot;&lt;li&gt;aaa&quot;)
                */
                match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id（匹配创建标签或者是id(后面的指的是id)）
            // $(&quot;#div1&quot;)通过id匹配元素，是在document中执行，不会传入context，所以context为空，因此进入if语句
            if ( match &amp;&amp; (match[1] || !context) ) {

                // HANDLE: $(html) -&gt; $(array)
                if ( match[1] ) {//则说明是match=[&apos;&lt;li&gt;hello&apos;,&apos;&lt;li&gt;&apos;,null]  //$(&apos;&lt;li&gt;hello&apos;)这种情况  // $(&quot;&lt;li&gt;&quot;)， $(&quot;&lt;li&gt;aaa&quot;)，$(&quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&quot;)
                    /*
                    true对应于$(&apos;&lt;li&gt;&apos;,$(document)),这样context[0]就是取得document
                    false对应于$(&apos;&lt;li&gt;&apos;,document),这样context就是取得document
                    所以想得到的就是document

                    //context就是document，因为创建元素只能在document中执行。但是页面里面有iframe时，iframe中的document与页面的document不同，所以$(&quot;&lt;li&gt;&quot;,document)有第二个参数。一般用不上。
                    */
                    context = context instanceof jQuery ? context[0] : context;
                    //$(&quot;&lt;li&gt;&quot;,$(document))，得到原生的document。

                    // scripts is true for back-compat
                    //jQuery.parseHTML返回的是数组，经历过merge操作后则返回的是json数据
                    /*
                    //parseHTML方法：第一个参数传入标签字符串&quot;&lt;li&gt;&quot;，第二个参数传入执行上下文document，第三个参数true代表可以新建script标签&quot;&lt;script&gt;&lt;\/script&gt;&quot;（script前面的反斜杠需要转义，其他标签不需要），false代表不能。返回值是一个数组：$(&quot;&lt;li&gt;&quot;) -&gt;   [&quot;li&quot;],  $(&quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&quot;) -&gt;[&quot;li&quot;,&quot;li&quot;]

          //merge方法是把数组转换成jQuery对象:[&quot;li&quot;] -&gt;  {0:&quot;li&quot;,length:1} ；[&quot;li&quot;,&quot;li&quot;]   -&gt;  {0:&quot;li&quot;,1:&quot;li&quot;,length:2}

          rsingleTag匹配单标签的，$(&quot;&lt;li&gt;&quot;)，$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)
                    */
                    jQuery.merge( this, jQuery.parseHTML(
                        match[1],
                        context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
                        true
                    ) );

                    // HANDLE: $(html, props)（处理单标签，多标签的话是不能进入到这个分支的例如：$(&apos;&lt;li&gt;&lt;/li&gt;&apos;,{title:&apos;hi&apos;,html:&apos;abcd&apos;}).appendTo(&apos;ul&apos;);）
                    if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
                        //$(&quot;&lt;li&gt;&quot;,{title:&quot;hi&quot;,html:&quot;abcd&quot;})  针对这种情况的,context 为json对象
                        for ( match in context ) {
                            // Properties of context are called as methods if possible,处理html:&apos;abcd&apos;
                            if ( jQuery.isFunction( this[ match ] ) ) {//如果属性是jQuery方法，就执行方法
                                this[ match ]( context[ match ] );

                            // ...and otherwise set as attributes
                            } else {//处理title:&apos;hi&apos;
                                this.attr( match, context[ match ] ); //如果不是方法，就设置属性。
                            }
                        }
                    }

                    return this;

                // HANDLE: $(#id),处理id的情况
                } else {
                    elem = document.getElementById( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    // Blackberry 4.6：elem存在，但是页面上没有，所以添加了elem.parentNode，如果都满足，则elem一定存在页面上。
                    if ( elem &amp;&amp; elem.parentNode ) {
                        // Inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {//find方法实际上调用的是sizzle(处理更复杂的选择器)
                return ( context || rootjQuery ).find( selector );
                //rootjQuery  = $(document)

        // 处理这种$(expr, context)，context是否是jQuery对象（context.jquery存在就是jQuery对象），会转换成$(context).find(expr)

        //或者$(expr)，会转换成$(document).find(expr)

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {//如果context存在，但是不是jQuery对象，就执行
                return this.constructor( context ).find( selector );//新建jQuery对象，并调用find方法
            }

        // HANDLE: $(DOMElement)($(this),$(document),$(DOMElement)将DOM对象转化为伪数组返回即可　
        } else if ( selector.nodeType ) {//如果是dom节点,比如：$(document) 
              //节点没有所谓的父级，所以它的执行上下文就是自己本身
            this.context = this[0] = selector;
            this.length = 1;
            return this;

        // HANDLE: $(function),$(function)等同于jQuery.ready(function)
        // Shortcut for document ready(传函数进行处理$(function(){}))
        } else if ( jQuery.isFunction( selector ) ) {//文档加载有两种方式:$(function(){})； $(document).ready(function(){});
            return rootjQuery.ready( selector );
        }
        //HANDLE: $($...),$($...)将参数执行结果（也是一个jQuery实例）包装到this上返回
    //因为$(&apos;#div1&apos;)或者是$($(&apos;#div1&apos;)),所以要验证selector是不是对象形式的。
        if ( selector.selector !== undefined ) {//$($(&quot;#div1&quot;))，当传入jQuery对象时
            this.selector = selector.selector;
            this.context = selector.context;
        }
    //传数组，传json的形式（$([]),$({})）
    //makeArray把selector(类数组)转换成数组(外部使用)，当传入第二个参数时(内部使用)，就会转换成jQuery对象的形式。
        return jQuery.makeArray( selector, this );
    },

    // Start with an empty selector
    selector: &quot;&quot;,

    // The default length of a jQuery object is 0
    length: 0, //匹配到的元素的长度，默认为0.

    toArray: function() {
        //如果不传参的话就会截取全部的
        return core_slice.call( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    //转原生集合，//获取当前集合中某一个或是全部的元素，需要注意的是，这里返回的是DOM节点对象，非jQuery对象,可不能再链式调用了。
    get: function( num ) {
        return num == null ?

            // Return a &apos;clean&apos; array
            //截取全部的元素
            this.toArray() :

            // Return just the object
            //this[ num ]是对应的json找对应的属性，所以[]不是下标，而是找对应属性的情况
            ( num &lt; 0 ? this[ this.length + num ] : this[ num ] );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems ) {

        // Build a new jQuery matched element set  this.constructor()是空的jQUERY对象，神马都没有，merge实现数组或者json的合并
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        //要把之前的对象存储一下，ret应该是将要压入栈的元素
        ret.prevObject = this;
        //对执行上下文进行处理，执行上下文是都没有发生变化的
        ret.context = this.context;

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    },

    ready: function( fn ) {
        // Add the callback
        jQuery.ready.promise().done( fn );

        return this;
    },

    slice: function() {
        return this.pushStack( core_slice.apply( this, arguments ) );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    eq: function( i ) {
        var len = this.length,
            j = +i + ( i &lt; 0 ? len : 0 );
        return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );
    },

    map: function( callback ) {
        //进行二次处理
        return this.pushStack( jQuery.map(this, function( elem, i ) {
            return callback.call( elem, i, elem );
        }));
    },

    end: function() {//回溯到当前栈顶的上一级
        //回溯到最顶端，当回溯回溯没有了的时候（没有可回溯的对象了），那就变成空了
        return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array&apos;s method, not like a jQuery method.
    push: core_push,
    sort: [].sort,
    splice: [].splice
};

/*
jQuery的伪类选择函数
jQuery.fn.eq（函数用于获取当前jQuery对象所匹配的元素中指定索引的元素，并返回封装该元素的jQuery对象）

　　jQuery.fn.first（函数用于获取当前jQuery对象所匹配的元素中的第一个元素，并返回封装该元素的jQuery对象）

　　jQuery.fn.last（函数用于获取当前jQuery对象所匹配的元素中的最后一个元素，并返回封装该元素的jQuery对象）

　　jQuery.fn.slice（函数用于选取匹配元素中一段连续的元素，并以jQuery对象的形式返回）

　　jQuery.fn.map（函数用于处理当前jQuery对象匹配的所有元素，并将处理结果封装为新的数组。返回封装该数组的jQuery对象）

　　jQuery.fn.end（函数用于返回最近一次&quot;破坏性&quot;操作之前的jQuery对象）



　　jQuery.fn.find（选取每个匹配元素的符合指定表达式的后代元素，并以jQuery对象的形式返回）

　　jQuery.fn.has（筛选出包含特定后代的元素，并以jQuery对象的形式返回）

　　jQuery.fn.is（判断当前jQuery对象所匹配的元素是否符合指定的表达式。只要其中有至少一个元素符合该表达式就返回true，否则返回false）

　　jQuery.fn.hasClass（指示当前jQuery对象所匹配的元素是否含有指定的css类名(elem.className)，只需要其中有一个元素有即返回true）

　　jQuery.fn.closest(从当前匹配元素开始，逐级向上级选取符合指定表达式的第一个元素，并以jQuery对象的形式返回)。

　　jQuery.fn.filter（函数用于筛选出符合指定表达式的元素，并以jQuery对象的形式返回）

　　jQuery.fn.has（函数用于筛选出包含特定后代的元素，并以jQuery对象的形式返回）

　　jQuery.fn.not（函数用于从匹配元素中删除符合指定表达式的元素，并以jQuery对象的形式返回保留的元素）

　　jQuery.fn.add（函数用于向当前匹配元素中添加符合指定表达式的元素，并以jQuery对象的形式返回，与not相反）

　　jQuery.fn.addBack（函数用于将之前匹配的元素加入到当前匹配的元素中，并以新的jQuery对象的形式返回）

　　jQuery.fn.children（函数用于选取每个匹配元素的子元素，并以jQuery对象的形式返回。你还可以使用选择器进一步缩小筛选范围，筛选出符合指定选择器的元素）

　　jQuery.fn.parent（选取每个匹配元素的父元素，并以jQuery对象的形式返回）

　　jQuery.fn.parents（选取每个匹配元素的祖先元素，并以jQuery对象的形式返回）

　　jQuery.fn.parentsUntil（选取每个匹配元素的祖先元，直到遇到符合指定表达式的元素为止，并以jQuery对象的形式返回）

　　jQuery.fn.next（筛选每个匹配元素之后紧邻的同辈元素，并以jQuery对象的形式返回）

　　jQuery.fn.prev（筛选每个匹配元素之前紧邻的同辈元素，并以jQuery对象的形式返回）

　　jQuery.fn.nextAll（选取每个匹配元素之后的所有同辈元素，并以jQuery对象的形式返回）

　　jQuery.fn.prevAll（选取每个匹配元素之前的所有同辈元素，并以jQuery对象的形式返回）

　　jQuery.fn.nextUntil（选取每个匹配元素之后所有的同辈元素，直到遇到符合指定表达式的元素为止，并以jQuery对象的形式返回）

　　jQuery.fn.prevUntil（选取每个匹配元素之前所有的同辈元素，直到遇到符合指定表达式的元素为止，并以jQuery对象的形式返回）

　　jQuery.fn.siblings（选取每个匹配元素的所有同辈元素(不包括自己)，并以jQuery对象的形式返回）

　　jQuery.fn.contents（函数用于选取当前匹配元素的所有子节点(包括文本节点、注释节点等)，并以jQuery对象的形式返回）

　　jQuery.fn.offsetParent（函数用于查找离当前匹配元素最近的被定位的祖辈元素，所谓&quot;被定位的元素&quot;，就是元素的CSS position属性值为absolute、relative或fixed(只要不是默认的static即可)）
*/

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;
//这说明jQuery上和jQuery.fn下都有这么一个extend方法
jQuery.extend = jQuery.fn.extend = function() {
    //定义一些变量
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},//// 常见用法 jQuery.extend( obj1, obj2 )，此时，target为arguments[0]
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation //// 如果第一个参数为true，即 jQuery.extend( true, obj1, obj2 ); 的情况
    if ( typeof target === &quot;boolean&quot; ) {//看看是不是深拷贝的情况，类似于$.extend(true,a,b);第一个参数为boolean值true了，所以就属于深拷贝的情况 // 此时target是true
        deep = target;
        target = arguments[1] || {}; // target改为 obj1
        // skip the boolean and the target
        i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy) // 处理奇怪的情况，比如 jQuery.extend( &apos;hello&apos; , {nick: &apos;casper})~~
    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {//看参数正确不
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( length === i ) {//看是否是插件（也就是jQuery.extend()还是jQuery.fn.extend()）// 处理这种情况 jQuery.extend(obj)，或 jQuery.fn.extend( obj )
        target = this; // jQuery.extend时，this指的是jQuery；jQuery.fn.extend时，this指的是jQuery.fn
        --i;
    }

    for ( ; i &lt; length; i++ ) {//可能有多个对象的情况（vara{};$.extend(a,{name:&apos;hello&apos;},{age:30})）
        // Only deal with non-null/undefined values
        //是看你有多个对象，但对象到底有没有值呢
        if ( (options = arguments[ i ]) != null ) { // 比如 jQuery.extend( obj1, obj2, obj3, ojb4 )，options则为 obj2、obj3...
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {//防止循环引用 // 防止自引用，不赘述
                    continue;
                }

                // Recurse（递归） if we&apos;re merging plain（普通的） objects or array//copy就是判断是否有第二个参数真正的去实现赋值操作
                //isPlainObject判断是否为对象自变量
                // 如果是深拷贝，且被拷贝的属性值本身是个对象
                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {//深拷贝
                    if ( copyIsArray ) {//针对数组操作 // 被拷贝的属性值是个数组
                        copyIsArray = false;
                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

                    } else {//针对JSON操作 被拷贝的属性值是个plainObject，比如{ nick: &apos;casper&apos; }
                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don&apos;t bring in undefined values
                } else if ( copy !== undefined ) {//浅拷贝 // 浅拷贝，且属性值不为undefined
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};
//扩展插件
jQuery.extend({
    // Unique for each copy of jQuery on the page//生成唯一JQ字符串（仅内部使用）,replace( /\D/g, &quot;&quot; )是把非数字的替换为空，具备唯一性，对于做映射关系有帮助，例如数据缓存、事件操作、ajax操作都有用到它
    expando: &quot;jQuery&quot; + ( core_version + Math.random() ).replace( /\D/g, &quot;&quot; ),

    noConflict: function( deep ) {//防止冲突，deep传参时走的下面的分支是不一样的哟
        //jQuery是实例对象
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep &amp;&amp; window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    },

    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,//Dom是否加载完（内部）

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,//等待多少文件的计数器（内部）

    // Hold (or release) the ready event
    holdReady: function( hold ) {//推迟Dom触发
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            //这就表示要释放一次
            jQuery.ready( true );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {//准备Dom触发

        // Abort if there are pending holds or we&apos;re already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
            return;
        }

        // If there are functions bound, to execute//当走到这句话的时候，则说明Dom已经加载完毕了，则这样就可以执行fn了
        //document是指向fn的，也就是指向当加载完成后需要触发的动作fn，resolveWith()与resolve不同的是前者表示带参数，[jQuery]就是参数
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.trigger ) {//对于$(document).on(&apos;ready&apos;,function(){});首先判断是否有主动触发的事件，如果有则进行触发，例如$(document).on(&apos;ready&apos;,function(){alert(123);});
            jQuery( document ).trigger(&quot;ready&quot;).off(&quot;ready&quot;);
        }
    },

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren&apos;t supported. They return false on IE (#2968).
    isFunction: function( obj ) {//是否为函数(并没有真正意义上的判断是否为函数，以前的版本是做了判断，但是现在又改回来了)
        return jQuery.type(obj) === &quot;function&quot;;
    },

    isArray: Array.isArray,//是否为数组

    isWindow: function( obj ) {//是否为window
        return obj != null &amp;&amp; obj === obj.window;
    },

    isNumeric: function( obj ) {//是否为数字
        //如果obj能进行转换的话那就不是NAN,如果不能转换的话那就是NAN了。
        return !isNaN( parseFloat(obj) ) &amp;&amp; isFinite( obj );
    },

    type: function( obj ) {//判断数据类型
        if ( obj == null ) {
            //这样String()类型转换是希望结果以字符串形式显示出来，如&quot;null&quot;
            return String( obj );
        }
        // Support: Safari &lt;= 5.1 (functionish RegExp)
        return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
            class2type[ core_toString.call(obj) ] || &quot;object&quot; :
            typeof obj;
    },

    isPlainObject: function( obj ) {//是否为对象自变量(对象自变量就是JSON或者new Object()的形式)
        //例如，var obj={name:&apos;hello&apos;};var obj=new Object();所以就判断是否满足这2个形式就OK
        // Not plain objects:
        // - Any object or value whose internal [[Class]] property is not &quot;[object Object]&quot;
        // - DOM nodes
        // - window jQuery.isWindow( obj )是把window对象过滤掉

        if ( jQuery.type( obj ) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) {
            return false;
        }

        // Support: Firefox &lt;20(因为老是调用的时候回出现递归泄露，所以try catch)
        // The try/catch suppresses exceptions thrown when attempting to access
        // the &quot;constructor&quot; property of certain host objects, ie. |window.location|
        // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
        try {
            if ( obj.constructor &amp;&amp;
                    !core_hasOwn.call( obj.constructor.prototype, &quot;isPrototypeOf&quot; ) ) {
                return false;
            }
        } catch ( e ) {
            return false;
        }

        // If the function hasn&apos;t returned already, we&apos;re confident that
        // |obj| is a plain object, created by {} or constructed with new Object
        return true;
    },

    isEmptyObject: function( obj ) {//是否为空的对象
        var name;
        for ( name in obj ) {
            return false;
        }
        return true;
    },

    error: function( msg ) {//抛出异常
        throw new Error( msg );
    },

    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    parseHTML: function( data, context, keepScripts ) {//解析节点，把字符串转换成Dom节点集合
        //var str=&apos;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&apos;
        //$.parseHTML(str);则节点被创造好，存放在了数组里[li,li]
        /*
        var str=&apos;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;script&gt;&lt;/script&gt;&apos;
        console.log($.parseHTML(str,document,true));//则script是写到数组里的
        console.log($.parseHTML(str,document,false));//则script是不能写到数组里的
        */
        //如果不是字符串，那也就没有必要往下进行了
        if ( !data || typeof data !== &quot;string&quot; ) {
            return null;
        }
        if ( typeof context === &quot;boolean&quot; ) {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec( data ),
            scripts = !keepScripts &amp;&amp; [];

        // Single tag(对于单标签)例如&lt;li&gt;&lt;/li&gt;
        if ( parsed ) {
            return [ context.createElement( parsed[1] ) ];
        }

    //buildFragment 是一个私有函数，用来构建一个包含子节点 fragment 对象。buildFragment是一个内部的方法
    //对于多标签进行处理（例如，&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;）,buildFragment是利用文档碎片对多标签进行处理的，创建Dom
        parsed = jQuery.buildFragment( [ data ], context, scripts );

        if ( scripts ) {
            jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
    },
  //将格式完好的JSON字符串转为与之对应的JavaScript对象,所谓&quot;格式完好&quot;，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。如果传入一个格式不&quot;完好&quot;的JSON字符串将抛出一个JS异常。
    parseJSON: JSON.parse,//解析JSON(将json形式的字符串转换为JSON,but IE6 and IE7不支持)
    //p.s  Json.parse只能解析严格模式的json字符串，而json.eval是能解析任意类型的字符串，json.stringify是将json转换成字符串

    // Cross-browser xml parsing 将字符串解析为对应的XML文档
    parseXML: function( data ) {解析XML
        var xml, tmp;
        //不是字符串的处理情况
        if ( !data || typeof data !== &quot;string&quot; ) {
            return null;
        }

        // Support: IE9
        try {
            //创建解析xml的实例对象（IE8以下不支持）,IE8以下的使用的是ActiveXobject
            //DOMParser 对象解析 XML 文本并返回一个 XML Document 对象。要使用 DOMParser，使用不带参数的构造函数来实例化它，然后调用其 parseFromString() 方法：
            tmp = new DOMParser();
            //返回的就是文档的document对象，如果传入的数据出错，那就会跳到catch中的xml=undefined进行处理（这是指ie9数据出错时下一句会报错，而火狐是动态的创建parsererror,在下面报错）
            xml = tmp.parseFromString( data , &quot;text/xml&quot; );
        } catch ( e ) {
            xml = undefined;
        }
//这个是在火狐浏览器数据出错时执行的
        if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
            jQuery.error( &quot;Invalid XML: &quot; + data );
        }
        return xml;
    },

    noop: function() {},//空函数

    // Evaluates a script in a global context
    globalEval: function( code ) {//全局解析JS,即是让在内部函数内部定义的变量变成全局的，从而在函数外面也可以被找到
        //例如，function test(){jQuery.globalEval(&quot;var newVar=true;&quot;)}  test();alert(newVar); newVar是可以被识别出来的
        var script,
                indirect = eval;

        code = jQuery.trim( code );

        if ( code ) {
            // If the code includes a valid, prologue position
            // strict mode pragma, execute code by injecting a
            // script tag into the document.
            if ( code.indexOf(&quot;use strict&quot;) === 1 ) {
                //如果是严格模式，则无法用eval解析，所以需用下面的处理方式，即创建script标签。
                script = document.createElement(&quot;script&quot;);
                script.text = code;
                document.head.appendChild( script ).parentNode.removeChild( script );
            } else {
            // Otherwise, avoid the DOM node creation, insertion
            // and removal by using an indirect global eval
            //如果不是严格模式，则就可以用eval进行解析咯
            //p.s.  eval既是windows下的一个属性又是js中的一个关键字，当你直接调用时，它会当做一个关键字使用，所以
            //只在局部作用域内有效，而windows.eval()就变成属性，则它内部的参数也会处理成windows下的，所以是可以全局解析到的
                indirect( code );
            }
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {//转驼峰（内部方法），因为js中不能接受-字符
        return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {//是否为指定节点名（内部方法）
        //为了能够全兼容，所以要转换成小写的，因为elem.nodeName测试时返回来的额是大写的
        //例如,alert($.nodeName(document.body,&apos;html&apos;))
        return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {//遍历集合//args是用于jquery内部使用的
        //for循环是针对原声js的，而each是针对jqury对象的（数组、类数组、json集合）
        var value,
            i = 0,
            length = obj.length,
            //isArray就是判断是obj是类数组还是真正的数组，当然它不光针对他们，还针对jQuery对象this-&gt;{0:1,:,2:,length:3}所以是返回真的，所以这要和数组和json区分开来处理
            //如果返回真，则是数组操作或者jquery 对象this={...}，否则是json的操作
            //jquery对象和json还是有些不同的,jquery对象的下标是0,1.。。的情况
            isArray = isArraylike( obj );

        if ( args ) {
            if ( isArray ) {
                for ( ; i &lt; length; i++ ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            //如果是数组，则就用for循环，如果是json，则应用for in形式
            if ( isArray ) {
                for ( ; i &lt; length; i++ ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                //json形式
                for ( i in obj ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    trim: function( text ) {//去前后空格（对原生trim进行二次封装）
        return text == null ? &quot;&quot; : core_trim.call( text );
    },

    // results is for internal usage only
    makeArray: function( arr, results ) {//类数组转真数组 其实它也可以将数字、字符串、json转换成数组的
        //例如，var str=1;console.log($.makeArray(str));
        如果makeArray有第二个参数，那么它就会用于内部使用，转换成json了，例如，上面例子调用改成console.log($.makeArray(str,{length:0})),注意是一定要有length属性的，这样才能转换成相应的json
        var ret = results || [];

        if ( arr != null ) {
            if ( isArraylike( Object(arr) ) ) {
                //Object(123) Number {[[PrimitiveValue]]: 123} 所以对于123即使object也会返回false的
                jQuery.merge( ret,
                    typeof arr === &quot;string&quot; ?
                    [ arr ] : arr
                );
            } else {
                core_push.call( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {//数组版indexOf
        return arr == null ? -1 : core_indexOf.call( arr, elem, i );
    },

    merge: function( first, second ) {//合并数组
        var l = second.length,
            i = first.length,
            j = 0;

        if ( typeof l === &quot;number&quot; ) {//$.merge([&apos;a&apos;,&apos;b&apos;],[&apos;c&apos;,&apos;d&apos;]);
            for ( ; j &lt; l; j++ ) {
                first[ i++ ] = second[ j ];
            }
        } else {//$.merge([&apos;a&apos;,&apos;b&apos;],{0:&apos;c&apos;,1:&apos;d&apos;}),是可以没有长度的 
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, inv ) {//过滤新数组 函数目的是过滤出用户指定的数据。一般来说第三个参数不传或传为false，callback是一个过滤器，过滤成功返回true，过滤失败返回false。最终grep函数将callback返回成功的素有elem元素返回。这个函数无论是在jQuery内部，或者我们自己使用都很有作用
        /*
        var arr=[1,2,3,4];
        arr=$.grep(arr,function(n,i){
        return n&gt;2;
        });
        则返回n&gt;2的数组元素
        如果传入了第三个参数true
        arr=$.grep(arr,function(n,i){
        return n&gt;2;
        },true);
        则会返回n&lt;=2的情况
        */
        var retVal,
            ret = [],
            i = 0,
            length = elems.length;
        inv = !!inv;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i &lt; length; i++ ) {
            retVal = !!callback( elems[ i ], i );
            if ( inv !== retVal ) {
                ret.push( elems[ i ] );
            }
        }

        return ret;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {//映射新数组
        /*
        var arr=[1,2,3,4];
        arr=$.map(arr,function(n){
        return n+1;
        })
        则这样就会映射成新的数组
        */
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        // Go through the array, translating each of the items to their
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }

        // Go through every key on the object,
        } else {
            for ( i in elems ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }
        }

        // Flatten any nested arrays避免出现复合数组所做的操作apply([],ret),把ret给[]
        return core_concat.apply( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,//唯一标识符（内部）,比如和事件操作都是有关系的。

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {//改了this指向
        var tmp, args, proxy;

    //处理简化写法$(document).click($.proxy(obj,&apos;show&apos;));
        if ( typeof context === &quot;string&quot; ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = core_slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        //设置唯一的标识
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    },

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it&apos;s a function
    access: function( elems, fn, key, value, chainable, emptyGet, raw ) {//多功能值操作（内部）fn是回调函数 chainable若为true,则我们是要设置，否则，我们是要获取
        var i = 0,
            length = elems.length,
            bulk = key == null;

        // Sets many values
        if ( jQuery.type( key ) === &quot;object&quot; ) {
            chainable = true;
            for ( i in key ) {
                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
            }

        // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;

            if ( !jQuery.isFunction( value ) ) {
                raw = true;
            }

            if ( bulk ) {
                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;

                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }

            if ( fn ) {
                for ( ; i &lt; length; i++ ) {
                    fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                }
            }
        }

        return chainable ?
            elems :

            // Gets 获取的操作在这里哟
            bulk ?
                fn.call( elems ) :
                length ? fn( elems[0], key ) : emptyGet;
    },

    now: Date.now,//当前时间

    // A method for quickly swapping in/out CSS properties to get correct calculations.
    // Note: this method belongs to the css module but it&apos;s needed here for the support module.
    // If support gets modularized, this method should be moved back to the css module.
    swap: function( elem, options, callback, args ) {CSS交换（内部）例如获取隐藏元素的宽度，jquery就可以获得，而原生js不能获得是因为jquery的swap操作“偷梁换柱”的结果
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.apply( elem, args || [] );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    }
});

jQuery.ready.promise = function( obj ) {//创建了延迟对象,promise在外面是不能被修改的
    if ( !readyList ) {
    //创建延迟对象
        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === &quot;complete&quot; ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            //保证让其延后触发，因为IE版本在可能差一点点就完成的时候它就触发了，所以IE有点帮倒忙了，所以保证IE下也是OK的。
            setTimeout( jQuery.ready );

        } else {

            // Use the handy event callback//complted是回调函数，它可以在jQuery源码中找寻到
            //浏览器中可能会对load进行缓存，所以加载的比较快些，所以写了下面2个语句，DOMContentLoaded和load无论哪个先触发好我们都执行相同的回调
            //函数completed.
            document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );

            // A fallback to window.onload, that will always work
            window.addEventListener( &quot;load&quot;, completed, false );
        }
    }
    //promise是保证状态在外面是不会修改的
    return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) {
    /*
    对于alert($.type([]));按理应该弹出[Object Array],但这样太长了，所以下面就是对其一种转换，最终弹出的是array.
    */
    class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
});

//简单的说：类数组对象是有一个数值length属性和对应非负整数属性的对象。源码就是判断一个对象是否为类数组对象。
//测试总结：三种情况下返回true。第一种：length恒等于0;第二种：本身就是Array类型;第三种：length&gt;0,同时length是number类型，同时(length-1) in obj为true!
function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );
//为什么要对window单独做判断呢，是因为害怕执行下面的操作的时候window下也挂载了length属性
//如果是函数，或者window那么直接返回false
    if ( jQuery.isWindow( obj ) ) {
        return false;
    }

    if ( obj.nodeType === 1 &amp;&amp; length ) {
        return true;
    }

  //length是数字类型，同时length&gt;0而且length-1要存在
    return type === &quot;array&quot; || type !== &quot;function&quot; &amp;&amp;
        ( length === 0 ||
        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj );
}

// All jQuery objects should point back to these 获取jQuery document根节点
jQuery定义了rootjQuery，同时赋予了它合理的上下文，即document,这样有助于压缩
rootjQuery = jQuery(document);
/*!
 * Sizzle CSS Selector Engine v1.9.4-pre
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-06-03
 */
(function( window, undefined ) {

var i,
    support,
    cachedruns,
    Expr,
    getText,
    isXML,
    compile,
    outermostContext,
    sortInput,

    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,

    // Instance-specific data
    expando = &quot;sizzle&quot; + -(new Date()),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    //jQuery在词法解析函数tokenize开始解析之前用到了一个比较巧妙的地方，Sizzle把每次查询结果缓存了起来，如果下一次有相同的查询，则直接使用缓存中的查询结果，而不需要重新查询。
    tokenCache = createCache(),
    compilerCache = createCache(),
    hasDuplicate = false,
    sortOrder = function( a, b ) {
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }
        return 0;
    },

    // General-purpose constants
    strundefined = typeof undefined,
    MAX_NEGATIVE = 1 &lt;&lt; 31,

    // Instance methods
    hasOwn = ({}).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    // Use a stripped-down indexOf if we can&apos;t use a native one
    indexOf = arr.indexOf || function( elem ) {
        var i = 0,
            len = this.length;
        for ( ; i &lt; len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

    // Regular expressions

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),

    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + whitespace +
        &quot;*(?:([*^$|!~]?=)&quot; + whitespace + &quot;*(?:([&apos;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + whitespace + &quot;*\\]&quot;,

    // Prefer arguments quoted,
    //   then not containing pseudos/brackets,
    //   then attribute selectors/non-parenthetical expressions,
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\((([&apos;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes.replace( 3, 8 ) + &quot;)*)|.*)\\)|)&quot;,

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

    rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
    rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),

    rsibling = new RegExp( whitespace + &quot;*[+~]&quot; ),
    rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&apos;\&quot;]*)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),

    rpseudo = new RegExp( pseudos ),
    ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

    matchExpr = {
        &quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
        &quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
        &quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
        &quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
            &quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
            &quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
        &quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        &quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
            whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
    },

    rnative = /^[^{]+\{\s*\[native \w/,

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,

    rescape = /&apos;|\\/g,

    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
    funescape = function( _, escaped, escapedWhitespace ) {
        var high = &quot;0x&quot; + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +&quot;0x&quot;
        return high !== high || escapedWhitespace ?
            escaped :
            // BMP codepoint
            high &lt; 0 ?
                String.fromCharCode( high + 0x10000 ) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
    };

// Optimize for push.apply( _, NodeList )
try {
    push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
    );
    // Support: Android&lt;4.0
    // Detect silently failing push.apply
    arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
    push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
            push_native.apply( target, slice.call(els) );
        } :

        // Support: IE&lt;9
        // Otherwise append directly
        function( target, els ) {
            var j = target.length,
                i = 0;
            // Can&apos;t trust NodeList.length
            while ( (target[j++] = els[i++]) ) {}
            target.length = j - 1;
        }
    };
}

function Sizzle( selector, context, results, seed ) {
    var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
    }

    context = context || document;
    results = results || [];

    if ( !selector || typeof selector !== &quot;string&quot; ) {
        return results;
    }

    if ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {
        return [];
    }

    if ( documentIsHTML &amp;&amp; !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
            // Speed-up: Sizzle(&quot;#ID&quot;)
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context.getElementById( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem &amp;&amp; elem.parentNode ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
                        contains( context, elem ) &amp;&amp; elem.id === m ) {
                        results.push( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle(&quot;TAG&quot;)
            } else if ( match[2] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

            // Speed-up: Sizzle(&quot;.CLASS&quot;)
            } else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName ) {
                push.apply( results, context.getElementsByClassName( m ) );
                return results;
            }
        }

        // QSA path
        if ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 &amp;&amp; selector;

            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn&apos;t work on object elements
            if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
                groups = tokenize( selector );

                if ( (old = context.getAttribute(&quot;id&quot;)) ) {
                    nid = old.replace( rescape, &quot;\\$&amp;&quot; );
                } else {
                    context.setAttribute( &quot;id&quot;, nid );
                }
                nid = &quot;[id=&apos;&quot; + nid + &quot;&apos;] &quot;;

                i = groups.length;
                while ( i-- ) {
                    groups[i] = nid + toSelector( groups[i] );
                }
                newContext = rsibling.test( selector ) &amp;&amp; context.parentNode || context;
                newSelector = groups.join(&quot;,&quot;);
            }

            if ( newSelector ) {
                try {
                    push.apply( results,
                        newContext.querySelectorAll( newSelector )
                    );
                    return results;
                } catch(qsaError) {
                } finally {
                    if ( !old ) {
                        context.removeAttribute(&quot;id&quot;);
                    }
                }
            }
        }
    }

    // All others
    return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *    deleting the oldest entry
 */
function createCache() {
    var keys = [];

    function cache( key, value ) {
        // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key += &quot; &quot; ) &gt; Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
        }
        return (cache[ key ] = value);
    }
    return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
    fn[ expando ] = true;
    return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
    var div = document.createElement(&quot;div&quot;);

    try {
        return !!fn( div );
    } catch (e) {
        return false;
    } finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
            div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
    }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
    var arr = attrs.split(&quot;|&quot;),
        i = attrs.length;

    while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
    }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
    var cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
            ( ~b.sourceIndex || MAX_NEGATIVE ) -
            ( ~a.sourceIndex || MAX_NEGATIVE );

    // Use IE sourceIndex if available on both nodes
    if ( diff ) {
        return diff;
    }

    // Check if b follows a
    if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
            if ( cur === b ) {
                return -1;
            }
        }
    }

    return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === &quot;input&quot; &amp;&amp; elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn&apos;t yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
};

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
 //该函数功能是设置document，探测浏览器对各个方法属性的支持情况保存在support对象中，并且给Sizzle选择器的匹配关键变量添加匹配相关的hooks,初始化contains和sortOrder函数。
setDocument = Sizzle.setDocument = function( node ) {
    var doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

    // If no document and documentElement is available, return
    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
    }

    // Set our document
    document = doc;
    docElem = doc.documentElement;

    // Support tests
    documentIsHTML = !isXML( doc );

    // Support: IE&gt;8
    // If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,
    // IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936
    // IE6-8 do not support the defaultView property so parent will be undefined
    if ( parent &amp;&amp; parent.attachEvent &amp;&amp; parent !== parent.top ) {
        parent.attachEvent( &quot;onbeforeunload&quot;, function() {
            setDocument();
        });
    }

    /* Attributes
    ---------------------------------------------------------------------- */

    // Support: IE&lt;8
    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
    support.attributes = assert(function( div ) {
        div.className = &quot;i&quot;;
        return !div.getAttribute(&quot;className&quot;);
    });

    /* getElement(s)By*
    ---------------------------------------------------------------------- */

    // Check if getElementsByTagName(&quot;*&quot;) returns only elements
    support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment(&quot;&quot;) );
        return !div.getElementsByTagName(&quot;*&quot;).length;
    });

    // Check if getElementsByClassName can be trusted
    support.getElementsByClassName = assert(function( div ) {
        div.innerHTML = &quot;&lt;div class=&apos;a&apos;&gt;&lt;/div&gt;&lt;div class=&apos;a i&apos;&gt;&lt;/div&gt;&quot;;

        // Support: Safari&lt;4
        // Catch class over-caching
        div.firstChild.className = &quot;i&quot;;
        // Support: Opera&lt;10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName(&quot;i&quot;).length === 2;
    });

    // Support: IE&lt;10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don&apos;t pick up programatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
    });

    // ID find and filter
    if ( support.getById ) {
        Expr.find[&quot;ID&quot;] = function( id, context ) {
            if ( typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML ) {
                var m = context.getElementById( id );
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                return m &amp;&amp; m.parentNode ? [m] : [];
            }
        };
        Expr.filter[&quot;ID&quot;] = function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                return elem.getAttribute(&quot;id&quot;) === attrId;
            };
        };
    } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find[&quot;ID&quot;];

        Expr.filter[&quot;ID&quot;] =  function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
                return node &amp;&amp; node.value === attrId;
            };
        };
    }

    // Tag
    Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
        function( tag, context ) {
            if ( typeof context.getElementsByTagName !== strundefined ) {
                return context.getElementsByTagName( tag );
            }
        } :
        function( tag, context ) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName( tag );

            // Filter out possible comments
            if ( tag === &quot;*&quot; ) {
                while ( (elem = results[i++]) ) {
                    if ( elem.nodeType === 1 ) {
                        tmp.push( elem );
                    }
                }

                return tmp;
            }
            return results;
        };

    // Class
    Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML ) {
            return context.getElementsByClassName( className );
        }
    };

    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */

    // QSA and matchesSelector support

    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];

    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See http://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];

    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE&apos;s treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div.innerHTML = &quot;&lt;select&gt;&lt;option selected=&apos;&apos;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

            // Support: IE8
            // Boolean attributes and &quot;value&quot; are not treated correctly
            if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
                rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
                rbuggyQSA.push(&quot;:checked&quot;);
            }
        });

        assert(function( div ) {

            // Support: Opera 10-12/IE8
            // ^= $= *= and empty values
            // Should not select anything
            // Support: Windows 8 Native Apps
            // The type attribute is restricted during .innerHTML assignment
            var input = doc.createElement(&quot;input&quot;);
            input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
            div.appendChild( input ).setAttribute( &quot;t&quot;, &quot;&quot; );

            if ( div.querySelectorAll(&quot;[t^=&apos;&apos;]&quot;).length ) {
                rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&apos;&apos;|\&quot;\&quot;)&quot; );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
                rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll(&quot;*,:x&quot;);
            rbuggyQSA.push(&quot;,.*:&quot;);
        });
    }

    if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
            // Check to see if it&apos;s possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call( div, &quot;div&quot; );

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call( div, &quot;[s!=&apos;&apos;]:x&quot; );
            rbuggyMatches.push( &quot;!=&quot;, pseudos );
        });
    }

    rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
    rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

    /* Contains
    ---------------------------------------------------------------------- */

    // Element contains another
    // Purposefully does not implement inclusive descendent
    // As in, an element does not contain itself
    contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
        function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b &amp;&amp; b.parentNode;
            return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
                adown.contains ?
                    adown.contains( bup ) :
                    a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
            ));
        } :
        function( a, b ) {
            if ( b ) {
                while ( (b = b.parentNode) ) {
                    if ( b === a ) {
                        return true;
                    }
                }
            }
            return false;
        };

    /* Sorting
    ---------------------------------------------------------------------- */

    // Document order sorting
    sortOrder = docElem.compareDocumentPosition ?
    function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        var compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( b );

        if ( compare ) {
            // Disconnected nodes
            if ( compare &amp; 1 ||
                (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {

                // Choose the first element that is related to our preferred document
                if ( a === doc || contains(preferredDoc, a) ) {
                    return -1;
                }
                if ( b === doc || contains(preferredDoc, b) ) {
                    return 1;
                }

                // Maintain original order
                return sortInput ?
                    ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                    0;
            }

            return compare &amp; 4 ? -1 : 1;
        }

        // Not directly comparable, sort on existence of method
        return a.compareDocumentPosition ? -1 : 1;
    } :
    function( a, b ) {
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

        // Exit early if the nodes are identical
        if ( a === b ) {
            hasDuplicate = true;
            return 0;

        // Parentless nodes are either documents or disconnected
        } else if ( !aup || !bup ) {
            return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
            return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
            ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
            bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
            i++;
        }

        return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck( ap[i], bp[i] ) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
    };

    return doc;
};

Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    // Make sure that attribute selectors are quoted
    expr = expr.replace( rattributeQuotes, &quot;=&apos;$1&apos;]&quot; );

    if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
            var ret = matches.call( elem, expr );

            // IE 9&apos;s matchesSelector returns false on disconnected nodes
            if ( ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
                return ret;
            }
        } catch(e) {}
    }

    return Sizzle( expr, document, null, [elem] ).length &gt; 0;
};

Sizzle.contains = function( context, elem ) {
    // Set document vars if needed
    if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
    }
    return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don&apos;t get fooled by Object.prototype properties (jQuery #13807)
        val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

    return val === undefined ?
        support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
                val.value :
                null :
        val;
};

Sizzle.error = function( msg ) {
    throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
    var elem,
        duplicates = [],
        j = 0,
        i = 0;

    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
    results.sort( sortOrder );

    if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
            if ( elem === results[ i ] ) {
                j = duplicates.push( i );
            }
        }
        while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
        }
    }

    return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = &quot;&quot;,
        i = 0,
        nodeType = elem.nodeType;

    if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        for ( ; (node = elem[i]); i++ ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (see #11153)
        if ( typeof elem.textContent === &quot;string&quot; ) {
            return elem.textContent;
        } else {
            // Traverse its children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                ret += getText( elem );
            }
        }
    } else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes

    return ret;
};

Expr = Sizzle.selectors = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: {},

    find: {},

    relative: {
        &quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
        &quot; &quot;: { dir: &quot;parentNode&quot; },
        &quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
        &quot;~&quot;: { dir: &quot;previousSibling&quot; }
    },

    preFilter: {
        &quot;ATTR&quot;: function( match ) {
            match[1] = match[1].replace( runescape, funescape );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

            if ( match[2] === &quot;~=&quot; ) {
                match[3] = &quot; &quot; + match[3] + &quot; &quot;;
            }

            return match.slice( 0, 4 );
        },

        &quot;CHILD&quot;: function( match ) {
            /* matches from matchExpr[&quot;CHILD&quot;]
                1 type (only|nth|...)
                2 what (child|of-type)
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                4 xn-component of xn+y argument ([+-]?\d*n|)
                5 sign of xn-component
                6 x of xn-component
                7 sign of y-component
                8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
                // nth-* requires argument
                if ( !match[3] ) {
                    Sizzle.error( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
                match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );

            // other types prohibit arguments
            } else if ( match[3] ) {
                Sizzle.error( match[0] );
            }

            return match;
        },

        &quot;PSEUDO&quot;: function( match ) {
            var excess,
                unquoted = !match[5] &amp;&amp; match[2];

            if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
                return null;
            }

            // Accept quoted arguments as-is
            if ( match[3] &amp;&amp; match[4] !== undefined ) {
                match[2] = match[4];

            // Strip excess characters from unquoted arguments
            } else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
                // Get excess from tokenize (recursively)
                (excess = tokenize( unquoted, true )) &amp;&amp;
                // advance to the next closing parenthesis
                (excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

                // excess is a negative index
                match[0] = match[0].slice( 0, excess );
                match[2] = unquoted.slice( 0, excess );
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
        }
    },

    filter: {

        &quot;TAG&quot;: function( nodeNameSelector ) {
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            return nodeNameSelector === &quot;*&quot; ?
                function() { return true; } :
                function( elem ) {
                    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
                };
        },

        &quot;CLASS&quot;: function( className ) {
            var pattern = classCache[ className + &quot; &quot; ];

            return pattern ||
                (pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
                classCache( className, function( elem ) {
                    return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
                });
        },

        &quot;ATTR&quot;: function( name, operator, check ) {
            return function( elem ) {
                var result = Sizzle.attr( elem, name );

                if ( result == null ) {
                    return operator === &quot;!=&quot;;
                }
                if ( !operator ) {
                    return true;
                }

                result += &quot;&quot;;

                return operator === &quot;=&quot; ? result === check :
                    operator === &quot;!=&quot; ? result !== check :
                    operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
                    operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
                    operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
                    operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
                    operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
                    false;
            };
        },

        &quot;CHILD&quot;: function( type, what, argument, first, last ) {
            var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
                forward = type.slice( -4 ) !== &quot;last&quot;,
                ofType = what === &quot;of-type&quot;;

            return first === 1 &amp;&amp; last === 0 ?

                // Shortcut for :nth-*(n)
                function( elem ) {
                    return !!elem.parentNode;
                } :

                function( elem, context, xml ) {
                    var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
                        parent = elem.parentNode,
                        name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                        useCache = !xml &amp;&amp; !ofType;

                    if ( parent ) {

                        // :(first|last|only)-(child|of-type)
                        if ( simple ) {
                            while ( dir ) {
                                node = elem;
                                while ( (node = node[ dir ]) ) {
                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                        return false;
                                    }
                                }
                                // Reverse direction for :only-* (if we haven&apos;t yet done so)
                                start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
                            }
                            return true;
                        }

                        start = [ forward ? parent.firstChild : parent.lastChild ];

                        // non-xml :nth-child(...) stores cache data on `parent`
                        if ( forward &amp;&amp; useCache ) {
                            // Seek `elem` from a previously-cached index
                            outerCache = parent[ expando ] || (parent[ expando ] = {});
                            cache = outerCache[ type ] || [];
                            nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
                            diff = cache[0] === dirruns &amp;&amp; cache[2];
                            node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

                            while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                // When found, cache indexes on `parent` and break
                                if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            }

                        // Use previously-cached element index if available
                        } else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {
                            diff = cache[1];

                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                        } else {
                            // Use the same loop as above to seek `elem` from the start
                            while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {
                                    // Cache the index of each encountered element
                                    if ( useCache ) {
                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                    }

                                    if ( node === elem ) {
                                        break;
                                    }
                                }
                            }
                        }

                        // Incorporate the offset, then check against cycle size
                        diff -= last;
                        return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
                    }
                };
        },

        &quot;PSEUDO&quot;: function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length &gt; 1 ) {
                args = [ pseudo, pseudo, &quot;&quot;, argument ];
                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        while ( i-- ) {
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        // Potentially complex pseudos
        &quot;not&quot;: markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    return !results.pop();
                };
        }),

        &quot;has&quot;: markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem ).length &gt; 0;
            };
        }),

        &quot;contains&quot;: markFunction(function( text ) {
            return function( elem ) {
                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
            };
        }),

        // &quot;Whether an element is represented by a :lang() selector
        // is based solely on the element&apos;s language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by &quot;-&quot;.
        // The matching of C against the element&apos;s language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name.&quot;
        // http://www.w3.org/TR/selectors/#lang-pseudo
        &quot;lang&quot;: markFunction( function( lang ) {
            // lang value must be a valid identifier
            if ( !ridentifier.test(lang || &quot;&quot;) ) {
                Sizzle.error( &quot;unsupported lang: &quot; + lang );
            }
            lang = lang.replace( runescape, funescape ).toLowerCase();
            return function( elem ) {
                var elemLang;
                do {
                    if ( (elemLang = documentIsHTML ?
                        elem.lang :
                        elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {

                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
                    }
                } while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
                return false;
            };
        }),

        // Miscellaneous
        &quot;target&quot;: function( elem ) {
            var hash = window.location &amp;&amp; window.location.hash;
            return hash &amp;&amp; hash.slice( 1 ) === elem.id;
        },

        &quot;root&quot;: function( elem ) {
            return elem === docElem;
        },

        &quot;focus&quot;: function( elem ) {
            return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        &quot;enabled&quot;: function( elem ) {
            return elem.disabled === false;
        },

        &quot;disabled&quot;: function( elem ) {
            return elem.disabled === true;
        },

        &quot;checked&quot;: function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
        },

        &quot;selected&quot;: function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
                elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
        },

        // Contents
        &quot;empty&quot;: function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
            //   not comment, processing instructions, or others
            // Thanks to Diego Perini for the nodeName shortcut
            //   Greater than &quot;@&quot; means alpha characters (specifically not starting with &quot;#&quot; or &quot;?&quot;)
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                if ( elem.nodeName &gt; &quot;@&quot; || elem.nodeType === 3 || elem.nodeType === 4 ) {
                    return false;
                }
            }
            return true;
        },

        &quot;parent&quot;: function( elem ) {
            return !Expr.pseudos[&quot;empty&quot;]( elem );
        },

        // Element/input types
        &quot;header&quot;: function( elem ) {
            return rheader.test( elem.nodeName );
        },

        &quot;input&quot;: function( elem ) {
            return rinputs.test( elem.nodeName );
        },

        &quot;button&quot;: function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
        },

        &quot;text&quot;: function( elem ) {
            var attr;
            // IE6 and 7 will map elem.type to &apos;text&apos; for new HTML5 types (search, etc)
            // use getAttribute instead to test this case
            return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
                elem.type === &quot;text&quot; &amp;&amp;
                ( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === elem.type );
        },

        // Position-in-collection
        &quot;first&quot;: createPositionalPseudo(function() {
            return [ 0 ];
        }),

        &quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        &quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument &lt; 0 ? argument + length : argument ];
        }),

        &quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
            var i = 0;
            for ( ; i &lt; length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        &quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
            var i = 1;
            for ( ; i &lt; length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        &quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument &lt; 0 ? argument + length : argument;
            for ( ; --i &gt;= 0; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        &quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument &lt; 0 ? argument + length : argument;
            for ( ; ++i &lt; length; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        })
    }
};

Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
    Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

//词法分析器(tokenize)
//假设传入进来的选择器是：div &gt; p + .aaron[type=&quot;checkbox&quot;], #id:first-child
//这里可以分为两个规则：div &gt; p + .aaron[type=&quot;checkbox&quot;] 以及 #id:first-child
//返回的需要是一个Token序列
//Sizzle的Token格式如下 ：{value:&apos;匹配到的字符串&apos;, type:&apos;对应的Token类型&apos;, matches:&apos;正则匹配到的一个结构&apos;}
function tokenize( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        //tokenize函数中获取缓存
        cached = tokenCache[ selector + &quot; &quot; ];

        //这里的soFar是表示目前还未分析的字符串剩余部分
  //groups表示目前已经匹配到的规则组，在这个例子里边，groups的长度最后是2，存放的是每个规则对应的Token序列

    //如果cache里边有，直接拿出来即可

    if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
    }
//初始化
    soFar = selector;
    groups = [];//这是最后要返回的结果，一个二维数组
    //比如&quot;title,div &gt; :nth-child(even)&quot;解析下面的符号流
    // [ [{value:&quot;title&quot;,type:&quot;TAG&quot;,matches:[&quot;title&quot;]}],
    //   [{value:&quot;div&quot;,type:[&quot;TAG&quot;,matches:[&quot;div&quot;]},
    //    {value:&quot;&gt;&quot;, type: &quot;&gt;&quot;},
    //    {value:&quot;:nth-child(even)&quot;,type:&quot;CHILD&quot;,matches:[&quot;nth&quot;,
    //     &quot;child&quot;,&quot;even&quot;,2,0,undefined,undefined,undefined]}
    //   ]
    // ]
    //有多少个并联选择器，里面就有多少个数组，数组里面是拥有value与type的对象

    //这里的预处理器为了对匹配到的Token适当做一些调整
    //自行查看源码，其实就是正则匹配到的内容的一个预处理
    preFilters = Expr.preFilter;
//递归检测字符串
    //比如&quot;div &gt; p + .aaron input[type=&quot;checkbox&quot;]&quot;
    while ( soFar ) {

        // Comma and first run
        // 以第一个逗号切割选择符,然后去掉前面的部分
        if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
                // Don&apos;t consume trailing commas as valid
                //如果匹配到逗号
                soFar = soFar.slice( match[0].length ) || soFar;
            }
            //往规则组里边压入一个Token序列，目前Token序列还是空的
            groups.push( tokens = [] );
        }

        matched = false;
        // Combinators
        //将刚才前面的部分以关系选择器再进行划分
        //先处理这几个特殊的Token ： &gt;, +, 空格, ~
        //因为他们比较简单，并且是单字符的

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
            //获取到匹配的字符
            matched = match.shift();
            //放入Token序列中
            tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace( rtrim, &quot; &quot; )
            });
            //剩余还未分析的字符串需要减去这段已经分析过的
            soFar = soFar.slice( matched.length );
        }

        // Filters
        // Filters
        //这里开始分析这几种Token ： TAG, ID, CLASS, ATTR, CHILD, PSEUDO, NAME
        //将每个选择器组依次用ID,TAG,CLASS,ATTR,CHILD,PSEUDO这些正则进行匹配
        //Expr.filter里边对应地 就有这些key
    /**
     *
     *
     *matchExpr 过滤正则
        ATTR: /^\[[\x20\t\r\n\f]*((?:\\.|[\w-]|[^\x00-\xa0])+)[\x20\t\r\n\f]*(?:([*^$|!~]?=)[\x20\t\r\n\f]*(?:([&apos;&quot;])((?:\\.|[^\\])*?)\3|((?:\\.|[\w#-]|[^\x00-\xa0])+)|)|)[\x20\t\r\n\f]*\]/
        CHILD: /^:(only|first|last|nth|nth-last)-(child|of-type)(?:\([\x20\t\r\n\f]*(even|odd|(([+-]|)(\d*)n|)[\x20\t\r\n\f]*(?:([+-]|)[\x20\t\r\n\f]*(\d+)|))[\x20\t\r\n\f]*\)|)/i
        CLASS: /^\.((?:\\.|[\w-]|[^\x00-\xa0])+)/
        ID: /^#((?:\\.|[\w-]|[^\x00-\xa0])+)/
        PSEUDO: /^:((?:\\.|[\w-]|[^\x00-\xa0])+)(?:\((([&apos;&quot;])((?:\\.|[^\\])*?)\3|((?:\\.|[^\\()[\]]|\[[\x20\t\r\n\f]*((?:\\.|[\w-]|[^\x00-\xa0])+)[\x20\t\r\n\f]*(?:([*^$|!~]?=)[\x20\t\r\n\f]*(?:([&apos;&quot;])((?:\\.|[^\\])*?)\8|((?:\\.|[\w#-]|[^\x00-\xa0])+)|)|)[\x20\t\r\n\f]*\])*)|.*)\)|)/
        TAG: /^((?:\\.|[\w*-]|[^\x00-\xa0])+)/
        bool: /^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$/i
        needsContext: /^[\x20\t\r\n\f]*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\([\x20\t\r\n\f]*((?:-\d)?\d*)[\x20\t\r\n\f]*\)|)(?=[^-]|$)/i
     *
     */
        //如果通过正则匹配到了Token格式：match = matchExpr[ type ].exec( soFar )
        //然后看看需不需要预处理：!preFilters[ type ]
        //如果需要 ，那么通过预处理器将匹配到的处理一下 ： match = preFilters[ type ]( match )
        for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {
                matched = match.shift();
                //放入Token序列中
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                });
                //剩余还未分析的字符串需要减去这段已经分析过的
                soFar = soFar.slice( matched.length );
            }
        }
//如果到了这里都还没matched到，那么说明这个选择器在这里有错误
            //直接中断词法分析过程
           //这就是Sizzle对词法分析的异常处理
        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we&apos;re just parsing
    // Otherwise, throw an error or return tokens
    // Return the length of the invalid excess
    // if we&apos;re just parsing
    // Otherwise, throw an error or return tokens
    //放到tokenCache函数里进行缓存
    //如果只需要这个接口检查选择器的合法性，直接就返回soFar的剩余长度，倘若是大于零，说明选择器不合法
    //其余情况，如果soFar长度大于零，抛出异常；否则把groups记录在cache里边并返回，
    return parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens //设置缓存
            tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
    var i = 0,
        len = tokens.length,
        selector = &quot;&quot;;
    for ( ; i &lt; len; i++ ) {
        selector += tokens[i].value;
    }
    return selector;
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
        doneName = done++;

    return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            var data, cache, outerCache,
                dirkey = dirruns + &quot; &quot; + doneName;

            // We can&apos;t set arbitrary data on XML nodes, so they don&apos;t benefit from dir caching
            if ( xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        if ( matcher( elem, context, xml ) ) {
                            return true;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                        if ( (cache = outerCache[ dir ]) &amp;&amp; cache[0] === dirkey ) {
                            if ( (data = cache[1]) === true || data === cachedruns ) {
                                return data === true;
                            }
                        } else {
                            cache = outerCache[ dir ] = [ dirkey ];
                            cache[1] = matcher( elem, context, xml ) || cachedruns;
                            if ( cache[1] === true ) {
                                return true;
                            }
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers.length &gt; 1 ?
        function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return false;
                }
            }
            return true;
        } :
        matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for ( ; i &lt; len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched.push( elem );
                if ( mapped ) {
                    map.push( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( null, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut.length;
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &amp;&amp;
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( null, results, matcherOut, xml );
            } else {
                push.apply( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf.call( checkContext, elem ) &gt; -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i &lt; len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j &lt; len; j++ ) {
                    if ( Expr.relative[ tokens[j].type ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i &gt; 1 &amp;&amp; elementMatcher( matchers ),
                    i &gt; 1 &amp;&amp; toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
                    ).replace( rtrim, &quot;$1&quot; ),
                    matcher,
                    i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
                    j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j &lt; len &amp;&amp; toSelector( tokens )
                );
            }
            matchers.push( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    // A counter to specify which element is currently being matched
    var matcherCachedRuns = 0,
        bySet = setMatchers.length &gt; 0,
        byElement = elementMatchers.length &gt; 0,
        superMatcher = function( seed, context, xml, results, expandContext ) {
            var elem, j, matcher,
                setMatched = [],
                matchedCount = 0,
                i = &quot;0&quot;,
                unmatched = seed &amp;&amp; [],
                outermost = expandContext != null,
                contextBackup = outermostContext,
                // We must always have either seed elements or context
                elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, expandContext &amp;&amp; context.parentNode || context ),
                // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

            if ( outermost ) {
                outermostContext = context !== document &amp;&amp; context;
                cachedruns = matcherCachedRuns;
            }

            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below
            for ( ; (elem = elems[i]) != null; i++ ) {
                if ( byElement &amp;&amp; elem ) {
                    j = 0;
                    while ( (matcher = elementMatchers[j++]) ) {
                        if ( matcher( elem, context, xml ) ) {
                            results.push( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                        cachedruns = ++matcherCachedRuns;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher &amp;&amp; elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched.push( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet &amp;&amp; i !== matchedCount ) {
                j = 0;
                while ( (matcher = setMatchers[j++]) ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount &gt; 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop.call( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push.apply( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
                    ( matchedCount + setMatchers.length ) &gt; 1 ) {

                    Sizzle.uniqueSort( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + &quot; &quot; ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !group ) {
            group = tokenize( selector );
        }
        i = group.length;
        while ( i-- ) {
            cached = matcherFromTokens( group[i] );
            if ( cached[ expando ] ) {
                setMatchers.push( cached );
            } else {
                elementMatchers.push( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    }
    return cached;
};

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts.length;
    for ( ; i &lt; len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

//引擎的主要入口函数
    function select(selector, context, results, seed) {
        var i, tokens, token, type, find,
            //解析出词法格式
            match = tokenize(selector);

        if (!seed) { //如果外界没有指定初始集合seed了。
            // Try to minimize operations if there is only one group
            // 没有多组的情况下
            // 如果只是单个选择器的情况，也即是没有逗号的情况：div, p，可以特殊优化一下
            if (match.length === 1) {

                // Take a shortcut and set the context if the root selector is an ID
                tokens = match[0] = match[0].slice(0); //取出选择器Token序列

                //如果第一个是selector是id我们可以设置context快速查找
                if (tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
                    support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
                    Expr.relative[tokens[1].type]) {

                    context = (Expr.find[&quot;ID&quot;](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        //如果context这个元素（selector第一个id选择器）都不存在就不用查找了
                        return results;
                    }
                    //去掉第一个id选择器
                    selector = selector.slice(tokens.shift().value.length);
                }

                // Fetch a seed set for right-to-left matching
                //其中： &quot;needsContext&quot;= new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; + whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
                //即是表示如果没有一些结构伪类，这些是需要用另一种方式过滤，在之后文章再详细剖析。
                //那么就从最后一条规则开始，先找出seed集合
                i = matchExpr[&quot;needsContext&quot;].test(selector) ? 0 : tokens.length;

                //从右向左边查询
                while (i--) { //从后开始向前找！
                    token = tokens[i]; //找到后边的规则

                    // Abort if we hit a combinator
                    // 如果遇到了关系选择器中止
                    //
                    //  &gt; + ~ 空
                    //
                    if (Expr.relative[(type = token.type)]) {
                        break;
                    }

                    /*
                  先看看有没有搜索器find，搜索器就是浏览器一些原生的取DOM接口，简单的表述就是以下对象了
                  Expr.find = {
                    &apos;ID&apos;    : context.getElementById,
                    &apos;CLASS&apos; : context.getElementsByClassName,
                    &apos;NAME&apos;  : context.getElementsByName,
                    &apos;TAG&apos;   : context.getElementsByTagName
                  }
                */
                    //如果是:first-child这类伪类就没有对应的搜索器了，此时会向前提取前一条规则token
                    if ((find = Expr.find[type])) {

                        // Search, expanding context for leading sibling combinators
                        // 尝试一下能否通过这个搜索器搜到符合条件的初始集合seed
                        if ((seed = find(
                            token.matches[0].replace(runescape, funescape),
                            rsibling.test(tokens[0].type) &amp;&amp; context.parentNode || context
                        ))) {

                            //如果真的搜到了
                            // If seed is empty or no tokens remain, we can return early
                            //把最后一条规则去除掉
                            tokens.splice(i, 1);
                            selector = seed.length &amp;&amp; toSelector(tokens);

                            //看看当前剩余的选择器是否为空
                            if (!selector) {
                                //是的话，提前返回结果了。
                                push.apply(results, seed);
                                return results;
                            }

                            //已经找到了符合条件的seed集合，此时前边还有其他规则，跳出去
                            break;
                        }
                    }
                }
            }
        }


        // &quot;div &gt; p + div.aaron [type=&quot;checkbox&quot;]&quot;

        // Compile and execute a filtering function
        // Provide `match` to avoid retokenization if we modified the selector above
        // 交由compile来生成一个称为终极匹配器
        // 通过这个匹配器过滤seed，把符合条件的结果放到results里边
        //
        //    //生成编译函数
        //  var superMatcher =   compile( selector, match )
        //
        //  //执行
        //    superMatcher(seed,context,!documentIsHTML,results,rsibling.test( selector ))
        //
        compile(selector, match)(
            seed,
            context, !documentIsHTML,
            results,
            rsibling.test(selector)
        );
        return results;
    }

// One-time assignments

// Sort stability
support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;

// Support: Chrome&lt;14
// Always assume duplicates if they aren&apos;t passed to the comparison function
support.detectDuplicates = hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
    // Should return 1, but returns 4 (following)
    return div1.compareDocumentPosition( document.createElement(&quot;div&quot;) ) &amp; 1;
});

// Support: IE&lt;8
// Prevent attribute/property &quot;interpolation&quot;
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
    div.innerHTML = &quot;&lt;a href=&apos;#&apos;&gt;&lt;/a&gt;&quot;;
    return div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
}) ) {
    addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
        if ( !isXML ) {
            return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
        }
    });
}

// Support: IE&lt;9
// Use defaultValue in place of getAttribute(&quot;value&quot;)
if ( !support.attributes || !assert(function( div ) {
    div.innerHTML = &quot;&lt;input/&gt;&quot;;
    div.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
    return div.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
}) ) {
    addHandle( &quot;value&quot;, function( elem, name, isXML ) {
        if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
            return elem.defaultValue;
        }
    });
}

// Support: IE&lt;9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
    return div.getAttribute(&quot;disabled&quot;) == null;
}) ) {
    addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
            return (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
                val.value :
                elem[ name ] === true ? name.toLowerCase() : null;
        }
    });
}

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[&quot;:&quot;] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
// String to Object options format cache
var optionsCache = {};

/*
optionsCache和options的关系是下面这样的：
options:{once:true,memory:true}
optionCache:{&apos;once memory&apos;:{once:true,memory:true}}
*/

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    // 多个变量指向同一对象(或数组)引用时，其中一个变量修改了被引用对象的内部结构，其他引用变量也会表现出来
    var object = optionsCache[ options ] = {};//这里是一个指针引用，两个对象指向同一个地方，所以给object赋值等同于给optionsCache赋值
    //core_rnotwhite是匹配单词的
    jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
        object[ flag ] = true;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *    options: an optional list of space-separated options that will change how
 *            the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * &quot;fired&quot; multiple times.
 *
 * Possible options:
 *
 *    once:            will ensure the callback list can only be fired once (like a Deferred)
 *
 *    memory:            will keep track of previous values and will call any callback added
 *                    after the list has been fired right away with the latest &quot;memorized&quot;
 *                    values (like a Deferred)
 /*
 memory:
 function fn1( value ) {
    console.log( value );
}

function fn2( value ) {
    fn1(&quot;fn2 says: &quot; + value);
    return false;
}
var callbacks = $.Callbacks(&quot;memory&quot;);

callbacks.add( fn1 );
callbacks.fire( &quot;1&quot; );

VM171:2 1
Object {}
callbacks.add( fn1 );
callbacks.fire( &quot;2&quot; );
VM171:2 1
2VM171:2 2
Object {}
callbacks.add( fn1 );
callbacks.fire( &quot;3&quot; );
VM171:2 2
3VM171:2 3
Object {}
callbacks.add( fn1 );
callbacks.fire( &quot;4&quot; );
VM171:2 3
4VM171:2 4
Object {}
 */
 *
 *    unique:            will ensure a callback can only be added once (no duplicate in the list)
 *
 *    stopOnFalse:    interrupt callings when a callback returns false//设计在内部方法fire执行时的for循环上
 *
 */
 /*
 * once: 确保回调列表仅只fire一次，设计在内部方法fire执行时的for循环上
 * unique: 在执行add操作中，确保回调列表中不存在重复的回调，设计在add上
 * stopOnFalse: 当执行回调返回值为false，则终止回调队列的执行
 * momery: 记录上一次fire时的参数，并在add中传递给fire和执行fire，执行时firingIndex为上一次fire时的firingLength memory方法就比较特殊了， 有点类似deferred的感觉，就是能够等全部的add都加载完毕后才触发
           memory的实现思路就是在add的时候直接触发fire,从而再次执行list列表，设计在add上
 */
 //还有需要注意的是，如果回调函数中使用了 this 对象，可以直接用这个 this 来访问self对象的公有API。当然，也可以用 fireWith() 自己指定 this 的引用对象。
 //jQuery.Callbacks()的核心思想是 Pub/Sub 模式，建立了程序间的松散耦合和高效通信。
jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
     // 缓存所有的参数标志，当再次传递已传递过的参数标志，则使用缓存值optionsCache[ options ]
     //通过字符串在optionsCache寻找有没有相应缓存，如果没有则创建一个，有则引用
    //如果是对象则通过jQuery.extend深复制后赋给options。
    //optionsCache[ options ]是说明如果有缓存则先走缓存
    //通过字符串在optionsCache寻找有没有相应缓存，如果没有则创建一个，有则引用
    //如果是对象则通过jQuery.extend深复制后赋给options。
    options = typeof options === &quot;string&quot; ?
       //处理单一参数或者组合参数的情况“once”  “once memory”,optionsCache[ options ]是如果之前存过的话就先走缓存
        ( optionsCache[ options ] || createOptions( options ) ) :
        // 说明也可以这样$.Callbacks({once:true, memory:true})使用
        jQuery.extend( {}, options );//什么情况下不是字符串呢，就是默认情况下，无参数，这typeof options=&quot;undefined&quot;,则便会执行这句话，主要目的是返回空字符串，防止出错

    var // Last fire value (for non-forgettable lists)
        memory,// 最后一次触发回调时传的参数 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred).
        // Flag to know if list was already fired
        fired,// 列表中的函数是否已经回调至少一次
        // Flag to know if list is currently firing
        firing,// 列表中的函数是否正在回调中
        // First callback to fire (used internally by add and fireWith)
        firingStart,// 回调的起点
        // End of the loop when firing
        firingLength,// 回调时的循环结尾
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,// 当前正在回调的函数索引
        // Actual callback list
        list = [],// 回调函数列表
        // Stack of fire calls for repeatable lists
        stack = !options.once &amp;&amp; [],// 可重复的回调函数堆栈，用于控制触发回调时的参数列表
        // Fire callbacks data为fireWith内部整理的args数组
        fire = function( data ) {//用给定的参数调用所有的回调
            //如果参数memory为true，则记录data
            memory = options.memory &amp;&amp; data;
            fired = true;//标记触发回调
            处理在add中，options.memory = true;的情况
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            //标记正在触发回调
            firing = true;
            //进行for循环 
            for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
                // 正在执行的回调返回值为false 且 options.stopOnFalse为true，则终止回调队列的执行
                // 阻止未来可能由于add所产生的回调
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;// 阻止未来可能由于add所产生的回调
                }
            }
            //标记回调结束
            firing = false;
            if ( list ) {
                // 处理正在执行的回调中执行fireWith的操作;
                if ( stack ) {
                    if ( stack.length ) {
                        //从堆栈头部取出，递归fire
                        fire( stack.shift() );
                    }
                    // 上一分支状态为回调执行过，且可以执行多次
          // 此时 options.once = true; 这里将list设置为[]，只是确保下次执行fire时，无回调执行
          // 但是如果 options.memory = true; 仍然会执行add中的fire操作，因为此时回调列表中已有回调
                } else if ( memory ) {//否则，如果有记忆
                    list = [];
                } else {//再否则阻止回调列表中的回调
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        // 暴露在外的Callbacks对象,对外接口
        //外观模式 self.fire –&gt; self.fireWith –&gt; fire
        /*

        var f1 = function() {
    console.log(&quot;f1&quot;);
    return false
  }; //注意 return false;
  var f2 = function() {
    console.log(&quot;f2&quot;);
  };

  var callbacks = $.Callbacks();
  callbacks.add(f1);
  callbacks.add(f2);
  callbacks.fire(); //输出 f1 f2

  callbacks = $.Callbacks(&quot;memory stopOnFalse&quot;);
  callbacks.add(f1);
  callbacks.add(f2);
  callbacks.fire();　　　　 //只输出  f1

  callbacks.add(function() {
    console.log(&quot;f3&quot;);
  }); //不会输出，memory已经失去作用了
  callbacks.fire();　　　　 //重新触发，输出f1
        */

        /*
        var callbacks = $.Callbacks(&quot;memory&quot;);

callbacks.add( fn1 );
callbacks.fire( &quot;1&quot; );

callbacks.add( fn1 );
callbacks.fire( &quot;2&quot; );

callbacks.add( fn1 );
callbacks.fire( &quot;3&quot; );

callbacks.add( fn1 );
callbacks.fire( &quot;4&quot; );
fn1 says: 1
fn1 says: 1
fn1 says: 2
fn1 says: 2
fn1 says: 2
fn1 says: 3 
fn1 says: 3
fn1 says: 3
fn1 says: 3 
fn1 says: 4 
fn1 says: 4
fn1 says: 4 
fn1 says: 4
        */
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {// 回调列表中添加一个回调或回调的集合。
                if ( list ) {
                    // First, we save the current length
                    //首先我们存储当前列表长度
                    var start = list.length;
                    (function add( args ) {
                        //这里处理多参数的情况 ( arguments )如cb.add(aaa,bbb)的情况
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === &quot;function&quot; ) {
                                //防止重复添加（去重操作） // 回调不唯一 或 唯一且不存在，则push  
                                //unique参数体现 //当$.Callbacks(&apos;unique&apos;)时，保证列表里面不会出现重复的回调
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                                // 递归检查
                            } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {//这个是针对数组形式的，例如， cb.add([aaa,bbb],这里aaa和bbb代表的都是函数) //假如传过来的参数为数组或array-like，则继续调用添加，从这里可以看出add的传参可以有add(fn),add([fn1,fn2]),add(fn1,fn2)
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    // 正在执行的回调执行了add操作，则更新firingLength
                     // 如果回调列表中的回调正在执行时，其中的一个回调函数执行了Callbacks.add操作
                    // 上句话可以简称：如果在执行Callbacks.add操作的状态为firing时
                    // 那么需要更新firingLength值
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we&apos;re not firing then
                    // we should call right away
                    // 如果options.memory为true，则再次执行fire，且参数相同，fire中的firingIndex为此时的firingStart
                    } else if ( memory ) {
                        //如果options.memory为true，则将memory做为参数，应用最近增加的回调函数
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            // 从函数列表中删除函数（集）
            remove: function() {// 从回调列表中的删除一个回调或回调集合。
                if ( list ) {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        // while循环的意义在于借助于强大的jQuery.inArray删除函数列表中相同的函数引用（没有设置unique的情况）
                        // jQuery.inArray将每次返回查找到的元素的index作为自己的第三个参数继续进行查找，直到函数列表的尽头
                        // splice删除数组元素，修改数组的结构
                        while( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
                            // 查找到所对应的索引，则移除索引项
                            list.splice( index, 1 );
                            // Handle firing indexes
                            // 正在执行的回调执行了remvoe操作，则更新firingLength和firingIndex的值
                            // 在函数列表处于firing状态时，最主要的就是维护firingLength和firgingIndex这两个值
             // 保证fire时函数列表中的函数能够被正确执行（fire中的for循环需要这两个值
                            if ( firing ) {
                                if ( index &lt;= firingLength ) {
                                    firingLength--;
                                }
                                if ( index &lt;= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            // 回调函数是否在列表中.
            has: function( fn ) {//确定列表中是否提供一个回调
                return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );
            },
            // 从列表中删除所有回调函数
            // Remove all callbacks from the list
            empty: function() {//从列表中删除所有的回调.
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            // 禁用回调列表中的回调。
            disable: function() {//禁用回调列表中的回调 // 禁用add,remove,fire主要方法的工作
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?//  列表中否被禁用
            disabled: function() {//确定回调列表是否已被禁用。
                return !list;
            },
            // Lock the list in its current state// 锁定列表
            lock: function() {//锁定当前状态的回调列表。
                // 如果回调执行过，则将阻止self.fire操作
        // 但如果 options.memory = true，则仍然会执行fire操作
                stack = undefined;
                // 回调未执行，则禁用
                if ( !memory ) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?// 列表是否被锁
            locked: function() {//确定回调列表是否已被锁定。
                return !stack;
            },
            // Call all callbacks with the given context and arguments// 以给定的上下文和参数调用所有回调函数
            fireWith: function( context, args ) {
                // 回调未执行 或 已执行且可以执行多次
                if ( list &amp;&amp; ( !fired || stack ) ) {
                    args = args || [];
                    //判断args是不是数组
                    args = [ context, args.slice ? args.slice() : args ];
                    // 正在执行的回调函数执行了fireWith操作( 暗指回调列表已执行过，且可以执行多次，stack = []; )
          // 该函数需要条件执行，或有移除该函数的操作，否则陷入死循环，详见例2
                    if ( firing ) {
                        //如果正在回调
                        //将参数推入堆栈，等待当前回调结束再调用
                        stack.push( args );
                    } else {// 正在执行的回调函数没有执行fireWith操作//否则直接调用
                        //调用内部的fire方法
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {// 用给定的参数调用所有的回调
                self.fireWith( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            // 回调函数列表是否至少被调用一次
            fired: function() {//访问给定的上下文和参数列表中的所有回调。
                return !!fired;
            }
        };

    return self;
};
//当我们了解了Deferred后，可用$.ajax(&apos;xxx.php&apos;).done(function(){alert(&quot;成功&quot;);}).fail(function(){alert(&quot;失败&quot;);});
//done和fail对应add;resolve和reject对应fire.相应的进行触发。resolve对应done,reject对应fail
//resolve和reject只会一次触发，而notify可以连续触发
jQuery.extend({
    //Deferred是基于Callbacks开发的，所以真正调用的还是Callbacks
    Deferred: function( func ) {
        //回调方法/事件订阅 done，fail，progress; 通知方法/事件发布 resolve，reject，notify，resolveWith，rejectWith，notifyWith
        //tuples 元素集 其实是把相同有共同特性的代码的给合并成一种结构，然后通过一次处理
        var tuples = [
                // action, add listener, listener list, final state
                //成功 失败 处理中 (这是Callbacks中的fire和add抽象出来对应的3种状态) 
                //resolve/reject/notiy对应状态，done/fail/progress对应回调方法，紧接着的对应回调对象来实现回调方法，最后的是最终完成的状态。
                [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
                [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
                [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
            ],
            state = &quot;pending&quot;,//等待状态  deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)
            promise = {
                state: function() {
                    return state;
                },
                //always是总是会触发
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    //return是针对pipe()方法的，它的使用详见2_8图片所示,创建一个延迟对象进行相应操作，之后可在此基础上再创建一个新的延迟对象并进行相应的操作。就是给人一种继承的感觉
                    return jQuery.Deferred(function( newDefer ) {
                        //对数组tuples进行遍历。
                        jQuery.each( tuples, function( i, tuple ) {
                            var action = tuple[ 0 ],
                            //判断是否为函数，如果是函数就返回该函数fns[ i ]，如果不是函数就返回false
                                fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ](function() {
                                //start...
                                var returned = fn &amp;&amp; fn.apply( this, arguments );
                                if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject )
                                        .progress( newDefer.notify );
                                } else {
                                    //这里有return就走return,若无return就走arguments
                                    newDefer[ action + &quot;With&quot; ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                }
                                //end...
                                //其实从start...到end...是和then没什么关系的，它主要是和pipe有关系
                            });
                        });
                        fns = null;
                    }).promise();//这里的promise（）说明了返回的就是不能够修改状态的延迟对象。
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {//在有无参数情况下处理是不同的
                    //通过这句话，就把promise的东西全继承给deferred.
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat,兼容了老版本，promise.pipe是以前版本的，而promise.then是后来版本的，后来发现两者可以合并，但是它们实现的功能还是有区别的
        //pipe就是管道的意思，它是说把延迟对象拉的更长一些,可能是为了满足更复杂的需求吧
        //这说明pipe和then是一样的，but 虽然代码一样，但它们各自实现的功能是不一样的。
        //兼容老版本
        promise.pipe = promise.then;

        // Add list-specific methods（对上面的映射数组tuples进行遍历）
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add  promise是延迟对象哟，把add方法放入到赋值给promoise。
            promise[ tuple[1] ] = list.add;

            // Handle state
            //这里处理的是if state=resolve,则它就不可能是reject;if state=reject,则它就不可能是resolve;对状态进行了处理
            if ( stateString ) {
                //add是可以进行累加的
                list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock// 位运算。实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable，disable是全部阻止，lock是上锁的操作。
                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            }
            /*
            resolve/reject/notify 是 callbacks.fireWith，执行回调函数
      resolveWith/rejectWith/notifyWith 是 callbacks.fireWith 队列方法引用
            */

            // deferred[ resolve | reject | notify ]  deferred也是延迟对象，要注意deferred和promise的区别
            deferred[ tuple[0] ] = function() {
                deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments );
                return this;
            };
            deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
        });

        // Make the deferred a promise
        //最后合并promise到deferred
        //所以最终通过工厂方法Deferred构建的异步对象带的所有的方法了
        promise.promise( deferred );

        //注意：promise和deerred都是延迟对象

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    //注意用when的时候对应的函数参数应返回延迟对象，如 return dfd.不然的话when会把这个函数作为普通函数（和延迟对象无任何关系）
    //so 总结而言就是：如果when传参but没有返回延迟对象或者没有传参，则when均会自动跳过，认为它们和延迟对象无任何关系。
    //when是辅助Deferred对象的，说白了就是一个帮手
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = core_slice.call( arguments ),
            length = resolveValues.length,

            // the count of uncompleted subordinates 计数器，表示未完成的延迟对象有多少个，从而才能返回all 成功还是其中有失败的。jQuery.isFunction( subordinate.promise )就是判断返回值是否是延迟对象。remaining即为计数器（记录未完成的个数）
            remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            //deferred即为延迟对象
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments.length &gt; 1 ? core_slice.call( arguments ) : value;
                    if( values === progressValues ) {
                        deferred.notifyWith( contexts, values );
                    } else if ( !( --remaining ) ) {
                        deferred.resolveWith( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length &gt; 1 ) {
            progressValues = new Array( length );//进行过程中值
            progressContexts = new Array( length );//进行过程中作用域
            resolveContexts = new Array( length );//成功作用域
            for ( ; i &lt; length; i++ ) {
                if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
                    resolveValues[ i ].promise()
                    //resolveValues就是你传的参数的集合
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    //上面的if已经做了判断是否为延迟对象，如果不是，则对普通函数进行计数器减少
                    --remaining;
                }
            }
        }

        // if we&apos;re not waiting on anything, resolve the master触发
        if ( !remaining ) {
            deferred.resolveWith( resolveContexts, resolveValues );
        }
    //返回延迟对象状态
        return deferred.promise();
    }
});
jQuery.support = (function( support ) {
    //采用创建元素的方式对兼容性检测
    var input = document.createElement(&quot;input&quot;),
        fragment = document.createDocumentFragment(),
        div = document.createElement(&quot;div&quot;),
        select = document.createElement(&quot;select&quot;),
        opt = select.appendChild( document.createElement(&quot;option&quot;) );

    // Finish early in limited environments
    if ( !input.type ) {
        return support;
    }

    input.type = &quot;checkbox&quot;;

    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // Check the default checkbox/radio value (&quot;&quot; on old WebKit; &quot;on&quot; elsewhere)
    support.checkOn = input.value !== &quot;&quot;;

    // Must access the parent to make an option select properly
    // Support: IE9, IE10
    support.optSelected = opt.selected;

    // Will be defined later首先定义值，后续再进行处理。之所以这样做是因为这几个值会等待页面全部加载完成后才能真正判断出来，而那些无需赋初始值就直接进行判断的是因为页面一加载就可以判断出来的
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;

    // Make sure checked status is properly cloned
    // Support: IE9, IE10
    input.checked = true;
    support.noCloneChecked = input.cloneNode( true ).checked;

    // Make sure that the options inside disabled selects aren&apos;t marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Check if an input maintains its value after becoming a radio
    // Support: IE9, IE10

    //注意这里顺序书写的问题导致的兼容性问题
    input = document.createElement(&quot;input&quot;);
    input.value = &quot;t&quot;;
    input.type = &quot;radio&quot;;
    support.radioValue = input.value === &quot;t&quot;;

    // #11217 - WebKit loses check when the name is after the checked attribute
    input.setAttribute( &quot;checked&quot;, &quot;t&quot; );
    input.setAttribute( &quot;name&quot;, &quot;t&quot; );

    fragment.appendChild( input );

    // Support: Safari 5.1, Android 4.x, Android 2.3
    // old WebKit doesn&apos;t clone checked state correctly in fragments
    support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

    // Support: Firefox, Chrome, Safari
    // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
    //onfocusin是个事件
    support.focusinBubbles = &quot;onfocusin&quot; in window;

    div.style.backgroundClip = &quot;content-box&quot;;
    div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
    //元素是否会受到克隆的影响
    support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;

    // Run tests that need a body at doc ready
    //等待DOM加载完才进行的功能检测
    jQuery(function() {
        var container, marginDiv,
            // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
            //box-sizing主要是测试当前页面是标准模式还是怪异模式content-box就是标准模式，border-box是怪异模式
         //标准模式和怪异模式主要是影响了布局中的盒模型
            divReset = &quot;padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box&quot;,
            body = document.getElementsByTagName(&quot;body&quot;)[ 0 ];

        if ( !body ) {
            // Return for frameset docs that don&apos;t have a body
            return;
        }

        container = document.createElement(&quot;div&quot;);
        //left:-9999px;是让它不要显示在页面之中，待检测完成后再把它从页面中删除。margin-top:1px是同jQuery 1点几的版本有关的，原因就是jquery2.几的版本相对于1.几的版本功能检测的要少一些
        container.style.cssText = &quot;border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px&quot;;

        // Check box-sizing and margin behavior.
        body.appendChild( container ).appendChild( div );
        div.innerHTML = &quot;&quot;;
        // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).

        div.style.cssText = &quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%&quot;;

        // Workaround failing boxSizing test due to offsetWidth returning wrong value
        // with some non-1 values of body zoom, ticket #13543
        //css转换方法，zoom设置页面的显示比例
        jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
            support.boxSizing = div.offsetWidth === 4;
        });

        // Use window.getComputedStyle because jsdom on node.js will break without it.
        if ( window.getComputedStyle ) {
            support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== &quot;1%&quot;;
            support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: &quot;4px&quot; } ).width === &quot;4px&quot;;

            // Support: Android 2.3
            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. (#3333)
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            marginDiv = div.appendChild( document.createElement(&quot;div&quot;) );
            marginDiv.style.cssText = div.style.cssText = divReset;
            marginDiv.style.marginRight = marginDiv.style.width = &quot;0&quot;;
            div.style.width = &quot;1px&quot;;

            support.reliableMarginRight =
                !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
        }

        body.removeChild( container );
    });

    return support;
})( {} );//传json参数进去，且本函数最终返回json support.

/*
data_user 存储对象
data-priv 存储对象

data_user和data_priv, 就如其名, 一个是用户用的, 一个是jQuery私有的, 他们都是一个叫Data的实例对象
    Implementation Summary

    1. Enforce API surface and semantic compatibility with 1.9.x branch
    2. Improve the module&apos;s maintainability by reducing the storage
        paths to a single mechanism.
    3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
    4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
    5. Avoid exposing implementation details on user objects (eg. expando properties)
    6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var data_user, data_priv, 
    rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
    rmultiDash = /([A-Z])/g;

/*
cache对象结构应该像下面这样：
var cache = {
    &quot;uid1&quot;: { // DOM节点1缓存数据，
        &quot;name1&quot;: value1,
        &quot;name2&quot;: value2
    },
    &quot;uid2&quot;: { // DOM节点2缓存数据，
        &quot;name1&quot;: value1,
        &quot;name2&quot;: value2
    }
    // ......
};
*/

function Data() {
    // Support: Android &lt; 4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    //先在jQuery内部创建一个cache对象{}, 来保存缓存数据。 然后往需要进行缓存的DOM节点上扩展一个值为expando的属性
    //注：expando的值，用于把当前数据缓存的UUID值做一个节点的属性给写入到指定的元素上形成关联桥梁,所以，所以元素本身具有这种属性的可能性很少，所以可以忽略冲突。
    Object.defineProperty( this.cache = {}, 0, {
        get: function() {
            return {};
        }
    });
   //dom与data映射的uuid  // 每个jQuery拷贝都有一个其唯一的标志。比如你的页面有两个iframe且每个iframe都用到的jQuery。name你的两个iframe就有两份jQuery拷贝。
    this.expando = jQuery.expando + Math.random();
}

//接着把每个节点的dom[expando]的值都设为一个自增的变量id，保持全局唯一性。 这个id的值就作为cache的key用来关联DOM节点和数据。也就是说cache[id]就取到了这个节点上的所有缓存，即id就好比是打开一个房间(DOM节点)的钥匙。 而每个元素的所有缓存都被放到了一个map映射里面，这样可以同时缓存多个数据。
//关联起dom对象与数据缓存对象的一个索引标记，换句话说.先在dom元素上找到expando对应值，也就uid，然后通过这个uid找到数据cache对象中的内容
//每个uid对应一个elem缓存数据，每个缓存对象是可以由多个name/value(名值对)对组成的，而value是可以是任何数据类型的。

Data.uid = 1;//每次自增变量

/**
     * 只能接受
     * 元素节点
     * 文档节点
     * 任何对象
     * @param  {[type]} owner [description]
     * @return {[type]}       [description]
     */
/主要用在acceptData函数中确定元素是否可以添加expando属性     
Data.accepts = function( owner ) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType ?
        owner.nodeType === 1 || owner.nodeType === 9 : true;
};

Data.prototype = {
    // 只能保证是DOM节点才可以
            //  
            //  以前的版本用的 逆天的 valueOf重写保存变量，但是太吃内存了
            //  
    key: function( owner ) {
        //key函数是让DOM元素设置xxx=&quot;key值&quot;，然后在把往catch里写json(key{})的方式，只不过刚开始json是空的，等调用了set函数后就会相应设置值了 
        // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return the key for a frozen object.
        if ( !Data.accepts( owner ) ) {
            return 0;
        }

        var descriptor = {},
            // Check if the owner object already has a cache key
            // 看看node对象有没有这个UUID映射
            unlock = owner[ this.expando ];

        // If not, create one// 如果没有，就创建它
        if ( !unlock ) {
            unlock = Data.uid++;

            // Secure it in a non-enumerable, non-writable property
            // 为了安全起见，这个值通过es5设置，保证不能遍历，不能改写
            try {
                descriptor[ this.expando ] = { value: unlock };
                Object.defineProperties( owner, descriptor );

            // Support: Android &lt; 4
            // Fallback to a less secure definition
            } catch ( e ) {
                descriptor[ this.expando ] = unlock;
                jQuery.extend( owner, descriptor );
            }
        }

        // Ensure the cache object
        if ( !this.cache[ unlock ] ) {// 确保缓存中有个对象容器
            this.cache[ unlock ] = {};
        }

        return unlock;
    },
    set: function( owner, data, value ) {
        var prop,
            // There may be an unlock assigned to this node,
            // if there is no entry for this &quot;owner&quot;, create one inline
            // and set the unlock as though an owner entry had always existed
            // 可能是一个解锁后分配给这个节点
                // 统一创建
            unlock = this.key( owner ),
            cache = this.cache[ unlock ];

        // Handle: [ owner, key, value ] args
        // 根据传递的参数类型,保存到cache上
        if ( typeof data === &quot;string&quot; ) {
            cache[ data ] = value;

        // Handle: [ owner, { properties } ] args
        } else {
            // Fresh assignments by object are shallow copied
            if ( jQuery.isEmptyObject( cache ) ) {
                jQuery.extend( this.cache[ unlock ], data );
            // Otherwise, copy the properties one-by-one to the cache object
            } else {
                for ( prop in data ) {//分解对象
                    cache[ prop ] = data[ prop ];
                }
            }
        }
        return cache;
    },
    get: function( owner, key ) {
        // Either a valid cache is found, or will be created.
        // New caches will be created and the unlock returned,
        // allowing direct access to the newly created
        // empty data object. A valid owner object must be provided.
        // 取出所有的缓存
        var cache = this.cache[ this.key( owner ) ];

        return key === undefined ?//根据key找到对应的数据
            cache : cache[ key ];
    },
    /**
         * 存储器
         * 可以set 与 get处理
         */
    access: function( owner, key, value ) {
        var stored;
        // In cases where either:
        //
        //   1. No key was specified
        //   2. A string key was specified, but no value provided
        //
        // Take the &quot;read&quot; path and allow the get method to determine
        // which value to return, respectively either:
        //
        //   1. The entire cache object
        //   2. The data stored at the key
        //
        if ( key === undefined ||
                ((key &amp;&amp; typeof key === &quot;string&quot;) &amp;&amp; value === undefined) ) {

            stored = this.get( owner, key );

            return stored !== undefined ?
                stored : this.get( owner, jQuery.camelCase(key) );
        }

        // [*]When the key is not a string, or both a key and value
        // are specified, set or extend (existing objects) with either:
        //
        //   1. An object of properties
        //   2. A key and value
        //
        this.set( owner, key, value );

        // Since the &quot;set&quot; path can have two possible entry points
        // return the expected data based on which path was taken[*]
        return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
        var i, name, camel,
            unlock = this.key( owner ),
            cache = this.cache[ unlock ];

        if ( key === undefined ) {
            this.cache[ unlock ] = {};

        } else {
            // Support array or space separated string of keys
            if ( jQuery.isArray( key ) ) {
                // If &quot;name&quot; is an array of keys...
                // When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,
                // keys will be converted to camelCase.
                // Since there is no way to tell _how_ a key was added, remove
                // both plain key and camelCase key. #12786
                // This will only penalize the array argument path.
                name = key.concat( key.map( jQuery.camelCase ) );
            } else {
                camel = jQuery.camelCase( key );
                // Try the string as a key before any manipulation
                if ( key in cache ) {
                    name = [ key, camel ];
                } else {
                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    name = camel;
                    name = name in cache ?
                        [ name ] : ( name.match( core_rnotwhite ) || [] );
                }
            }

            i = name.length;
            while ( i-- ) {
                delete cache[ name[ i ] ];
            }
        }
    },
    hasData: function( owner ) {
        return !jQuery.isEmptyObject(
            this.cache[ owner[ this.expando ] ] || {}
        );
    },
    discard: function( owner ) {
        if ( owner[ this.expando ] ) {
            delete this.cache[ owner[ this.expando ] ];
        }
    }
};

// These may be used throughout the jQuery core codebase
data_user = new Data();//存数据的//用户使用
  //存储对象
    //jQuery内部私有
    //用来存事件的, 如click事件那种  
data_priv = new Data();


jQuery.extend({
    //可接受数据的范围
    acceptData: Data.accepts,
/**
         * 是否有数据
         * @param  {[type]} elem [description]
         * @return {[type]}      [description]
         */
    hasData: function( elem ) {
        return data_user.hasData( elem ) || data_priv.hasData( elem );
    },

    data: function( elem, name, data ) {
        return data_user.access( elem, name, data );
    },

    removeData: function( elem, name ) {
        data_user.remove( elem, name );
    },

    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to data_priv methods, these can be deprecated.
    // 内部使用
    _data: function( elem, name, data ) {
        return data_priv.access( elem, name, data );
    },

    _removeData: function( elem, name ) {
        data_priv.remove( elem, name );
    }
});

jQuery.fn.extend({
    data: function( key, value ) {//内部使用基础api：jQuery.data来实现,可以使用参数(key,value),也可以使用参数（obj）
        var attrs, name,
            elem = this[ 0 ],
            i = 0,
            data = null;

        // Gets all values
        if ( key === undefined ) {
            if ( this.length ) {
                data = data_user.get( elem );

                if ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, &quot;hasDataAttrs&quot; ) ) {
                    attrs = elem.attributes;
                    for ( ; i &lt; attrs.length; i++ ) {
                        name = attrs[ i ].name;

                        if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
                            name = jQuery.camelCase( name.slice(5) );
                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                    data_priv.set( elem, &quot;hasDataAttrs&quot;, true );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === &quot;object&quot; ) {
            return this.each(function() {
                data_user.set( this, key );
            });
        }

        return jQuery.access( this, function( value ) {
            var data,
                camelKey = jQuery.camelCase( key );

            // The calling jQuery object (element matches) is not empty
            // (and therefore has an element appears at this[ 0 ]) and the
            // `value` parameter was not undefined. An empty jQuery object
            // will result in `undefined` for elem = this[ 0 ] which will
            // throw an exception if an attempt to read a data cache is made.
            if ( elem &amp;&amp; value === undefined ) {
                // Attempt to get data from the cache
                // with the key as-is
                data = data_user.get( elem, key );
                if ( data !== undefined ) {
                    return data;
                }

                // Attempt to get data from the cache
                // with the key camelized
                data = data_user.get( elem, camelKey );
                if ( data !== undefined ) {
                    return data;
                }

                // Attempt to &quot;discover&quot; the data in
                // HTML5 custom data-* attrs
                data = dataAttr( elem, camelKey, undefined );
                if ( data !== undefined ) {
                    return data;
                }

                // We tried really hard, but the data doesn&apos;t exist.
                return;
            }

            // Set the data...
            this.each(function() {
                // First, attempt to store a copy or reference of any
                // data that might&apos;ve been store with a camelCased key.
                var data = data_user.get( this, camelKey );

                // For HTML5 data-* attribute interop, we have to
                // store property names with dashes in a camelCase form.
                // This might not apply to all properties...*
                data_user.set( this, camelKey, value );

                // *... In the case of properties that might _actually_
                // have dashes, we need to also store a copy of that
                // unchanged property.
                if ( key.indexOf(&quot;-&quot;) !== -1 &amp;&amp; data !== undefined ) {
                    data_user.set( this, key, value );
                }
            });
        }, null, value, arguments.length &gt; 1, null, true );
    },

    removeData: function( key ) {//内部使用基础api: jQuery.removeData来实现
        return this.each(function() {
            data_user.remove( this, key );
        });
    }
});

/**
     * 处理HTML5的data-*属性
     * 逻辑结构更为清晰
     * @param  {[type]} elem [description]
     * @param  {[type]} key  [description]
     * @param  {[type]} data [description]
     * @return {[type]}      [description]
     */
function dataAttr( elem, key, data ) {
    var name;

    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
        name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase();
        data = elem.getAttribute( name );

        if ( typeof data === &quot;string&quot; ) {
            try {
                data = data === &quot;true&quot; ? true :
                    data === &quot;false&quot; ? false :
                    data === &quot;null&quot; ? null :
                    // Only convert to a number if it doesn&apos;t change the string
                    +data + &quot;&quot; === data ? +data :
                    rbrace.test( data ) ? JSON.parse( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn&apos;t changed later
            data_user.set( elem, key, data );
        } else {
            data = undefined;
        }
    }
    return data;
}

/**
 * jQuery队列
 * jQuery的队列依赖缓存机制事件，它同时是animate的基础。
 * 它不像事件机制、缓存机制、回调机制一样有自己的命名空间，
 * 由于比较简单，所以直接挂在到$和jQuery对象上。
 */
jQuery.extend({
    //加入动画队列
    //将data按照某种类型存储到elem对应的队列中，并等待执行。同时返回目前队列中的所有数据
    第一个参数elem是DOM元素，第二个参数type是字符串，第三个参数data可以是function或数组。
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            //默认处理动画队列 默认队列的名称是fx
            type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
            //取出关联到现有元素上的所有队列
            queue = data_priv.get( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                //如果elem还没有在cache中存储过名为type的数据，或者需要存储的数据时数组
                if ( !queue || jQuery.isArray( data ) ) {
                    queue = data_priv.access( elem, type, jQuery.makeArray(data) );
                } else {
                    queue.push( data );
                }
            }
            return queue || [];
        }
    },
   //执行动画队列
    //出列操作，如果想要执行队列中的所有方法，则有多少个方法就需要执行多少次dequeue方法
    dequeue: function( elem, type ) {
        //如果指定类型就按照指定类型查找，否则默认是“fx”
        type = type || &quot;fx&quot;;

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            //取出队列（数组）中的第一个值（先进先出），
            //第一个数据是上一次执行dequeue时添加到队列中的“inprogress”占位符
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            //预先准备好下一个队列操作
            next = function() {
                jQuery.dequeue( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        // 当进行出栈操作时，总是删除名为“inprogress”的数据，并继续取下一条。
        // 队列中也存在占位符，用于动画处理
        if ( fn === &quot;inprogress&quot; ) {
            // 函数执行前, 在queue数组的最前面添加一个进程锁，就实在之前清除的 
            fn = queue.shift();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === &quot;fx&quot; ) {
                queue.unshift( &quot;inprogress&quot; );
            }

            // clear up the last queue stop function
            delete hooks.stop;
            //执行动画回调
            fn.call( elem, next, hooks );
        }

        if ( !startLength &amp;&amp; hooks ) {
            hooks.empty.fire();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    // 从elem相应类型对应的队列中下一条数据并执行这条数据

    //dequeue不仅是取出来还需要执行，在执行的时候把next与hooks传递给外部的回调
    //这就是js的逻辑上的很绕的地方，在内部可以传递一个引用出去，又能提供外部调用或者执行
    _queueHooks: function( elem, type ) {
        var key = type + &quot;queueHooks&quot;;
        return data_priv.get( elem, key ) || data_priv.access( elem, key, {
            empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() {
                data_priv.remove( elem, [ type + &quot;queue&quot;, key ] );
            })
        });
    }
});
//内部动画队列
jQuery.fn.extend({
    //queue方法，相当于数组中的push操作。dequeue相当于数组的shift操作。
    queue: function( type, data ) {
        var setter = 2;
    //修正type, 默认为表示jquery动画的fx, 如果不为&quot;fx&quot;, 
        //即为自己的自定义动画, 一般我们用&quot;fx&quot;就足够了.
        if ( typeof type !== &quot;string&quot; ) {
            data = type;
            type = &quot;fx&quot;;
            setter--;
        }
    //只有动画的回调
        if ( arguments.length &lt; setter ) {
            return jQuery.queue( this[0], type );
        }
    //生成的动画数据
        //动画队列
        //动画钩子
        return data === undefined ?
            this :
            this.each(function() {
                //调用基础队列
                //设置动画队列缓存
                //并返回队列总数
                var queue = jQuery.queue( this, type, data );

                // ensure a hooks for this queue
                // 确保是一个队列钩子
                jQuery._queueHooks( this, type );
                //直接执行动画队列
                //防止在执行函数的时候, 这里又进行dequeue操作, 这样会同时执行2个函数, 队列就不受控制了.
                //其实就是通过inprogress这个参数。判断从什么时候开始真正执行动画

                if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {
                    //如果队列没有被锁住, 即此时没有在执行dequeue. 移出队列里第一个函数并执行它.
                    jQuery.dequeue( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this.each(function() {
            jQuery.dequeue( this, type );
        });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || &quot;fx&quot;;

        return this.queue( type, function( next, hooks ) {
            var timeout = setTimeout( next, time );
            hooks.stop = function() {
                clearTimeout( timeout );
            };
        });
    },
    clearQueue: function( type ) {
        return this.queue( type || &quot;fx&quot;, [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            };

        if ( typeof type !== &quot;string&quot; ) {
            obj = type;
            type = undefined;
        }
        type = type || &quot;fx&quot;;

        while( i-- ) {
            tmp = data_priv.get( elements[ i ], type + &quot;queueHooks&quot; );
            if ( tmp &amp;&amp; tmp.empty ) {
                count++;
                tmp.empty.add( resolve );
            }
        }
        resolve();
        return defer.promise( obj );
    }
});
var nodeHook, boolHook,
    rclass = /[\t\r\n\f]/g,
    rreturn = /\r/g,
    rfocusable = /^(?:input|select|textarea|button)$/i;

//这里的jQuery.fn.extend是用于外部使用的，也就是这里的方法调用了jQuery.extend中的方法。
jQuery.fn.extend({
    attr: function( name, value ) {
        return jQuery.access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
    },

    removeAttr: function( name ) {
        return this.each(function() {
            jQuery.removeAttr( this, name );
        });
    },

    prop: function( name, value ) {
        return jQuery.access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
    },

    removeProp: function( name ) {
        return this.each(function() {
            delete this[ jQuery.propFix[ name ] || name ];
        });
    },

    addClass: function( value ) {
        var classes, elem, cur, clazz, j,
            i = 0,
            len = this.length,
            proceed = typeof value === &quot;string&quot; &amp;&amp; value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).addClass( value.call( this, j, this.className ) );
            });
        }

        if ( proceed ) {
            // The disjunction here is for better compressibility (see removeClass)
            classes = ( value || &quot;&quot; ).match( core_rnotwhite ) || [];

            for ( ; i &lt; len; i++ ) {
                elem = this[ i ];
                cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?
                    ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) :
                    &quot; &quot;
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
                            cur += clazz + &quot; &quot;;
                        }
                    }
                    elem.className = jQuery.trim( cur );

                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var classes, elem, cur, clazz, j,
            i = 0,
            len = this.length,
            proceed = arguments.length === 0 || typeof value === &quot;string&quot; &amp;&amp; value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).removeClass( value.call( this, j, this.className ) );
            });
        }
        if ( proceed ) {
            classes = ( value || &quot;&quot; ).match( core_rnotwhite ) || [];

            for ( ; i &lt; len; i++ ) {
                elem = this[ i ];
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?
                    ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) :
                    &quot;&quot;
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        // Remove *all* instances
                        while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt;= 0 ) {
                            cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
                        }
                    }
                    elem.className = value ? jQuery.trim( cur ) : &quot;&quot;;
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value;

        if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; type === &quot;string&quot; ) {
            return stateVal ? this.addClass( value ) : this.removeClass( value );
        }

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( i ) {
                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
            });
        }

        return this.each(function() {
            if ( type === &quot;string&quot; ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    classNames = value.match( core_rnotwhite ) || [];

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    if ( self.hasClass( className ) ) {
                        self.removeClass( className );
                    } else {
                        self.addClass( className );
                    }
                }

            // Toggle whole class name
            } else if ( type === core_strundefined || type === &quot;boolean&quot; ) {
                if ( this.className ) {
                    // store className if set
                    data_priv.set( this, &quot;__className__&quot;, this.className );
                }

                // If the element has a class name or if we&apos;re passed &quot;false&quot;,
                // then remove the whole classname (if there was one, the above saved it).
                // Otherwise bring back whatever was previously saved (if anything),
                // falling back to the empty string if nothing was stored.
                this.className = this.className || value === false ? &quot;&quot; : data_priv.get( this, &quot;__className__&quot; ) || &quot;&quot;;
            }
        });
    },

    hasClass: function( selector ) {
        var className = &quot; &quot; + selector + &quot; &quot;,
            i = 0,
            l = this.length;
        for ( ; i &lt; l; i++ ) {
            if ( this[i].nodeType === 1 &amp;&amp; (&quot; &quot; + this[i].className + &quot; &quot;).replace(rclass, &quot; &quot;).indexOf( className ) &gt;= 0 ) {
                return true;
            }
        }

        return false;
    },

    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments.length ) {
            if ( elem ) {
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
                    return ret;
                }

                ret = elem.value;

                return typeof ret === &quot;string&quot; ?
                    // handle most common string cases
                    ret.replace(rreturn, &quot;&quot;) :
                    // handle cases where value is null/undef or number
                    ret == null ? &quot;&quot; : ret;
            }

            return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
            var val;

            if ( this.nodeType !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value.call( this, i, jQuery( this ).val() );
            } else {
                val = value;
            }

            // Treat null/undefined as &quot;&quot;; convert numbers to string
            if ( val == null ) {
                val = &quot;&quot;;
            } else if ( typeof val === &quot;number&quot; ) {
                val += &quot;&quot;;
            } else if ( jQuery.isArray( val ) ) {
                val = jQuery.map(val, function ( value ) {
                    return value == null ? &quot;&quot; : value + &quot;&quot;;
                });
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !(&quot;set&quot; in hooks) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
                this.value = val;
            }
        });
    }
});


//这里的jQuery.extend主要是用于内部使用的
jQuery.extend({
    valHooks: {
        option: {
            get: function( elem ) {
                // attributes.value is undefined in Blackberry 4.7 but
                // uses .value. See #6932
                var val = elem.attributes.value;
                return !val || val.specified ? elem.value : elem.text;
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === &quot;select-one&quot; || index &lt; 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index &lt; 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i &lt; max; i++ ) {
                    option = options[ i ];

                    // IE6-9 doesn&apos;t update selected after form reset (#2551)
                    if ( ( option.selected || i === index ) &amp;&amp;
                            // Don&apos;t return options that are disabled or in a disabled optgroup
                            ( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null ) &amp;&amp;
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don&apos;t need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values.push( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var optionSet, option,
                    options = elem.options,
                    values = jQuery.makeArray( value ),
                    i = options.length;

                while ( i-- ) {
                    option = options[ i ];
                    if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) &gt;= 0) ) {
                        optionSet = true;
                    }
                }

                // force browsers to behave consistently when non-matching value is set
                if ( !optionSet ) {
                    elem.selectedIndex = -1;
                }
                return values;
            }
        }
    },

    attr: function( elem, name, value ) {
        var hooks, ret,
            nType = elem.nodeType;

        // don&apos;t get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === core_strundefined ) {
            return jQuery.prop( elem, name, value );
        }

        // All attributes are lowercase
        // Grab necessary hook if one is defined  jQuery.isXMLDoc调用了Sizzle的isXML方法
        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] ||
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === null ) {
                jQuery.removeAttr( elem, name );

            } else if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem.setAttribute( name, value + &quot;&quot; );
                return value;
            }

        } else if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
            return ret;

        } else {
            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var name, propName,
            i = 0,
            attrNames = value &amp;&amp; value.match( core_rnotwhite );

        if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
            while ( (name = attrNames[i++]) ) {
                propName = jQuery.propFix[ name ] || name;

                // Boolean attributes get special treatment (#10870)
                if ( jQuery.expr.match.bool.test( name ) ) {
                    // Set corresponding property to false
                    elem[ propName ] = false;
                }

                elem.removeAttribute( name );
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                if ( !jQuery.support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to default in case type is set after value during creation
                    var val = elem.value;
                    elem.setAttribute( &quot;type&quot;, value );
                    if ( val ) {
                        elem.value = val;
                    }
                    return value;
                }
            }
        }
    },


/*
由于class属于JavaScript保留值，因此当我们要操作元素的class属性值时，直接使用obj.getAttribute(&apos;class&apos;)和obj.setAttribute(&apos;class&apos;, &apos;value&apos;)可能会遭遇浏览器兼容性问题，W3C DOM标准为每个节点提供了一个可读写的className属性，作为节点class属性的映射，标准浏览器的都提供了这一属性的支持，因此，可以使用e.className访问元素的class属性值，也可对该属性进行重新斌值。而IE和Opera中也可使用e.getAttribute(&apos;className&apos;)和e.setAttribute(&apos;className&apos;, &apos;value&apos;)访问及修改class属性值。相比之下，e.className是W3C DOM标准，仍然是兼容性最强的解决办法。
同理htmlFor用于读取label标签的for属性
*/
    propFix: {
        &quot;for&quot;: &quot;htmlFor&quot;,
        &quot;class&quot;: &quot;className&quot;
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don&apos;t get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            //这里主要是对tabindex做的兼容
            hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
            return hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ?
                ret :
                ( elem[ name ] = value );

        } else {
            return hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ?
                ret :
                elem[ name ];
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                return elem.hasAttribute( &quot;tabindex&quot; ) || rfocusable.test( elem.nodeName ) || elem.href ?
                    elem.tabIndex :
                    -1;
            }
        }
    }
});

// Hooks for boolean attributes
/*
属性操作的钩子

propFix

propHooks

attrHooks

valHooks
*/

boolHook = {
    set: function( elem, value, name ) {
        if ( value === false ) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
        } else {
            elem.setAttribute( name, name );
        }
        return name;
    }
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
    var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

    jQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {
        var fn = jQuery.expr.attrHandle[ name ],
            ret = isXML ?
                undefined :
                /* jshint eqeqeq: false */
                // Temporarily disable this handler to check existence
                (jQuery.expr.attrHandle[ name ] = undefined) !=
                    getter( elem, name, isXML ) ?

                    name.toLowerCase() :
                    null;

        // Restore handler
        jQuery.expr.attrHandle[ name ] = fn;

        return ret;
    };
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate   option下的选择框兼容情况
if ( !jQuery.support.optSelected ) {
    jQuery.propHooks.selected = {
        get: function( elem ) {
            var parent = elem.parentNode;
            if ( parent &amp;&amp; parent.parentNode ) {
                parent.parentNode.selectedIndex;
            }
            return null;
        }
    };
}

/*
tabIndex 属性可设置或返回按钮的 tab 键控制次序
readonly 属性规定输入字段为只读。
maxlength 属性规定输入字段的最大长度，以字符个数计。
cellspacing 属性规定单元格之间的空间
cellpadding 属性规定单元边沿与其内容之间的空白。
rowspan 属性规定单元格可横跨的行数。
colspan 属性规定单元格可横跨的列数。
HTML &lt;img&gt; 标签的
usemap 属性将图像定义为客户端图像映射
frameBorder 属性设置或返回是否显示框架周围的边框。
contenteditable 属性规定是否可编辑元素的内容。
*/
jQuery.each([
    &quot;tabIndex&quot;,
    &quot;readOnly&quot;,
    &quot;maxLength&quot;,
    &quot;cellSpacing&quot;,
    &quot;cellPadding&quot;,
    &quot;rowSpan&quot;,
    &quot;colSpan&quot;,
    &quot;useMap&quot;,
    &quot;frameBorder&quot;,
    &quot;contentEditable&quot;
], function() {
    //值得一提的是这个方法用的比较巧妙了，收集所有的合集名，然后在每一个上下文回调中把每一个名字传递到propFix方法,key转成小写,value保存正确写法
    jQuery.propFix[ this.toLowerCase() ] = this;
});

// Radios and checkboxes getter/setter
jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
    jQuery.valHooks[ this ] = {
        set: function( elem, value ) {
            if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );
            }
        }
    };
    if ( !jQuery.support.checkOn ) {
        jQuery.valHooks[ this ].get = function( elem ) {
            // Support: Webkit
            // &quot;&quot; is returned instead of &quot;on&quot; if a value isn&apos;t specified
            return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value;
        };
    }
});
var rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
    return true;
}

function returnFalse() {
    return false;
}

function safeActiveElement() {
    try {
        return document.activeElement;
    } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards&apos; addEvent library for many of the ideas.
 */
 /*
 不管你用的是（click / bind / delegate)之中那个方法，最终都是jQuery底层都是调用on方法来完成最终的事件绑定。
 .on()方法事件处理程序到当前选定的jQuery对象中的元素。在jQuery 1.7中，.on()方法 提供绑定事件处理的所有功能
 */

jQuery.event = {

    global: {},

    add: function( elem, types, handler, data, selector ) {

        var handleObjIn, eventHandle, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            //获取数据缓存，在$.cahce缓存中获取存储的事件句柄对象，如果没就新建elemData
            elemData = data_priv.get( elem );

        // Don&apos;t attach events to noData or text/comment nodes (but allow plain objects)
        if ( !elemData ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
            //为每一个事件的句柄给一个标示，添加ID的目的是 用来寻找或者删除handler，因为这个东东是缓存在缓存对象上的，没有直接跟元素节点发生关联
            handler.guid = jQuery.guid++;
        }

        // Init the element&apos;s event structure and main handler, if this is the first
        if ( !(events = elemData.events) ) {
            events = elemData.events = {};
        }
        if ( !(eventHandle = elemData.handle) ) {
            eventHandle = elemData.handle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== core_strundefined &amp;&amp; (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space// 事件可能是通过空格键分隔的字符串，所以将其变成字符串数组
        types = ( types || &quot;&quot; ).match( core_rnotwhite ) || [&quot;&quot;];
        // 例如：&apos;.a .b .c&apos;.match(/\S+/g) → [&quot;.a&quot;, &quot;.b&quot;, &quot;.c&quot;]
    // 事件的个数
        t = types.length;
        while ( t-- ) {
            // 尝试取出事件的命名空间
    // 如&quot;mouseover.a.b&quot; → [&quot;mouseover.a.b&quot;, &quot;mouseover&quot;, &quot;a.b&quot;]
            tmp = rtypenamespace.exec( types[t] ) || [];
            // 取出事件类型，如mouseover
            type = origType = tmp[1];
            // 取出事件命名空间，如a.b，并根据&quot;.&quot;分隔成数组
            namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

            // There *must* be a type, no attaching namespace-only handlers
            if ( !type ) {
                continue;
            }

            // If event changes its type, use the special event handlers for the changed type
            // 事件是否会改变当前状态，如果会则使用特殊事件
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            // 根据是否已定义selector，决定使用哪个特殊事件api，如果没有非特殊事件，则用type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            // type状态发生改变，重新定义特殊事件
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
             // 这里把handleObj叫做事件处理对象,扩展一些来着handleObjIn的属性
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
                namespace: namespaces.join(&quot;.&quot;)
            }, handleObjIn );

            // Init the event handler queue if we&apos;re the first
             // 初始化事件处理列队，如果是第一次使用，将执行语句
            if ( !(handlers = events[ type ]) ) {
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                // Only use addEventListener if the special events handler returns false
                // 如果获取特殊事件监听方法失败，则使用addEventListener进行添加事件
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );
                    }
                }
            }
      // 特殊事件使用add处理
            if ( special.add ) {
                special.add.call( elem, handleObj );
        // 设置事件处理函数的ID
                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add to the element&apos;s handler list, delegates in front
            // 将事件处理对象推入处理列表，姑且定义为事件处理对象包
            if ( selector ) {
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
                handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            // 表示事件曾经使用过，用于事件优化
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        // 设置为null避免IE中循环引用导致的内存泄露
        elem = null;
    },

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {

        var j, origCount, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );

        if ( !elemData || !(events = elemData.events) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = ( types || &quot;&quot; ).match( core_rnotwhite ) || [&quot;&quot;];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                }
                continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[2] &amp;&amp; new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; );

            // Remove matching events
            origCount = j = handlers.length;
            while ( j-- ) {
                handleObj = handlers[ j ];

                if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
                    ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
                    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
                    ( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
                    handlers.splice( j, 1 );

                    if ( handleObj.selector ) {
                        handlers.delegateCount--;
                    }
                    if ( special.remove ) {
                        special.remove.call( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( origCount &amp;&amp; !handlers.length ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it&apos;s no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            delete elemData.handle;
            data_priv.remove( elem, &quot;events&quot; );
        }
    },

    trigger: function( event, data, elem, onlyHandlers ) {

        var i, cur, tmp, bubbleType, ontype, handle, special,
            eventPath = [ elem || document ],
            type = core_hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
            namespaces = core_hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split(&quot;.&quot;) : [];

        cur = tmp = elem = elem || document;

        // Don&apos;t do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        // focus/blur morphs to focusin/out; ensure we&apos;re not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
        }

        if ( type.indexOf(&quot;.&quot;) &gt;= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(&quot;.&quot;);
            type = namespaces.shift();
            namespaces.sort();
        }
        ontype = type.indexOf(&quot;:&quot;) &lt; 0 &amp;&amp; &quot;on&quot; + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[ jQuery.expando ] ?
            event :
            new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );

        // Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(&quot;.&quot;);
        event.namespace_re = event.namespace ?
            new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; ) :
            null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
            event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            if ( !rfocusMorph.test( bubbleType + type ) ) {
                cur = cur.parentNode;
            }
            for ( ; cur; cur = cur.parentNode ) {
                eventPath.push( cur );
                tmp = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( tmp === (elem.ownerDocument || document) ) {
                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            }
        }

        // Fire handlers on the event path
        i = 0;
        while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {

            event.type = i &gt; 1 ?
                bubbleType :
                special.bindType || type;

            // jQuery handler
            handle = ( data_priv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, &quot;handle&quot; );
            if ( handle ) {
                handle.apply( cur, data );
            }

            // Native handler
            handle = ontype &amp;&amp; cur[ ontype ];
            if ( handle &amp;&amp; jQuery.acceptData( cur ) &amp;&amp; handle.apply &amp;&amp; handle.apply( cur, data ) === false ) {
                event.preventDefault();
            }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;
                jQuery.acceptData( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Don&apos;t do default actions on window, that&apos;s where global variables be (#6170)
                if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {

                    // Don&apos;t re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ ontype ];

                    if ( tmp ) {
                        elem[ ontype ] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    elem[ type ]();
                    jQuery.event.triggered = undefined;

                    if ( tmp ) {
                        elem[ ontype ] = tmp;
                    }
                }
            }
        }

        return event.result;
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event );

        var i, j, ret, matched, handleObj,
            handlerQueue = [],
            args = core_slice.call( arguments ),
            handlers = ( data_priv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
            return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {
            event.currentTarget = matched.elem;

            j = 0;
            while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {

                // Triggered event must either 1) have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                    event.handleObj = handleObj;
                    event.data = handleObj.data;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                    if ( ret !== undefined ) {
                        if ( (event.result = ret) === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
        }

        return event.result;
    },

    handlers: function( event, handlers ) {
        var i, matches, sel, handleObj,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;

        // Find delegate handlers
        // Black-hole SVG &lt;use&gt; instance trees (#13180)
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== &quot;click&quot;) ) {

            for ( ; cur !== this; cur = cur.parentNode || this ) {

                // Don&apos;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur.disabled !== true || event.type !== &quot;click&quot; ) {
                    matches = [];
                    for ( i = 0; i &lt; delegateCount; i++ ) {
                        handleObj = handlers[ i ];

                        // Don&apos;t conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + &quot; &quot;;

                        if ( matches[ sel ] === undefined ) {
                            matches[ sel ] = handleObj.needsContext ?
                                jQuery( sel, this ).index( cur ) &gt;= 0 :
                                jQuery.find( sel, this, null, [ cur ] ).length;
                        }
                        if ( matches[ sel ] ) {
                            matches.push( handleObj );
                        }
                    }
                    if ( matches.length ) {
                        handlerQueue.push({ elem: cur, handlers: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( delegateCount &lt; handlers.length ) {
            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
        }

        return handlerQueue;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),

    fixHooks: {},

    keyHooks: {
        props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;),
        filter: function( event, original ) {

            // Add which for key events
            if ( event.which == null ) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: &quot;button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;),
        filter: function( event, original ) {
            var eventDoc, doc, body,
                button = original.button;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null &amp;&amp; original.clientX != null ) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
                event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don&apos;t use it
            if ( !event.which &amp;&amp; button !== undefined ) {
                event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },
  //对事件进行包裹
    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;//表明事件已经被包裹
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop, copy,
            type = event.type,
            //保存原始event
            originalEvent = event,
            fixHook = this.fixHooks[ type ];

        if ( !fixHook ) {
            this.fixHooks[ type ] = fixHook =
                rmouseEvent.test( type ) ? this.mouseHooks :
                rkeyEvent.test( type ) ? this.keyHooks :
                {};
        }
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        //克隆一个事件
        event = new jQuery.Event( originalEvent );

        i = copy.length;
        while ( i-- ) {
            prop = copy[ i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Support: Cordova 2.5 (WebKit) (#13255)
        // All events should have a target; Cordova deviceready doesn&apos;t
        if ( !event.target ) {
            event.target = document;
        }

        // Support: Safari 6.0+, Chrome &lt; 28
        // Target should not be a text node (#504, #13143)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
        },
        focus: {
            // Fire native event if possible so blur/focus sequence is correct
            trigger: function() {
                if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
                    this.focus();
                    return false;
                }
            },
            delegateType: &quot;focusin&quot;
        },
        blur: {
            trigger: function() {
                if ( this === safeActiveElement() &amp;&amp; this.blur ) {
                    this.blur();
                    return false;
                }
            },
            delegateType: &quot;focusout&quot;
        },
        click: {
            // For checkbox, fire native event so checked state will be right
            trigger: function() {
                if ( this.type === &quot;checkbox&quot; &amp;&amp; this.click &amp;&amp; jQuery.nodeName( this, &quot;input&quot; ) ) {
                    this.click();
                    return false;
                }
            },

            // For cross-browser consistency, don&apos;t fire native .click() on links
            _default: function( event ) {
                return jQuery.nodeName( event.target, &quot;a&quot; );
            }
        },

        beforeunload: {
            postDispatch: function( event ) {

                // Support: Firefox 20+
                // Firefox doesn&apos;t alert if the returnValue field is not set.
                if ( event.result !== undefined ) {
                    event.originalEvent.returnValue = event.result;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor&apos;s stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
            new jQuery.Event(),
            event,
            {
                type: type,
                isSimulated: true,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery.event.trigger( e, null, elem );
        } else {
            jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
            event.preventDefault();
        }
    }
};

jQuery.removeEvent = function( elem, type, handle ) {
    if ( elem.removeEventListener ) {
        elem.removeEventListener( type, handle, false );
    }
};

jQuery.Event = function( src, props ) {
    // Allow instantiation without the &apos;new&apos; keyword
    if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
    }

    // Event object
    if ( src &amp;&amp; src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = ( src.defaultPrevented ||
            src.getPreventDefault &amp;&amp; src.getPreventDefault() ) ? returnTrue : returnFalse;

    // Event type
    } else {
        this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery.extend( this, props );
    }

    // Create a timestamp if incoming event doesn&apos;t have one
    this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function() {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;

        if ( e &amp;&amp; e.preventDefault ) {
            e.preventDefault();
        }
    },
    stopPropagation: function() {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;

        if ( e &amp;&amp; e.stopPropagation ) {
            e.stopPropagation();
        }
    },
    stopImmediatePropagation: function() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
    }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
    mouseenter: &quot;mouseover&quot;,
    mouseleave: &quot;mouseout&quot;
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( this, arguments );
                event.type = fix;
            }
            return ret;
        }
    };
});

// Create &quot;bubbling&quot; focus and blur events
// Support: Firefox, Chrome, Safari
if ( !jQuery.support.focusinBubbles ) {
    jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

        // Attach a single capturing handler while someone wants focusin/focusout
        var attaches = 0,
            handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

        jQuery.event.special[ fix ] = {
            setup: function() {
                if ( attaches++ === 0 ) {
                    document.addEventListener( orig, handler, true );
                }
            },
            teardown: function() {
                if ( --attaches === 0 ) {
                    document.removeEventListener( orig, handler, true );
                }
            }
        };
    });
}

jQuery.fn.extend({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === &quot;object&quot; ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== &quot;string&quot; ) {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this.on( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == null &amp;&amp; fn == null ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === &quot;string&quot; ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            return this;
        }
        if ( typeof types === &quot;object&quot; ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this.off( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === false || typeof selector === &quot;function&quot; ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === false ) {
            fn = returnFalse;
        }
        return this.each(function() {
            jQuery.event.remove( this, types, fn, selector );
        });
    },

    trigger: function( type, data ) {
        return this.each(function() {
            jQuery.event.trigger( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        var elem = this[0];
        if ( elem ) {
            return jQuery.event.trigger( type, data, elem, true );
        }
    }
});
var isSimple = /^.[^:#\[\.,]*$/,
    rparentsprev = /^(?:parents|prev(?:Until|All))/,
    rneedsContext = jQuery.expr.match.needsContext,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

jQuery.fn.extend({
    find: function( selector ) {
        var i,
            ret = [],
            self = this,
            len = self.length;

        if ( typeof selector !== &quot;string&quot; ) {
            return this.pushStack( jQuery( selector ).filter(function() {
                for ( i = 0; i &lt; len; i++ ) {
                    if ( jQuery.contains( self[ i ], this ) ) {
                        return true;
                    }
                }
            }) );
        }

        for ( i = 0; i &lt; len; i++ ) {
            jQuery.find( selector, self[ i ], ret );
        }

        // Needed because $( selector, context ) becomes $( context ).find( selector )
        ret = this.pushStack( len &gt; 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + &quot; &quot; + selector : selector;
        return ret;
    },

    has: function( target ) {
        var targets = jQuery( target, this ),
            l = targets.length;

        return this.filter(function() {
            var i = 0;
            for ( ; i &lt; l; i++ ) {
                if ( jQuery.contains( this, targets[i] ) ) {
                    return true;
                }
            }
        });
    },

    not: function( selector ) {
        return this.pushStack( winnow(this, selector || [], true) );
    },

    filter: function( selector ) {
        return this.pushStack( winnow(this, selector || [], false) );
    },

    is: function( selector ) {
        return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&apos;t return true for a doc with two &quot;p&quot;.
            typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
                jQuery( selector ) :
                selector || [],
            false
        ).length;
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            pos = ( rneedsContext.test( selectors ) || typeof selectors !== &quot;string&quot; ) ?
                jQuery( selectors, context || this.context ) :
                0;

        for ( ; i &lt; l; i++ ) {
            for ( cur = this[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {
                // Always skip document fragments
                if ( cur.nodeType &lt; 11 &amp;&amp; (pos ?
                    pos.index(cur) &gt; -1 :

                    // Don&apos;t pass non-elements to Sizzle
                    cur.nodeType === 1 &amp;&amp;
                        jQuery.find.matchesSelector(cur, selectors)) ) {

                    cur = matched.push( cur );
                    break;
                }
            }
        }

        return this.pushStack( matched.length &gt; 1 ? jQuery.unique( matched ) : matched );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === &quot;string&quot; ) {
            return core_indexOf.call( jQuery( elem ), this[ 0 ] );
        }

        // Locate the position of the desired element
        return core_indexOf.call( this,

            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[ 0 ] : elem
        );
    },

    add: function( selector, context ) {
        var set = typeof selector === &quot;string&quot; ?
                jQuery( selector, context ) :
                jQuery.makeArray( selector &amp;&amp; selector.nodeType ? [ selector ] : selector ),
            all = jQuery.merge( this.get(), set );

        return this.pushStack( jQuery.unique(all) );
    },

    addBack: function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    }
});

function sibling( cur, dir ) {
    while ( (cur = cur[dir]) &amp;&amp; cur.nodeType !== 1 ) {}

    return cur;
}

jQuery.each({
    parent: function( elem ) {
        var parent = elem.parentNode;
        return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
        return jQuery.dir( elem, &quot;parentNode&quot; );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;parentNode&quot;, until );
    },
    next: function( elem ) {
        return sibling( elem, &quot;nextSibling&quot; );
    },
    prev: function( elem ) {
        return sibling( elem, &quot;previousSibling&quot; );
    },
    nextAll: function( elem ) {
        return jQuery.dir( elem, &quot;nextSibling&quot; );
    },
    prevAll: function( elem ) {
        return jQuery.dir( elem, &quot;previousSibling&quot; );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;nextSibling&quot;, until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;previousSibling&quot;, until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
    },
    contents: function( elem ) {
        return elem.contentDocument || jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
        var matched = jQuery.map( this, fn, until );

        if ( name.slice( -5 ) !== &quot;Until&quot; ) {
            selector = until;
        }

        if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
            matched = jQuery.filter( selector, matched );
        }

        if ( this.length &gt; 1 ) {
            // Remove duplicates
            if ( !guaranteedUnique[ name ] ) {
                jQuery.unique( matched );
            }

            // Reverse order for parents* and prev-derivatives
            if ( rparentsprev.test( name ) ) {
                matched.reverse();
            }
        }

        return this.pushStack( matched );
    };
});

jQuery.extend({
    filter: function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
            expr = &quot;:not(&quot; + expr + &quot;)&quot;;
        }

        return elems.length === 1 &amp;&amp; elem.nodeType === 1 ?
            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
            }));
    },

    dir: function( elem, dir, until ) {
        var matched = [],
            truncate = until !== undefined;

        while ( (elem = elem[ dir ]) &amp;&amp; elem.nodeType !== 9 ) {
            if ( elem.nodeType === 1 ) {
                if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
                    break;
                }
                matched.push( elem );
            }
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var matched = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
                matched.push( n );
            }
        }

        return matched;
    }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
    if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep( elements, function( elem, i ) {
            /* jshint -W018 */
            return !!qualifier.call( elem, i, elem ) !== not;
        });

    }

    if ( qualifier.nodeType ) {
        return jQuery.grep( elements, function( elem ) {
            return ( elem === qualifier ) !== not;
        });

    }

    if ( typeof qualifier === &quot;string&quot; ) {
        if ( isSimple.test( qualifier ) ) {
            return jQuery.filter( qualifier, elements, not );
        }

        qualifier = jQuery.filter( qualifier, elements );
    }

    return jQuery.grep( elements, function( elem ) {
        return ( core_indexOf.call( qualifier, elem ) &gt;= 0 ) !== not;
    });
}
var rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
    rtagName = /&lt;([\w:]+)/,
    rhtml = /&lt;|&amp;#?\w+;/,
    rnoInnerhtml = /&lt;(?:script|style|link)/i,
    manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
    // checked=&quot;checked&quot; or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,

    // We have to close these tags to support XHTML (#13200)
    wrapMap = {

        // Support: IE 9
        option: [ 1, &quot;&lt;select multiple=&apos;multiple&apos;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],

        thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
        col: [ 2, &quot;&lt;table&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
        tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
        td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],

        _default: [ 0, &quot;&quot;, &quot;&quot; ]
    };

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
    text: function( value ) {
        return jQuery.access( this, function( value ) {
            return value === undefined ?
                jQuery.text( this ) :
                this.empty().append( ( this[ 0 ] &amp;&amp; this[ 0 ].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
    },

    append: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.appendChild( elem );
            }
        });
    },

    prepend: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.insertBefore( elem, target.firstChild );
            }
        });
    },

    before: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this );
            }
        });
    },

    after: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this.nextSibling );
            }
        });
    },

    // keepData is for internal use only--do not document
    remove: function( selector, keepData ) {
        var elem,
            elems = selector ? jQuery.filter( selector, this ) : this,
            i = 0;

        for ( ; (elem = elems[i]) != null; i++ ) {
            if ( !keepData &amp;&amp; elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem ) );
            }

            if ( elem.parentNode ) {
                if ( keepData &amp;&amp; jQuery.contains( elem.ownerDocument, elem ) ) {
                    setGlobalEval( getAll( elem, &quot;script&quot; ) );
                }
                elem.parentNode.removeChild( elem );
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            if ( elem.nodeType === 1 ) {

                // Prevent memory leaks
                jQuery.cleanData( getAll( elem, false ) );

                // Remove any remaining nodes
                elem.textContent = &quot;&quot;;
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map( function () {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return jQuery.access( this, function( value ) {
            var elem = this[ 0 ] || {},
                i = 0,
                l = this.length;

            if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {
                return elem.innerHTML;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
                !wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {

                value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );

                try {
                    for ( ; i &lt; l; i++ ) {
                        elem = this[ i ] || {};

                        // Remove element nodes and prevent memory leaks
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                            elem.innerHTML = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch( e ) {}
            }

            if ( elem ) {
                this.empty().append( value );
            }
        }, null, value, arguments.length );
    },

    replaceWith: function() {
        var
            // Snapshot the DOM in case .domManip sweeps something relevant into its fragment
            args = jQuery.map( this, function( elem ) {
                return [ elem.nextSibling, elem.parentNode ];
            }),
            i = 0;

        // Make the changes, replacing each context element with the new content
        this.domManip( arguments, function( elem ) {
            var next = args[ i++ ],
                parent = args[ i++ ];

            if ( parent ) {
                // Don&apos;t use the snapshot next if it has moved (#13810)
                if ( next &amp;&amp; next.parentNode !== parent ) {
                    next = this.nextSibling;
                }
                jQuery( this ).remove();
                parent.insertBefore( elem, next );
            }
        // Allow new content to include elements from the context set
        }, true );

        // Force removal if there was no new content (e.g., from empty arguments)
        return i ? this : this.remove();
    },

    detach: function( selector ) {
        return this.remove( selector, true );
    },

    domManip: function( args, callback, allowIntersection ) {

        // Flatten any nested arrays
        args = core_concat.apply( [], args );

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = this.length,
            set = this,
            iNoClone = l - 1,//是否为克隆节点
            value = args[ 0 ],
            isFunction = jQuery.isFunction( value );

        // We can&apos;t cloneNode fragments that contain checked, in WebKit
        if ( isFunction || !( l &lt;= 1 || typeof value !== &quot;string&quot; || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
            return this.each(function( index ) {
                var self = set.eq( index );
                if ( isFunction ) {
                    args[ 0 ] = value.call( this, index, self.html() );
                }
                self.domManip( args, callback, allowIntersection );
            });
        }

        if ( l ) {
            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection &amp;&amp; this );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            if ( first ) {
                scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i &lt; l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {
                            // Support: QtWebKit
                            // jQuery.merge because core_push.apply(_, arraylike) throws
                            jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
                        }
                    }

                    callback.call( this[ i ], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i &lt; hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
                            !data_priv.access( node, &quot;globalEval&quot; ) &amp;&amp; jQuery.contains( doc, node ) ) {

                            if ( node.src ) {
                                // Hope ajax is available...
                                jQuery._evalUrl( node.src );
                            } else {
                                jQuery.globalEval( node.textContent.replace( rcleanScript, &quot;&quot; ) );
                            }
                        }
                    }
                }
            }
        }

        return this;
    }
});

jQuery.each({
    appendTo: &quot;append&quot;,
    prependTo: &quot;prepend&quot;,
    insertBefore: &quot;before&quot;,
    insertAfter: &quot;after&quot;,
    replaceAll: &quot;replaceWith&quot;
}, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
        var elems,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1,
            i = 0;

        for ( ; i &lt;= last; i++ ) {
            elems = i === last ? this : this.clone( true );
            jQuery( insert[ i ] )[ original ]( elems );

            // Support: QtWebKit
            // .get() because core_push.apply(_, arraylike) throws
            core_push.apply( ret, elems.get() );
        }

        return this.pushStack( ret );
    };
});

jQuery.extend({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var i, l, srcElements, destElements,
            clone = elem.cloneNode( true ),
            inPage = jQuery.contains( elem.ownerDocument, elem );

        // Support: IE &gt;= 9
        // Fix Cloning issues
        if ( !jQuery.support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp; !jQuery.isXMLDoc( elem ) ) {

            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
            destElements = getAll( clone );
            srcElements = getAll( elem );

            for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
                fixInput( srcElements[ i ], destElements[ i ] );
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            if ( deepDataAndEvents ) {
                srcElements = srcElements || getAll( elem );
                destElements = destElements || getAll( clone );

                for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
                    cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                }
            } else {
                cloneCopyEvent( elem, clone );
            }
        }

        // Preserve script evaluation history
        destElements = getAll( clone, &quot;script&quot; );
        if ( destElements.length &gt; 0 ) {
            setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
        }

        // Return the cloned set
        return clone;
    },

    buildFragment: function( elems, context, scripts, selection ) {
        var elem, tmp, tag, wrap, contains, j,
            i = 0,
            l = elems.length,
            fragment = context.createDocumentFragment(),
            nodes = [];

        for ( ; i &lt; l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === &quot;object&quot; ) {
                    // Support: QtWebKit
                    // jQuery.merge because core_push.apply(_, arraylike) throws
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild( context.createElement(&quot;div&quot;) );

                    // Deserialize a standard representation
                    tag = ( rtagName.exec( elem ) || [&quot;&quot;, &quot;&quot;] )[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; ) + wrap[ 2 ];

                    // Descend through wrappers to the right content
                    j = wrap[ 0 ];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Support: QtWebKit
                    // jQuery.merge because core_push.apply(_, arraylike) throws
                    jQuery.merge( nodes, tmp.childNodes );

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Fixes #12346
                    // Support: Webkit, IE
                    tmp.textContent = &quot;&quot;;
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = &quot;&quot;;

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

            // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ( selection &amp;&amp; jQuery.inArray( elem, selection ) !== -1 ) {
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( fragment.appendChild( elem ), &quot;script&quot; );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( (elem = tmp[ j++ ]) ) {
                    if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        return fragment;
    },

    cleanData: function( elems ) {
        var data, elem, events, type, key, j,
            special = jQuery.event.special,
            i = 0;

        for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
            if ( Data.accepts( elem ) ) {
                key = elem[ data_priv.expando ];

                if ( key &amp;&amp; (data = data_priv.cache[ key ]) ) {
                    events = Object.keys( data.events || {} );
                    if ( events.length ) {
                        for ( j = 0; (type = events[j]) !== undefined; j++ ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove&apos;s overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
                    }
                    if ( data_priv.cache[ key ] ) {
                        // Discard any remaining `private` data
                        delete data_priv.cache[ key ];
                    }
                }
            }
            // Discard any remaining `user` data
            delete data_user.cache[ elem[ data_user.expando ] ];
        }
    },

    _evalUrl: function( url ) {
        return jQuery.ajax({
            url: url,
            type: &quot;GET&quot;,
            dataType: &quot;script&quot;,
            async: false,
            global: false,
            &quot;throws&quot;: true
        });
    }
});

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
    return jQuery.nodeName( elem, &quot;table&quot; ) &amp;&amp;
        jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, &quot;tr&quot; ) ?

        elem.getElementsByTagName(&quot;tbody&quot;)[0] ||
            elem.appendChild( elem.ownerDocument.createElement(&quot;tbody&quot;) ) :
        elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
    elem.type = (elem.getAttribute(&quot;type&quot;) !== null) + &quot;/&quot; + elem.type;
    return elem;
}
function restoreScript( elem ) {
    var match = rscriptTypeMasked.exec( elem.type );

    if ( match ) {
        elem.type = match[ 1 ];
    } else {
        elem.removeAttribute(&quot;type&quot;);
    }

    return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
    var l = elems.length,
        i = 0;

    for ( ; i &lt; l; i++ ) {
        data_priv.set(
            elems[ i ], &quot;globalEval&quot;, !refElements || data_priv.get( refElements[ i ], &quot;globalEval&quot; )
        );
    }
}

function cloneCopyEvent( src, dest ) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    if ( dest.nodeType !== 1 ) {
        return;
    }

    // 1. Copy private data: events, handlers, etc.
    if ( data_priv.hasData( src ) ) {
        pdataOld = data_priv.access( src );
        pdataCur = data_priv.set( dest, pdataOld );
        events = pdataOld.events;

        if ( events ) {
            delete pdataCur.handle;
            pdataCur.events = {};

            for ( type in events ) {
                for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
                    jQuery.event.add( dest, type, events[ type ][ i ] );
                }
            }
        }
    }

    // 2. Copy user data
    if ( data_user.hasData( src ) ) {
        udataOld = data_user.access( src );
        udataCur = jQuery.extend( {}, udataOld );

        data_user.set( dest, udataCur );
    }
}


function getAll( context, tag ) { //这是一个jQuery内部使用的函数，非常有用。他获取context中（自身以及后代节点）标签名为tag的节点集合。他使用context.getElementsByTagName或context.querySelectorAll来获取，当实在是没有获取到值的时候通过context.childNodes来获取conten的儿子节点中标签为tag的节点。
    var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || &quot;*&quot; ) :
            context.querySelectorAll ? context.querySelectorAll( tag || &quot;*&quot; ) :
            [];

    return tag === undefined || tag &amp;&amp; jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], ret ) :
        ret;
}

// Support: IE &gt;= 9
function fixInput( src, dest ) {
    var nodeName = dest.nodeName.toLowerCase();

    // Fails to persist the checked state of a cloned checkbox or radio button.
    if ( nodeName === &quot;input&quot; &amp;&amp; manipulation_rcheckableType.test( src.type ) ) {
        dest.checked = src.checked;

    // Fails to return the selected option to the default selected state when cloning options
    } else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
        dest.defaultValue = src.defaultValue;
    }
}
jQuery.fn.extend({
    wrapAll: function( html ) {
        var wrap;

        if ( jQuery.isFunction( html ) ) {
            return this.each(function( i ) {
                jQuery( this ).wrapAll( html.call(this, i) );
            });
        }

        if ( this[ 0 ] ) {

            // The elements to wrap the target around
            wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

            if ( this[ 0 ].parentNode ) {
                wrap.insertBefore( this[ 0 ] );
            }

            wrap.map(function() {
                var elem = this;

                while ( elem.firstElementChild ) {
                    elem = elem.firstElementChild;
                }

                return elem;
            }).append( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function( i ) {
                jQuery( this ).wrapInner( html.call(this, i) );
            });
        }

        return this.each(function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents.length ) {
                contents.wrapAll( html );

            } else {
                self.append( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function( i ) {
            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent().each(function() {
            if ( !jQuery.nodeName( this, &quot;body&quot; ) ) {
                jQuery( this ).replaceWith( this.childNodes );
            }
        }).end();
    }
});
var curCSS, iframe,
    // swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rmargin = /^margin/,
    rnumsplit = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(.*)$&quot;, &quot;i&quot; ),
    rnumnonpx = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; ),
    rrelNum = new RegExp( &quot;^([+-])=(&quot; + core_pnum + &quot;)&quot;, &quot;i&quot; ),
    elemdisplay = { BODY: &quot;block&quot; },

    cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
    cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    },

    cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ],
    cssPrefixes = [ &quot;Webkit&quot;, &quot;O&quot;, &quot;Moz&quot;, &quot;ms&quot; ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function isHidden( elem, el ) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot; || !jQuery.contains( elem.ownerDocument, elem );
}

// NOTE: we&apos;ve included the &quot;window&quot; in window.getComputedStyle
// because jsdom on node.js will break without it.
function getStyles( elem ) {
    return window.getComputedStyle( elem, null );
}

function showHide( elements, show ) {
    var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

    for ( ; index &lt; length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }

        values[ index ] = data_priv.get( elem, &quot;olddisplay&quot; );
        display = elem.style.display;
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] &amp;&amp; display === &quot;none&quot; ) {
                elem.style.display = &quot;&quot;;
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem.style.display === &quot;&quot; &amp;&amp; isHidden( elem ) ) {
                values[ index ] = data_priv.access( elem, &quot;olddisplay&quot;, css_defaultDisplay(elem.nodeName) );
            }
        } else {

            if ( !values[ index ] ) {
                hidden = isHidden( elem );

                if ( display &amp;&amp; display !== &quot;none&quot; || !hidden ) {
                    data_priv.set( elem, &quot;olddisplay&quot;, hidden ? display : jQuery.css(elem, &quot;display&quot;) );
                }
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index &lt; length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        if ( !show || elem.style.display === &quot;none&quot; || elem.style.display === &quot;&quot; ) {
            elem.style.display = show ? values[ index ] || &quot;&quot; : &quot;none&quot;;
        }
    }

    return elements;
}

jQuery.fn.extend({
    css: function( name, value ) {
        return jQuery.access( this, function( elem, name, value ) {
            var styles, len,
                map = {},
                i = 0;

            if ( jQuery.isArray( name ) ) {
                styles = getStyles( elem );
                len = name.length;

                for ( ; i &lt; len; i++ ) {
                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                }

                return map;
            }

            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length &gt; 1 );
    },
    show: function() {
        return showHide( this, true );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state ) {
        if ( typeof state === &quot;boolean&quot; ) {
            return state ? this.show() : this.hide();
        }

        return this.each(function() {
            if ( isHidden( this ) ) {
                jQuery( this ).show();
            } else {
                jQuery( this ).hide();
            }
        });
    }
});

jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, &quot;opacity&quot; );
                    return ret === &quot;&quot; ? &quot;1&quot; : ret;
                }
            }
        }
    },

    // Don&apos;t automatically add &quot;px&quot; to these possibly-unitless properties
    cssNumber: {
        &quot;columnCount&quot;: true,
        &quot;fillOpacity&quot;: true,
        &quot;fontWeight&quot;: true,
        &quot;lineHeight&quot;: true,
        &quot;opacity&quot;: true,
        &quot;order&quot;: true,
        &quot;orphans&quot;: true,
        &quot;widows&quot;: true,
        &quot;zIndex&quot;: true,
        &quot;zoom&quot;: true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        &quot;float&quot;: &quot;cssFloat&quot;
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don&apos;t set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
        }

        // Make sure that we&apos;re working with the right name
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we&apos;re setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === &quot;string&quot; &amp;&amp; (ret = rrelNum.exec( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                // Fixes bug #9237
                type = &quot;number&quot;;
            }

            // Make sure that NaN and null values aren&apos;t set. See: #7116
            if ( value == null || type === &quot;number&quot; &amp;&amp; isNaN( value ) ) {
                return;
            }

            // If a number was passed in, add &apos;px&apos; to the (except for certain CSS properties)
            if ( type === &quot;number&quot; &amp;&amp; !jQuery.cssNumber[ origName ] ) {
                value += &quot;px&quot;;
            }

            // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
            // but it would mean to define eight (for every problematic property) identical functions
            if ( !jQuery.support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf(&quot;background&quot;) === 0 ) {
                style[ name ] = &quot;inherit&quot;;
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !(&quot;set&quot; in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
                style[ name ] = value;
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, extra, styles ) {
        var val, num, hooks,
            origName = jQuery.camelCase( name );

        // Make sure that we&apos;re working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
            val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name, styles );
        }

        //convert &quot;normal&quot; to computed value
        if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( extra === &quot;&quot; || extra ) {
            num = parseFloat( val );
            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
    }
});

curCSS = function( elem, name, _computed ) {
    var width, minWidth, maxWidth,
        computed = _computed || getStyles( elem ),

        // Support: IE9
        // getPropertyValue is only needed for .css(&apos;filter&apos;) in IE9, see #12537
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
        style = elem.style;

    if ( computed ) {

        if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
            ret = jQuery.style( elem, name );
        }

        // Support: Safari 5.1
        // A tribute to the &quot;awesome hack by Dean Edwards&quot;
        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
        if ( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {

            // Remember the original values
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;

            // Put in the new values to get a computed value out
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;

            // Revert the changed values
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
        }
    }

    return ret;
};


function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
        // Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || &quot;px&quot; ) :
        value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    var i = extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === &quot;width&quot; ? 1 : 0,

        val = 0;

    for ( ; i &lt; 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === &quot;margin&quot; ) {
            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === &quot;content&quot; ) {
                val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
            }

            // at this point, extra isn&apos;t border nor margin, so remove border
            if ( extra !== &quot;margin&quot; ) {
                val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
            }
        } else {
            // at this point, extra isn&apos;t content, so add padding
            val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );

            // at this point, extra isn&apos;t content nor padding, so add border
            if ( extra !== &quot;padding&quot; ) {
                val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val &lt;= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, styles );
        if ( val &lt; 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox &amp;&amp; ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

        // Normalize &quot;&quot;, auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
            valueIsBorderBox,
            styles
        )
    ) + &quot;px&quot;;
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
    var doc = document,
        display = elemdisplay[ nodeName ];

    if ( !display ) {
        display = actualDisplay( nodeName, doc );

        // If the simple way fails, read from inside an iframe
        if ( display === &quot;none&quot; || !display ) {
            // Use the already-created iframe if possible
            iframe = ( iframe ||
                jQuery(&quot;&lt;iframe frameborder=&apos;0&apos; width=&apos;0&apos; height=&apos;0&apos;/&gt;&quot;)
                .css( &quot;cssText&quot;, &quot;display:block !important&quot; )
            ).appendTo( doc.documentElement );

            // Always write a new HTML skeleton so Webkit and Firefox don&apos;t choke on reuse
            doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
            doc.write(&quot;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&quot;);
            doc.close();

            display = actualDisplay( nodeName, doc );
            iframe.detach();
        }

        // Store the correct default display
        elemdisplay[ nodeName ] = display;
    }

    return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
    var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
        display = jQuery.css( elem[0], &quot;display&quot; );
    elem.remove();
    return display;
}

jQuery.each([ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
    jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                return elem.offsetWidth === 0 &amp;&amp; rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) ?
                    jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    }) :
                    getWidthOrHeight( elem, name, extra );
            }
        },

        set: function( elem, value, extra ) {
            var styles = extra &amp;&amp; getStyles( elem );
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
                    styles
                ) : 0
            );
        }
    };
});

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
    // Support: Android 2.3
    if ( !jQuery.support.reliableMarginRight ) {
        jQuery.cssHooks.marginRight = {
            get: function( elem, computed ) {
                if ( computed ) {
                    // Support: Android 2.3
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; },
                        curCSS, [ elem, &quot;marginRight&quot; ] );
                }
            }
        };
    }

    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    if ( !jQuery.support.pixelPosition &amp;&amp; jQuery.fn.position ) {
        jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
            jQuery.cssHooks[ prop ] = {
                get: function( elem, computed ) {
                    if ( computed ) {
                        computed = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx.test( computed ) ?
                            jQuery( elem ).position()[ prop ] + &quot;px&quot; :
                            computed;
                    }
                }
            };
        });
    }

});

if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
    jQuery.expr.filters.hidden = function( elem ) {
        // Support: Opera &lt;= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth &lt;= 0 &amp;&amp; elem.offsetHeight &lt;= 0;
    };

    jQuery.expr.filters.visible = function( elem ) {
        return !jQuery.expr.filters.hidden( elem );
    };
}

// These hooks are used by animate to expand properties
jQuery.each({
    margin: &quot;&quot;,
    padding: &quot;&quot;,
    border: &quot;Width&quot;
}, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
            var i = 0,
                expanded = {},

                // assumes a single number if not a string
                parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ];

            for ( ; i &lt; 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
});
var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
    serialize: function() {
        return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
        return this.map(function(){
            // Can add propHook for &quot;elements&quot; to filter or add form elements
            var elements = jQuery.prop( this, &quot;elements&quot; );
            return elements ? jQuery.makeArray( elements ) : this;
        })
        .filter(function(){
            var type = this.type;
            // Use .is(&quot;:disabled&quot;) so that fieldset[disabled] works
            return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
                rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
                ( this.checked || !manipulation_rcheckableType.test( type ) );
        })
        .map(function( i, elem ){
            var val = jQuery( this ).val();

            return val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, function( val ){
                        return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
                    }) :
                    { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
        }).get();
    }
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction( value ) ? value() : ( value == null ? &quot;&quot; : value );
            s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery &lt;= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
            add( this.name, this.value );
        });

    } else {
        // If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; );
};

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // Item is non-scalar (array or object), encode its numeric index.
                buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add );
            }
        });

    } else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}
jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
    &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
    &quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length &gt; 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});

jQuery.fn.extend({
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn );
    }
});
var
    // Document location
    ajaxLocParts,
    ajaxLocation,//location.href

    ajax_nonce = jQuery.now(),

    ajax_rquery = /\?/,
    rhash = /#.*$/,
    rts = /([?&amp;])_=[^&amp;]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

    // Keep a copy of the old load method
    _load = jQuery.fn.load,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol &quot;*&quot; can be used
     * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol &quot;*&quot; can be used
     * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
     */

    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = &quot;*/&quot;.concat(&quot;*&quot;);

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location.href;
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement( &quot;a&quot; );
    ajaxLocation.href = &quot;&quot;;
    ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
//前置过滤器和请求分发器，这2个方法是通过私有方法addToPrefiltersOrTransports通过curry手段构造的，分别是保持了prefilters与transports的引用
//可见ajaxPrefilter就维持了addToPrefiltersOrTransports返回函数的引用了，这种就是闭包的手法了，这也是JS的开发人员都需要掌握的好处就是合并多个参数，当然因为维持引用代价就是一点点性能消耗
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to &quot;*&quot;
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== &quot;string&quot; ) {
            func = dataTypeExpression;
            dataTypeExpression = &quot;*&quot;;
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

        if ( jQuery.isFunction( func ) ) {
            // For each dataType in the dataTypeExpression
            while ( (dataType = dataTypes[i++]) ) {
                // Prepend if requested
                if ( dataType[0] === &quot;+&quot; ) {
                    dataType = dataType.slice( 1 ) || &quot;*&quot;;
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                // Otherwise append
                } else {
                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                }
            }
        }
    };
}

// Base inspection function for prefilters and transports
/*
ajaxPrefilter与ajaxTransport都是通过inspectPrefiltersOrTransports构建器
prefilters中的前置过滤器在请求发送之前、设置请求参数的过程中被调用，调用prefilters的是函数inspectPrefiltersOrTransports；
巧妙的是，transports中的请求分发器在大部分参数设置完成后，也通过函数inspectPrefiltersOrTransports取到与请求类型匹配的请求分发器：
*/
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

    var inspected = {},
        seekingTransport = ( structure === transports );

    function inspect( dataType ) {
        var selected;
        inspected[ dataType ] = true;
        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            if( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
                options.dataTypes.unshift( dataTypeOrTransport );
                inspect( dataTypeOrTransport );
                return false;
            } else if ( seekingTransport ) {
                return !( selected = dataTypeOrTransport );
            }
        });
        return selected;
    }

    return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
}

// A special extend for ajax options
// that takes &quot;flat&quot; options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var key, deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery.extend( true, target, deep );
    }

    return target;
}

jQuery.fn.load = function( url, params, callback ) {
    if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) {
        return _load.apply( this, arguments );
    }

    var selector, type, response,
        self = this,
        off = url.indexOf(&quot; &quot;);

    if ( off &gt;= 0 ) {
        selector = url.slice( off );
        url = url.slice( 0, off );
    }

    // If it&apos;s a function
    if ( jQuery.isFunction( params ) ) {

        // We assume that it&apos;s the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
        type = &quot;POST&quot;;
    }

    // If we have elements to modify, make the request
    if ( self.length &gt; 0 ) {
        jQuery.ajax({
            url: url,

            // if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used
            type: type,
            dataType: &quot;html&quot;,
            data: params
        }).done(function( responseText ) {

            // Save response for use in complete callback
            response = arguments;

            self.html( selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE &apos;Permission Denied&apos; errors
                jQuery(&quot;&lt;div&gt;&quot;).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                // Otherwise use the full result
                responseText );

        }).complete( callback &amp;&amp; function( jqXHR, status ) {
            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        });
    }

    return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ &quot;ajaxStart&quot;, &quot;ajaxStop&quot;, &quot;ajaxComplete&quot;, &quot;ajaxError&quot;, &quot;ajaxSuccess&quot;, &quot;ajaxSend&quot; ], function( i, type ){
    jQuery.fn[ type ] = function( fn ){
        return this.on( type, fn );
    };
});

//异步队列deferred   回调队列Callbacks
jQuery.extend({

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
        url: ajaxLocation,
        type: &quot;GET&quot;,
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: true,//设置是否触发ajaxStart/ajaxStop/ajaxComplete等事件，false是不触发
        processData: true,
        async: true,
        contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            &quot;*&quot;: allTypes,
            text: &quot;text/plain&quot;,
            html: &quot;text/html&quot;,
            xml: &quot;application/xml, text/xml&quot;,
            json: &quot;application/json, text/javascript&quot;
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: &quot;responseXML&quot;,
            text: &quot;responseText&quot;,
            json: &quot;responseJSON&quot;
        },

        // Data converters
        // Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
        converters: {

            // Convert anything to text
            &quot;* text&quot;: String,

            // Text to html (true = no transformation)
            &quot;text html&quot;: true,

            // Evaluate text as a json expression
            &quot;text json&quot;: jQuery.parseJSON,

            // Parse text as xml
            &quot;text xml&quot;: jQuery.parseXML
        },

        // For options that shouldn&apos;t be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn&apos;t be
        // deep extended (see ajaxExtend)
        flatOptions: {
            url: true,
            context: true
        }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        return settings ?

            // Building a settings object
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
            ajaxExtend( jQuery.ajaxSettings, target );
    },

//预处理的类型取决于由更加接近默认的Content-Type响应，但可以明确使用dataType选项进行设置。如果提供了dataType选项， 响应的Content-Type头信息将被忽略。
    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === &quot;object&quot; ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var transport,
            // URL without anti-cache param
            cacheURL,
            // Response headers
            responseHeadersString,
            responseHeaders,
            // timeout handle
            timeoutTimer,
            // Cross-domain detection vars
            parts,
            // To know if global events are to be dispatched
            fireGlobals,
            // Loop variable
            i,
            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks(&quot;once memory&quot;),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = &quot;canceled&quot;,
            // Fake xhr
            //XMLHttpRequest（jqXHR）对象
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while ( (match = rheaders.exec( responseHeadersString )) ) {
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key.toLowerCase() ];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function( name, value ) {
                    var lname = name.toLowerCase();
                    if ( !state ) {
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Overrides response content-type header  // 重写相应头content-type
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks 对应状态的回调函数集
                statusCode: function( map ) {
                    var code;
                    if ( map ) {
                        if ( state &lt; 2 ) {
                            for ( code in map ) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            }
                        } else {
                            // Execute the appropriate callbacks // 无论Deferred成功还是失败都执行当前状态回调
                            jqXHR.always( map[ jqXHR.status ] );
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    var finalText = statusText || strAbort;
                    if ( transport ) {
                        transport.abort( finalText );
                    }
                    done( 0, finalText );
                    return this;
                }
            };

        // Attach deferreds
        deferred.promise( jqXHR ).complete = completeDeferred.add;
        //注意这里喔
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (prefilters might expect it)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available
        s.url = ( ( url || s.url || ajaxLocation ) + &quot;&quot; ).replace( rhash, &quot;&quot; )
            .replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; );

        // Alias method option to type as per ticket #12004
        s.type = options.method || options.type || s.method || s.type;

        // Extract dataTypes list
        s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().match( core_rnotwhite ) || [&quot;&quot;];

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s.crossDomain == null ) {
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &amp;&amp;
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) )
            );
        }

        // Convert data if not already a string
        if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
            s.data = jQuery.param( s.data, s.traditional );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s.global;

        // Watch for a new set of requests
        if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
            jQuery.event.trigger(&quot;ajaxStart&quot;);
        }

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test( s.type );

        // Save the URL in case we&apos;re toying with the If-Modified-Since
        // and/or If-None-Match header later on
        cacheURL = s.url;

        // More options handling for requests with no content
        if ( !s.hasContent ) {

            // If data is available, append data to url
            if ( s.data ) {
                cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data );
                // #9682: remove data so that it&apos;s not used in an eventual retry
                delete s.data;
            }

            // Add anti-cache in url if needed
            if ( s.cache === false ) {
                s.url = rts.test( cacheURL ) ?

                    // If there is already a &apos;_&apos; parameter, set its value
                    cacheURL.replace( rts, &quot;$1_=&quot; + ajax_nonce++ ) :

                    // Otherwise add one to the end
                    cacheURL + ( ajax_rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ajax_nonce++;
            }
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
            if ( jQuery.lastModified[ cacheURL ] ) {
                jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
            }
            if ( jQuery.etag[ cacheURL ] ) {
                jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
            }
        }

        // Set the correct header, if data is being sent
        if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
            &quot;Accept&quot;,
            s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
                s.accepts[ &quot;*&quot; ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
            // Abort if not done already and return
            return jqXHR.abort();
        }

        // aborting is no longer a cancellation
        strAbort = &quot;abort&quot;;

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, &quot;No Transport&quot; );
        } else {
            jqXHR.readyState = 1;

            // Send global event
            if ( fireGlobals ) {
                globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
            }
            // Timeout
            if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
                timeoutTimer = setTimeout(function() {
                    jqXHR.abort(&quot;timeout&quot;);
                }, s.timeout );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch ( e ) {
                // Propagate exception as error if not done
                if ( state &lt; 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        // Callback for when everything is done
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is &quot;done&quot; now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || &quot;&quot;;

            // Set readyState
            jqXHR.readyState = status &gt; 0 ? 4 : 0;

            // Determine if successful
            isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // Convert no matter what (that way responseXXX fields are always set)
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            // If successful, handle type chaining
            if ( isSuccess ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s.ifModified ) {
                    modified = jqXHR.getResponseHeader(&quot;Last-Modified&quot;);
                    if ( modified ) {
                        jQuery.lastModified[ cacheURL ] = modified;
                    }
                    modified = jqXHR.getResponseHeader(&quot;etag&quot;);
                    if ( modified ) {
                        jQuery.etag[ cacheURL ] = modified;
                    }
                }

                // if no content
                if ( status === 204 || s.type === &quot;HEAD&quot; ) {
                    statusText = &quot;nocontent&quot;;

                // if not modified
                } else if ( status === 304 ) {
                    statusText = &quot;notmodified&quot;;

                // If we have data, let&apos;s convert it
                } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( status || !statusText ) {
                    statusText = &quot;error&quot;;
                    if ( status &lt; 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;

            // Success/Error
            if ( isSuccess ) {
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
                    [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery.active ) ) {
                    jQuery.event.trigger(&quot;ajaxStop&quot;);
                }
            }
        }

        return jqXHR;
    },

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, &quot;json&quot; );
    },

    getScript: function( url, callback ) {//动态异步加载js文件
        /*
        $.getScript(&apos;a.js&apos;,functio()）{}；)
        function(){}是回调函数
        */
        return jQuery.get( url, undefined, callback, &quot;script&quot; );
    }
});

jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        });
    };
});

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

    var ct, type, finalDataType, firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while( dataTypes[ 0 ] === &quot;*&quot; ) {
        dataTypes.shift();
        if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader(&quot;Content-Type&quot;);
        }
    }

    // Check if we&apos;re dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
                dataTypes.unshift( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
 //类型转换器
function ajaxConvert( s, response, jqXHR, isSuccess ) {
    var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while ( current ) {

        if ( s.responseFields[ current ] ) {
            jqXHR[ s.responseFields[ current ] ] = response;
        }

        // Apply the dataFilter if provided
        if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        prev = current;
        current = dataTypes.shift();

        if ( current ) {

        // There&apos;s only work to do if current dataType is non-auto
            if ( current === &quot;*&quot; ) {

                current = prev;

            // Convert response if prev dataType is non-auto and differs from current
            } else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2.split( &quot; &quot; );
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
                                converters[ &quot;* &quot; + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === true ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== true ) {
                                    current = tmp[ 0 ];
                                    dataTypes.unshift( tmp[ 1 ] );
                                }
                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== true ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv &amp;&amp; s[ &quot;throws&quot; ] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: &quot;parsererror&quot;, error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current };
                        }
                    }
                }
            }
        }
    }

    return { state: &quot;success&quot;, data: response };
}
// Install script dataType
jQuery.ajaxSetup({
    accepts: {
        script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
    },
    contents: {
        script: /(?:java|ecma)script/
    },
    converters: {
        &quot;text script&quot;: function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});

// Handle cache&apos;s special case and crossDomain
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
    if ( s.cache === undefined ) {
        s.cache = false;
    }
    if ( s.crossDomain ) {
        s.type = &quot;GET&quot;;
    }
});

// Bind script tag hack transport
//请求分发器  请求分发器顾名思义发送请求，那么底层的ajax发送请求是通过send方法
jQuery.ajaxTransport( &quot;script&quot;, function( s ) {
    // This transport only deals with cross domain requests
    if ( s.crossDomain ) {
        var script, callback;
        return {
            send: function( _, complete ) {
                script = jQuery(&quot;&lt;script&gt;&quot;).prop({
                    async: true,
                    charset: s.scriptCharset,
                    src: s.url
                }).on(
                    &quot;load error&quot;,
                    callback = function( evt ) {
                        script.remove();
                        callback = null;
                        if ( evt ) {
                            complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
                        }
                    }
                );
                document.head.appendChild( script[ 0 ] );
            },
            abort: function() {
                if ( callback ) {
                    callback();
                }
            }
        };
    }
});
var oldCallbacks = [],
    rjsonp = /(=)\?(?=&amp;|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
    jsonp: &quot;callback&quot;,
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( ajax_nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
//前置过滤器
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
            &quot;url&quot; :
            typeof s.data === &quot;string&quot; &amp;&amp; !( s.contentType || &quot;&quot; ).indexOf(&quot;application/x-www-form-urlencoded&quot;) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
        );

    // Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
    if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {

        // Get callback name, remembering preexisting value associated with it
        //jsonpCallback为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。从jQuery 1.5开始，你也可以使用一个函数作为该参数设置，在这种情况下，该函数的返回值就是jsonpCallback的结果。
        //在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，比如{jsonp:&apos;onJsonPLoad&apos;}会导致将&quot;onJsonPLoad=?&quot;传给服务器。在jQuery 1.5，，设置jsonp选项为false，阻止了jQuery从加入&quot;?callback&quot;字符串的URL或试图使用&quot;=?&quot;转换。在这种情况下，你也应该明确设置jsonpCallback设置。例如, { jsonp: false, jsonpCallback: &quot;callbackName&quot; }、
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

        // Insert callback into url or form data
        if ( jsonProp ) {
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
        } else if ( s.jsonp !== false ) {
            s.url += ( ajax_rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters[&quot;script json&quot;] = function() {
            if ( !responseContainer ) {
                jQuery.error( callbackName + &quot; was not called&quot; );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = &quot;json&quot;;

        // Install callback
        overwritten = window[ callbackName ];
        window[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
            // Restore preexisting value
            window[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn&apos;t screw things around
                s.jsonpCallback = originalSettings.jsonpCallback;

                // save the callback name for future use
                oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return &quot;script&quot;;
    }
});
jQuery.ajaxSettings.xhr = function() {
    try {
        return new XMLHttpRequest();
    } catch( e ) {}
};

var xhrSupported = jQuery.ajaxSettings.xhr(),
    xhrSuccessStatus = {
        // file protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE9
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    },
    // Support: IE9
    // We need to keep track of outbound xhr and abort them manually
    // because IE is not smart enough to do it all by itself
    xhrId = 0,
    xhrCallbacks = {};

if ( window.ActiveXObject ) {
    jQuery( window ).on( &quot;unload&quot;, function() {
        for( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]();
        }
        xhrCallbacks = undefined;
    });
}
//withCredentials是ajax跨域的一个属性xhrSupported就是xmlhttpRequest对象，，cors就是判断ajax是否支持跨域
jQuery.support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
jQuery.support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
    var callback;
    // Cross domain only allowed if supported through XMLHttpRequest
    if ( jQuery.support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
        return {
            send: function( headers, complete ) {
                var i, id,
                    xhr = options.xhr();
                xhr.open( options.type, options.url, options.async, options.username, options.password );
                // Apply custom fields if provided
                if ( options.xhrFields ) {
                    for ( i in options.xhrFields ) {
                        xhr[ i ] = options.xhrFields[ i ];
                    }
                }
                // Override mime type if needed
                if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
                    xhr.overrideMimeType( options.mimeType );
                }
                // X-Requested-With header
                // For cross-domain requests, seeing as conditions for a preflight are
                // akin to a jigsaw puzzle, we simply never set it to be sure.
                // (it can always be set on a per-request basis or even using ajaxSetup)
                // For same-domain requests, won&apos;t change header if already provided.
                if ( !options.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) {
                    headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;
                }
                // Set headers
                for ( i in headers ) {
                    xhr.setRequestHeader( i, headers[ i ] );
                }
                // Callback
                callback = function( type ) {
                    return function() {
                        if ( callback ) {
                            delete xhrCallbacks[ id ];
                            callback = xhr.onload = xhr.onerror = null;
                            if ( type === &quot;abort&quot; ) {
                                xhr.abort();
                            } else if ( type === &quot;error&quot; ) {
                                complete(
                                    // file protocol always yields status 0, assume 404
                                    xhr.status || 404,
                                    xhr.statusText
                                );
                            } else {
                                complete(
                                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                                    xhr.statusText,
                                    // Support: IE9
                                    // #11426: When requesting binary data, IE9 will throw an exception
                                    // on any attempt to access responseText
                                    typeof xhr.responseText === &quot;string&quot; ? {
                                        text: xhr.responseText
                                    } : undefined,
                                    xhr.getAllResponseHeaders()
                                );
                            }
                        }
                    };
                };
                // Listen to events
                xhr.onload = callback();
                xhr.onerror = callback(&quot;error&quot;);
                // Create the abort callback
                callback = xhrCallbacks[( id = xhrId++ )] = callback(&quot;abort&quot;);
                // Do send the request
                // This may raise an exception which is actually
                // handled in jQuery.ajax (so no try/catch here)
                xhr.send( options.hasContent &amp;&amp; options.data || null );
            },
            abort: function() {
                if ( callback ) {
                    callback();
                }
            }
        };
    }
});


var fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( &quot;^(?:([+-])=|)(&quot; + core_pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        &quot;*&quot;: [function( prop, value ) {
            var tween = this.createTween( prop, value ),
                target = tween.cur(),
                parts = rfxnum.exec( value ),
                unit = parts &amp;&amp; parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),

                // Starting value computation is required for potential unit mismatches
                start = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +target ) &amp;&amp;
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                scale = 1,
                maxIterations = 20;

            if ( start &amp;&amp; start[ 3 ] !== unit ) {
                // Trust units reported by jQuery.css
                unit = unit || start[ 3 ];

                // Make sure we update the tween properties later on
                parts = parts || [];

                // Iteratively approximate from a nonzero starting point
                start = +target || 1;

                do {
                    // If previous iteration zeroed out, double until we get *something*
                    // Use a string for doubling factor so we don&apos;t accidentally see scale as unchanged below
                    scale = scale || &quot;.5&quot;;

                    // Adjust and apply
                    start = start / scale;
                    jQuery.style( tween.elem, prop, start + unit );

                // Update scale, tolerating zero or NaN from tween.cur()
                // And breaking the loop if scale is unchanged or perfect, or if we&apos;ve just had enough
                } while ( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations );
            }

            // Update tween properties
            if ( parts ) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we&apos;re doing a relative animation
                tween.end = parts[ 1 ] ?
                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                    +parts[ 2 ];
            }

            return tween;
        }]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    });
    return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
    var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ &quot;*&quot; ] ),
        index = 0,
        length = collection.length;
    for ( ; index &lt; length; index++ ) {
        if ( (tween = collection[ index ].call( animation, prop, value )) ) {

            // we&apos;re done with this property
            return tween;
        }
    }
}

function Animation( elem, properties, options ) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
            // don&apos;t match elem in the :animated selector
            delete tick.elem;
        }),
        tick = function() {
            if ( stopped ) {
                return false;
            }
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                // archaic crash bug won&apos;t allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for ( ; index &lt; length ; index++ ) {
                animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            if ( percent &lt; 1 &amp;&amp; length ) {
                return remaining;
            } else {
                deferred.resolveWith( elem, [ animation ] );
                return false;
            }
        },
        animation = deferred.promise({
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end ) {
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0;
                if ( stopped ) {
                    return this;
                }
                stopped = true;
                for ( ; index &lt; length ; index++ ) {
                    animation.tweens[ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                } else {
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    for ( ; index &lt; length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
            return result;
        }
    }

    jQuery.map( props, createTween, animation );

    if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
    }

    jQuery.fx.timer(
        jQuery.extend( tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })
    );

    // attach callbacks from options
    return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing &apos;index&apos; from above because we have the correct &quot;name&quot;
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

jQuery.Animation = jQuery.extend( Animation, {

    tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
            callback = props;
            props = [ &quot;*&quot; ];
        } else {
            props = props.split(&quot; &quot;);
        }

        var prop,
            index = 0,
            length = props.length;

        for ( ; index &lt; length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters.unshift( callback );
        } else {
            animationPrefilters.push( callback );
        }
    }
});

function defaultPrefilter( elem, props, opts ) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType &amp;&amp; isHidden( elem ),
        dataShow = data_priv.get( elem, &quot;fxshow&quot; );

    // handle queue: false promises
    if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
        if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
                if ( !hooks.unqueued ) {
                    oldfire();
                }
            };
        }
        hooks.unqueued++;

        anim.always(function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim.always(function() {
                hooks.unqueued--;
                if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
                    hooks.empty.fire();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem.nodeType === 1 &amp;&amp; ( &quot;height&quot; in props || &quot;width&quot; in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE9-10 do not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        if ( jQuery.css( elem, &quot;display&quot; ) === &quot;inline&quot; &amp;&amp;
                jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {

            style.display = &quot;inline-block&quot;;
        }
    }

    if ( opts.overflow ) {
        style.overflow = &quot;hidden&quot;;
        anim.always(function() {
            style.overflow = opts.overflow[ 0 ];
            style.overflowX = opts.overflow[ 1 ];
            style.overflowY = opts.overflow[ 2 ];
        });
    }


    // show/hide pass
    for ( prop in props ) {
        value = props[ prop ];
        if ( rfxtypes.exec( value ) ) {
            delete props[ prop ];
            toggle = toggle || value === &quot;toggle&quot;;
            if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {

                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
                    hidden = true;
                } else {
                    continue;
                }
            }
            orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
        }
    }

    if ( !jQuery.isEmptyObject( orig ) ) {
        if ( dataShow ) {
            if ( &quot;hidden&quot; in dataShow ) {
                hidden = dataShow.hidden;
            }
        } else {
            dataShow = data_priv.access( elem, &quot;fxshow&quot;, {} );
        }

        // store state if its toggle - enables .stop().toggle() to &quot;reverse&quot;
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }
        if ( hidden ) {
            jQuery( elem ).show();
        } else {
            anim.done(function() {
                jQuery( elem ).hide();
            });
        }
        anim.done(function() {
            var prop;

            data_priv.remove( elem, &quot;fxshow&quot; );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        });
        for ( prop in orig ) {
            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween.start;
                if ( hidden ) {
                    tween.end = tween.start;
                    tween.start = prop === &quot;width&quot; || prop === &quot;height&quot; ? 1 : 0;
                }
            }
        }
    }
}

function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || &quot;swing&quot;;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
    },
    cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks &amp;&amp; hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        } else {
            this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks &amp;&amp; hooks.set ) {
            hooks.set( this );
        } else {
            Tween.propHooks._default.set( this );
        }
        return this;
    }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween.elem[ tween.prop ] != null &amp;&amp;
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                return tween.elem[ tween.prop ];
            }

            // passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as &quot;10px&quot; are parsed to Float.
            // complex values such as &quot;rotate(1rad)&quot; are returned as is.
            result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );
            // Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
            return !result || result === &quot;auto&quot; ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery.fx.step[ tween.prop ] ) {
                jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    }
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
        if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
};

jQuery.each([ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === &quot;boolean&quot; ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
    };
});

jQuery.fn.extend({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( &quot;opacity&quot;, 0 ).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won&apos;t be lost
                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                // Empty animations, or finishing resolves immediately
                if ( empty || data_priv.get( this, &quot;finish&quot; ) ) {
                    anim.stop( true );
                }
            };
            doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
        };

        if ( typeof type !== &quot;string&quot; ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue &amp;&amp; type !== false ) {
            this.queue( type || &quot;fx&quot;, [] );
        }

        return this.each(function() {
            var dequeue = true,
                index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
                timers = jQuery.timers,
                data = data_priv.get( this );

            if ( index ) {
                if ( data[ index ] &amp;&amp; data[ index ].stop ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this &amp;&amp; (type == null || timers[ index ].queue === type) ) {
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = false;
                    timers.splice( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn&apos;t forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery.dequeue( this, type );
            }
        });
    },
    finish: function( type ) {
        if ( type !== false ) {
            type = type || &quot;fx&quot;;
        }
        return this.each(function() {
            var index,
                data = data_priv.get( this ),
                queue = data[ type + &quot;queue&quot; ],
                hooks = data[ type + &quot;queueHooks&quot; ],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;

            // enable finishing flag on private data
            data.finish = true;

            // empty the queue first
            jQuery.queue( this, type, [] );

            if ( hooks &amp;&amp; hooks.stop ) {
                hooks.stop.call( this, true );
            }

            // look for any active animations, and finish them
            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
                    timers[ index ].anim.stop( true );
                    timers.splice( index, 1 );
                }
            }

            // look for any animations in the old queue and finish them
            for ( index = 0; index &lt; length; index++ ) {
                if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
                    queue[ index ].finish.call( this );
                }
            }

            // turn off finishing flag
            delete data.finish;
        });
    }
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don&apos;t include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth? 1 : 0;
    for( ; i &lt; 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
    }

    if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
    }

    return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
    slideDown: genFx(&quot;show&quot;),
    slideUp: genFx(&quot;hide&quot;),
    slideToggle: genFx(&quot;toggle&quot;),
    fadeIn: { opacity: &quot;show&quot; },
    fadeOut: { opacity: &quot;hide&quot; },
    fadeToggle: { opacity: &quot;toggle&quot; }
}, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return this.animate( props, speed, easing, callback );
    };
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn &amp;&amp; easing ||
            jQuery.isFunction( speed ) &amp;&amp; speed,
        duration: speed,
        easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &quot;number&quot; ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
    if ( opt.queue == null || opt.queue === true ) {
        opt.queue = &quot;fx&quot;;
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
            opt.old.call( this );
        }

        if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
        }
    };

    return opt;
};

jQuery.easing = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p*Math.PI ) / 2;
    }
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i &lt; timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() &amp;&amp; timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
    if ( timer() &amp;&amp; jQuery.timers.push( timer ) ) {
        jQuery.fx.start();
    }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
    if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};

jQuery.fx.stop = function() {
    clearInterval( timerId );
    timerId = null;
};

jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};

// Back Compat &lt;1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep(jQuery.timers, function( fn ) {
            return elem === fn.elem;
        }).length;
    };
}
jQuery.fn.offset = function( options ) {
    if ( arguments.length ) {
        return options === undefined ?
            this :
            this.each(function( i ) {
                jQuery.offset.setOffset( this, options, i );
            });
    }

    var docElem, win,
        elem = this[ 0 ],
        box = { top: 0, left: 0 },
        doc = elem &amp;&amp; elem.ownerDocument;

    if ( !doc ) {
        return;
    }

    docElem = doc.documentElement;

    // Make sure it&apos;s not a disconnected DOM node
    if ( !jQuery.contains( docElem, elem ) ) {
        return box;
    }

    // If we don&apos;t have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)
    if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
        box = elem.getBoundingClientRect();
    }
    win = getWindow( doc );
    return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
    };
};

jQuery.offset = {

    setOffset: function( elem, options, i ) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, &quot;position&quot; ),
            curElem = jQuery( elem ),
            props = {};

        // Set position first, in-case top/left are set even on static elem
        if ( position === &quot;static&quot; ) {
            elem.style.position = &quot;relative&quot;;
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, &quot;top&quot; );
        curCSSLeft = jQuery.css( elem, &quot;left&quot; );
        calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp; ( curCSSTop + curCSSLeft ).indexOf(&quot;auto&quot;) &gt; -1;

        // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;

        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
            options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( &quot;using&quot; in options ) {
            options.using.call( elem, props );

        } else {
            curElem.css( props );
        }
    }
};


jQuery.fn.extend({

    position: function() {
        if ( !this[ 0 ] ) {
            return;
        }

        var offsetParent, offset,
            elem = this[ 0 ],
            parentOffset = { top: 0, left: 0 };

        // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it&apos;s only offset parent
        if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {
            // We assume that getBoundingClientRect is available when computed position is fixed
            offset = elem.getBoundingClientRect();

        } else {
            // Get *real* offsetParent
            offsetParent = this.offsetParent();

            // Get correct offsets
            offset = this.offset();
            if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) {
                parentOffset = offsetParent.offset();
            }

            // Add offsetParent borders
            parentOffset.top += jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true );
            parentOffset.left += jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true );
        }

        // Subtract parent offsets and element margins
        return {
            top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
            left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
        };
    },

    offsetParent: function() {
        return this.map(function() {
            var offsetParent = this.offsetParent || docElem;

            while ( offsetParent &amp;&amp; ( !jQuery.nodeName( offsetParent, &quot;html&quot; ) &amp;&amp; jQuery.css( offsetParent, &quot;position&quot;) === &quot;static&quot; ) ) {
                offsetParent = offsetParent.offsetParent;
            }

            return offsetParent || docElem;
        });
    }
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot;}, function( method, prop ) {
    var top = &quot;pageYOffset&quot; === prop;

    jQuery.fn[ method ] = function( val ) {
        return jQuery.access( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? win[ prop ] : elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : window.pageXOffset,
                    top ? val : window.pageYOffset
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments.length, null );
    };
});

function getWindow( elem ) {
    return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
    jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
                extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );

            return jQuery.access( this, function( elem, type, value ) {
                var doc;

                if ( jQuery.isWindow( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn&apos;t a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem.document.documentElement[ &quot;client&quot; + name ];
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    doc = elem.documentElement;

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                    // whichever is greatest
                    return Math.max(
                        elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
                        elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
                        doc[ &quot;client&quot; + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css( elem, type, extra ) :

                    // Set width or height on the element
                    jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, null );
        };
    });
});
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
    return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
if ( typeof module === &quot;object&quot; &amp;&amp; module &amp;&amp; typeof module.exports === &quot;object&quot; ) {
    // Expose jQuery as module.exports in loaders that implement the Node
    // module pattern (including browserify). Do not create the global, since
    // the user will be storing it themselves locally, and globals are frowned
    // upon in the Node module world.
    module.exports = jQuery;
} else {
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
        define( &quot;jquery&quot;, [], function () { return jQuery; } );
    }
}

// If there is a window object, that at least has a document property,
// define jQuery and $ identifiers
if ( typeof window === &quot;object&quot; &amp;&amp; typeof window.document === &quot;object&quot; ) {
    //对外提供了接口，这样匿名函数中的jQuery就可以找到了，因为挂载到了window下
    window.jQuery = window.$ = jQuery;
}

})( window );
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/jquery-2.0.3源码及解析/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jquery源码总结(中) " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/jquery源码总结(中) /">jquery源码总结(中)</a>
    </h1>
  

        <a href="/2016/08/18/jquery源码总结(中) /" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="问题：初始化与链式调用基础"><a href="#问题：初始化与链式调用基础" class="headerlink" title="问题：初始化与链式调用基础"></a>问题：初始化与链式调用基础</h5><p>答：jQuery之所以能够链式调用在于每次调用返回来jQuery本身。实现关键代码如下。</p>
<pre><code>jQuery = function(selector,context){
  return new jQuery.fn.init(selector,context,rootjQuery);
}
...
rootjQuery = jQuery(document);
...
jQuery.fn = jQuery.prototype = {
　　constructor: jQuery,
　　init: function(selector,context,rootjQuery){
　　　　...
　　　　return this;
　　　　...
  }
}
...
jQuery.fn.init.prototype = jQuery.fn;
...
window.jQuery = window.$ = jQuery;
</code></pre><p>由上面的分析可知jQuery.fn.init.prototype = jQuery.fn目的就是将jQuery.fn上的所有属性都挂在jQuery实例$(…)上，使得实例拥有很多jQuery.fn上定义的函数。比如jQuery.fn.extend函数，实例就可以直接使用：$(…).extend({“name”: “chua”})。<br>由于每次都是一个新的实例new jQuery.fn.init(selector,context,rootjQuery)，所以各个实例是独立的。而jQuery全局的属性直接挂在jQuery上，比如jQuery.extend,这个和jQuery.fn.extend不一样了，因为jQuery.extend是全局的，比如jQuery.extend（{“test”: “chua”}）你可以随时通过jQuery.test就把值给取出来了，而jQuery实例则需要保证同一个实例的情况下才能取到值。比如var ps = $(“p”).extend({“test”: “chua”}),通过ps.test能够取到值，但是你使用$(“p”).test是取不到的。因为你使用$(…)又新建了一个实例。<br>至于jQuery的链式调用很好理解，源码初始化的时候返回了jQuery对象本身：</p>
<pre><code>init: function(selector,context,rootjQuery){
　　...
　　return this;
}    
</code></pre><h6 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h6><pre><code>return new jQuery.fn.init( selector, context, rootjQuery );
</code></pre><p>$(‘#casper’)跟new $(‘#casper’)是一样的。个人觉得这里设计的原因，一个减少写一堆new的麻烦，同时也可以避免开发者不小心遗漏了new导致的诡异bug。当然，不好的地方是，代码有点绕，这也算是jQuery源码的其中一个特点。</p>
<pre><code>jQuery.fn = jQuery.prototype
</code></pre><p>没什么好讲，jQuery.prototype为jQuery的原型方法，这里用jQuery.fn来代替jQuery.prototype，只是为了少写几个字符，平常写插件时就是在这东东上面做修改.    </p>
<pre><code>jQuery.fn.init.prototype = jQuery.fn
</code></pre><p>很好很绕的一个语句，上面说了$(’#casper‘)返回的其实是个jQuery.fn.init对象。所以，这里的作用，是让jQuery.fn上的方法都成为jQuery.fn.init对象的原型方法。 这个语句应该让很多刚接触jQuery源码的人感到困惑，包括我（=_=），可以试jQuery.fn.init.prototype.init.prototype.init…，如果你愿意可以一直写下去。</p>
<h5 id="问题：jQuery-type函数用来识别对象类型"><a href="#问题：jQuery-type函数用来识别对象类型" class="headerlink" title="问题：jQuery.type函数用来识别对象类型"></a>问题：jQuery.type函数用来识别对象类型</h5><p>答：JavaScript也自带有一个typeof运算符，可以确定数据的类型。不过，对于绝大多数对象而言，typeof运算符都返回”object”，无法区分具体的类型。jQuery.type()可以更加精确地确定JS内置对象的类型。</p>
<pre><code>jQuery.type( undefined ); // &quot;undefined&quot;
jQuery.type( null ); // &quot;null&quot;

jQuery.type( true ); // &quot;boolean&quot;
jQuery.type( new Boolean(true) ); // &quot;boolean&quot;

jQuery.type( 3 ); // &quot;number&quot;
jQuery.type( new Number(3) ); // &quot;number&quot;

jQuery.type( &quot;test&quot; ); // &quot;string&quot;
jQuery.type( new String(&quot;test&quot;) ); // &quot;string&quot;

jQuery.type( function(){} ); // &quot;function&quot;
jQuery.type( new Function() ); // &quot;function&quot;

jQuery.type( [] ); // &quot;array&quot;
jQuery.type( new Array() ); // &quot;array&quot;

jQuery.type( new Date() ); // &quot;date&quot;

jQuery.type( new Error() ); // &quot;error&quot; // jQuery 1.9 新增支持

jQuery.type( /test/ ); // &quot;regexp&quot;
jQuery.type( new RegExp(&quot;\\d+&quot;) ); // &quot;regexp&quot;

/* 除上述类型的对象外，其他对象一律返回&quot;object&quot; */

jQuery.type( {} ); // &quot;object&quot;
function User() { }
jQuery.type( new User() ); // &quot;object&quot;    
</code></pre><h5 id="问题：ownerDocument和-documentElement的区别"><a href="#问题：ownerDocument和-documentElement的区别" class="headerlink" title="问题：ownerDocument和 documentElement的区别"></a>问题：ownerDocument和 documentElement的区别</h5><p>ownerDocument是Node对象的一个属性，返回的是某个元素的根节点文档对象：即document对象；documentElement是Document对象的属性，返回的是文档根节点对于HTML文档来说，documentElement是<html>标签对应的Element对象，ownerDocument是document对象.接下开始正题。</html></p>
<h5 id="问题：jQuery-noConflict-函数详解"><a href="#问题：jQuery-noConflict-函数详解" class="headerlink" title="问题：jQuery.noConflict() 函数详解"></a>问题：jQuery.noConflict() 函数详解</h5><p>jQuery.noConflict()函数用于让出jQuery库对变量$(和变量jQuery)的控制权。</p>
<p>一般情况下，在jQuery库中，变量$是变量jQuery的别名，它们之间是等价的，例如jQuery(“p”)和$(“p”)是等价的。由于变量$只有一个字符，并且特点鲜明，因此我们更加习惯使用$来操作jQuery库。</p>
<p>不过，其他JS库也可能使用变量$来进行操作，例如Prototype库。这个时候两个库可能会由于变量$的控制权问题而发生冲突。</p>
<p>此时，你可以使用该函数让出jQuery库对变量$的控制权，将该变量交给上一个实现它的JS库，之后我们只能使用变量jQuery来操作jQuery库。</p>
<p>此外，使用该函数，还可以同时让出变量$和变量jQuery的控制权，从而实现多个不同版本的jQuery库共存(详情见下面的示例说明)。</p>
<p>该函数属于全局jQuery对象。</p>
<p>语法</p>
<p>静态函数jQuery.noConflict()的语法如下：</p>
<pre><code>jQuery.noConflict( [ removeAll ] )
</code></pre><p>参数</p>
<p> 参数                                   描述<br>removeAll    可选/Boolean类型是否彻底移交对变量jQuery的控制权，默认为false。<br>如果省略了参数removeAll或该参数不为true，则表示只让出对变量$的控制权；如果该参数为true，则表示同时让出变量$和jQuery的控制权。</p>
<p>返回值</p>
<p>jQuery.noConflict()函数的返回值是jQuery类型，返回变量jQuery的引用。</p>
<p>示例&amp;说明</p>
<p>以下是加载Prototype和jQuery库的情况：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;prototype.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 让出对变量$的控制权
jQuery.noConflict();

// 使用jQuery进行DOM操作
jQuery(&quot;#uname&quot;).hide();

// 使用Prototype进行DOM操作
$(&quot;myDiv&quot;).setStyle( {color: &quot;#ffffff&quot;} );
&lt;/script&gt;    
</code></pre><p>(以下代码请自行复制到演示页面运行，注意不要同时执行，请分别执行)</p>
<p>此外，我们还可以使用其他自定义的变量名来操作jQuery：</p>
<pre><code>// 让出对变量$的控制权，并将jQuery赋给新的别名j
var j = jQuery.noConflict();

// 基于jQuery进行DOM操作(使用变量j)
j(&quot;#uname&quot;).hide();

// 基于Prototype进行DOM操作
$(&quot;myDiv&quot;).setStyle( {color: &quot;#ffffff&quot;} );
</code></pre><p>即使是多个库共存，我们也可以在jQuery.ready()的回调函数或其他自定义函数中将局部变量$作为jQuery的别名使用：</p>
<pre><code>// 让出jQuery库对变量$的控制权
jQuery.noConflict();

jQuery(document).ready(function($){
    // 使用局部变量$进行jQuery操作
    $(&quot;p&quot;).css(&quot;color&quot;, &quot;&quot;);    
});


(function($){
    // 使用局部变量$进行jQuery操作
    $(&quot;ul li&quot;).addClass(&quot;item&quot;);    
}(jQuery));    
</code></pre><p>如果要实现两个版本的jQuery库共存，我们可以编写如下代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.4.2.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 让出jQuery-1.11.1对变量$和变量jQuery的控制权
var j = jQuery.noConflict( true );

document.writeln( j.fn.jquery ); // 1.11.1

document.writeln( $.fn.jquery ); // 1.4.2
document.writeln( jQuery.fn.jquery ); // 1.4.2

/*
 * 如果前面的jQuery.noConflict()没有传入参数true，
 * 也就是说只让出变量$的控制，则$表示1.4.2，jQuery表示1.11.1
 * 此时，jQuery.fn.jquery为1.11.1
 */
 &lt;/script&gt;    
</code></pre><p>三个版本的jQuery库共存，对应的jQuery示例代码如下：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.4.2.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 让出jQuery-1.11.1对变量$和变量jQuery的控制权，使用变量j来控制
var j = jQuery.noConflict( true );

// 让出jQuery-1.8.3对变量$的控制权
jQuery.noConflict();

document.writeln( j.fn.jquery ); // 1.11.1
document.writeln( jQuery.fn.jquery ); // 1.8.3
document.writeln( $.fn.jquery ); // 1.4.2
&lt;/script&gt;     
</code></pre><p>注意：多个可能存在全局变量重名冲突的JS库，变量的实际控制权一般取决于JS库的加载顺序。以上面三个版本的jQuery库的示例代码为例，后加载的jQuery库的变量覆盖了之前版本的变量，因此每次让出变量的控制权，控制权就会交给上一个JS库。</p>
<h5 id="问题：jQuery-Data源码-数据缓存系统"><a href="#问题：jQuery-Data源码-数据缓存系统" class="headerlink" title="问题：jQuery.Data源码(数据缓存系统)"></a>问题：jQuery.Data源码(数据缓存系统)</h5><p>对于DOM元素，通过分配一个唯一的关联id把DOM元素和该DOM元素的数据缓存对象关联起来，关联id被附加到以jQuery.expando的值命名的属性上，数据存储在全局缓存对象jQuery.cache中。在读取、设置、移除数据时，将通过关联id从全局缓存对象jQuery.cache中找到关联的数据缓存对象，然后在数据缓存对象上执行读取、设置、移除操作。</p>
<p>对于Javascript对象，数据则直接存储在该Javascript对象的属性jQuery.expando上。在读取、设置、移除数据时，实际上是对Javascript对象的数据缓存对象执行读取、设置、移除操作。</p>
<p>为了避免jQuery内部使用的数据和用户自定义的数据发生冲突，数据缓存模块把内部数据存储在数据缓存对象上，把自定义数据存储在数据缓存对象的属性data上。<br><a href="http://www.cnblogs.com/yaoyinglong/p/5738979.html" target="_blank" rel="external">http://www.cnblogs.com/yaoyinglong/p/5738979.html</a><br>P.S. 下图解释了Data的处理机制（也阐明了不会出现内存泄露问题的原因）</p>
<div align="center"><br><img src="/images/jquery/5_1.png"><br></div><br>相同的元素是只分配同一个id的，如下图<br><div align="center"><br><img src="/images/jquery/5_3.png"><br><img src="/images/jquery/5_4.png"><br></div><br>##### 问题：jauery回调Callbacks<br>jQuery.Callbacks()提供的回调函数队列管理本来是延时回调处理的一部分，但是后面将其独立出来作为一个模块。jQuery就是这样，各个模块间的代码耦合度是处理的比较好的，值得学习。虽然是从延时回调处理中独立出来的，但是它的功能非常强大，提供了一种强大的方法来管理回调函数队列。<br>　　大家都明白封装函数的目的：去耦合与简化操作。<br>　　通常情况下函数队列的处理方式<br><br>    //执行函数<br>    function runList(arr){<br>        for(var i = 0; i &lt; arr.length; i++){<br>            arr<a href="">i</a>;　　　　<br>        }<br>    　　arr.length = 0;<br>    }<br><br>    var list = [];<br>    //添加函数队列<br>    list[list.length] = function(){alert(1)};<br>    list[list.length] = function(){alert(2)};<br>    list[list.length] = function(){alert(3)};<br>    //执行<br>    runList(list);//三个函数顺序执行<br><br>使用$.callbacks封装以后的处理为<br><br>    var callbacks = $.Callbacks(“unique”);<br><br>    callbacks.add( function(){alert(1)} );<br>    callbacks.add( function(){alert(2)} );<br>    callbacks.add( function(){alert(3)} );<br>    //执行<br>    callbacks.fire();//三个函数顺序执行<br><br>干净了很多。而且代码可读性比最开始的那个要好很多。list[list.length]神马的最讨厌了。还有主要的是$.callbacks有四个属性可以组合，这个组合可就很强大了。<br><br>　　<br><br>a. Callbacks的四个可设置的属性分析<br><br><br><br>once: 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred).<br><br>       设置“once”在执行第一次fire后会直接禁用该Callbacks(fire函数代码段else {self.disable();})<br><br>    var f1 = function(value) { console.log(value); };<br>    var callbacks = $.Callbacks(‘once’);<br><br>    callbacks.add(f1);//无执行结果,添加一个回调<br>    callbacks.fire(1);//执行结果1。清除回调列表<br>    callbacks.add(f1);//没有添加回调直接返回<br>    callbacks.fire(2);//无执行结果<br>    callbacks.add(f1);//没有添加回调直接返回<br>    callbacks.fire(3);//无执行结果<br><br>memory: 保持以前的值（参数），将函数添加到这个列表的后面，并使用先前保存的参数立即执行该函数。 内部变量会保存上次执行的场景。<br><br>　　他有一个特点，就是在第一次fire之前使用add添加的回调都不会马上执行，只有调用了一次fire之后使用add添加的回调会马上执行。该设置本身不会清除之前的回调列表。<br><br>　　需要注意的是每次add内部执行fire函数都会将firingStart置为0，只有下次add的时候会从新设置firingStart的值。<br><br>　　eg:<br><br>    var f1 = function(value) {    console.log(value); };<br>    var callbacks = $.Callbacks(“memory”);<br><br>    callbacks.add( fn1 );//无执行结果<br>    callbacks.fire( “1” );//执行结果1。保存场景参数1<br><br>    callbacks.add( fn1 );//执行结果1。使用上次保存的场景参数1<br>    callbacks.fire( “2” );//执行结果2,2。保存场景参数2<br><br>    callbacks.add( fn1 );//执行结果2。使用上次保存的场景参数2<br>    callbacks.fire( “3” );//执行结果3,3,3。保存场景参数3<br><br>    callbacks.add( fn1 );//执行结果3。使用上次保存的场景参数3<br>    callbacks.fire( “4” );//执行结果4,4,4,4。保存场景参数4<br><br>　组合使用，组合使用中间使用空格隔开<br><br>　　设置“once memory”, options.once=options.memory=true。在执行第一次fire后会把回到列表清空，而且之后每次add马上执行后页同样会把回调列表清空（fire函数代码段else if ( memory ) {list = [];}）。<br><br>       eg:<br><br>    var f1 = function(value) { console.log(value); };<br>    var callbacks = $.Callbacks(‘once memory’);<br><br>    callbacks.add(f1);//无执行结果,添加一个回调<br>    callbacks.fire(1);//执行结果1。清除回调列表，保存场景参数1<br>    callbacks.add(f1);//添加一个回调并执行结果1，使用上次保存的场景参数。清除回调列表<br>    callbacks.fire(2);//无执行结果<br>    callbacks.add(f1);//添加一个回调并执行结果1，使用上次保存的场景参数。清除回调列表<br>    callbacks.fire(3);//无执行结果<br><br>两个设置之间用空格，不支持其他符号，比如设置“once,memory”等同于没有设置。<br><br>　　eg:<br><br>    var f1 = function(value) { console.log(value); };<br>    var callbacks = $.Callbacks(‘once,memory’);<br><br>    callbacks.add(f1);//无执行结果,添加一个回调<br>    callbacks.fire(1);//执行结果1<br>    callbacks.add(f1);//添加一个回调<br>    callbacks.fire(2);//执行结果2,2<br>    callbacks.add(f1);//添加一个回调<br>    callbacks.fire(3);//执行结果3,3,3<br>    callbacks.add(f1);//添加一个回调<br>    callbacks.fire(4);//执行结果4,4,4,4<br><br>unique: 确保一次只能添加一个回调(所以在列表中没有重复的回调).<br><br><br><br>stopOnFalse: 当一个回调返回false 时中断调用<br><br>       当有一个回调返回false的时候，会设置memory为false。导致memory失去作用（后续add的函数不会马上执行，当然先前memory保证了前面执行过得函数不再执行这也条也就不起作用了。下次fire会从回调列表的第一个开始执行）。<br><br><br><br>b. 整体结构<br><br>　　使用缓存是jQuery中最常见的技巧。$.Callbacks中也不例外。主要是缓存Callbacks中遇到的选项（字符串）。<br><br>    // 使用过的选项缓存<br>    var optionsCache = {};<br><br>    // 新增和缓存回调设置于optionsCache中<br>    function createOptions( options ) {<br>        var object = optionsCache[ options ] = {};<br>        jQuery.each( options.match( core<em>rnotwhite ) || [], function( </em>, flag ) {<br>            object[ flag ] = true;<br>        });<br>        return object;<br>    }<br><br>    jQuery.Callbacks = function( options ) {<br>        // 尽可能读取缓存，没有则新增缓存<br>        options = typeof options === “string” ?<br>        ( optionsCache[ options ] || createOptions( options ) ) :<br>        jQuery.extend( {}, options );<br><br>        var // 回调列表正在执行（为true的时候）的标志<br>            firing,<br>            // 最后执行的值（为memory选项下保存）<br>            memory,<br>            // 回调已经被执行过的标志<br>            fired,<br>            // 循环执行回调列表的结束位置<br>            firingLength,<br>            // 当前真正执行的回调的索引值 (执行下个回调的时候回更改【如果必要的话】)<br>            firingIndex,<br>            // 循环执行回调列表的开始位置(在函数add和fireWith中使用)<br>            firingStart,<br>            // 回调列表<br>            list = [],<br>            // Stack记录要重复执行的回调列表<br>            stack = !options.once &amp;&amp; [],<br>            // data数组一般第一个元素是上下文环境，第二个元素是参数<br>            //执行回调列表<br>            fire = function( data ) {…},<br>            // 回调对象<br>            self = {<br>                // 添加回调<br>                add: function() {…},<br>                // 移除回调<br>                remove: function() {…},<br>                …<br>                // 给定 context 和 arguments执行所有回调<br>                fireWith: function( context, args ) {<br>                    args = args || [];<br>                    //组装args，第一个元素为上下文环境，第二个元素为参数列表<br>                    args = [ context, args.slice ? args.slice() : args ];<br>                    //有list且函数列表没有被执行过或者存在要循环执行的函数列表<br>                    if ( list &amp;&amp; ( !fired || stack ) ) {<br>                        //如果正在fire，则把函数场景记录在stack中<br>                        if ( firing ) {<br>                            stack.push( args );<br>                        //否则，至此那个fire<br>                        } else {<br>                            fire( args );<br>                        }<br>                    }<br>                    return this;<br>                },<br>                // 使用给定的arguments执行所有回调<br>                fire: function() {<br>                    self.fireWith( this, arguments );<br>                    return this;<br>                },<br>                …<br>            };<br>        return self;<br>    };<br><br>下面分析两个最重要的两个函数，添加回调函数add和执行回调函数fire<br><br>c. add:添加回调<br><br>　　添加回调函数比较简单，针对可能传递的值（函数或者函数数组）将回调添加到回调列表中即可，这里使用了一个闭包，使用了外部变量list。<br><br>     (function add( args ) {<br>                jQuery.each( args, function( <em>, arg ) {<br>                    var type = jQuery.type( arg );<br>                    if ( type === “function” ) {<br>                        //当$.Callbacks(‘unique’)时，保证列表里面不会出现重复的回调<br>                        if ( !options.unique || !self.has( arg ) ) {<br>                            list.push( arg );<br>                        }<br>                    //如果是数组则递归添加<br>                    } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== “string” ) {<br>                        add( arg );<br>                    }<br>                });<br>            })( arguments );<br><br>　但是这里需要对用户初始化设置的属性做一些特殊的处理。<br><br>　　如果列表没有定义或null（一般只有在用户设置once且执行过一次后list才会白置为未定义），直接返回list<br><br>    //如果列表没有定义或null（一般只有在用户设置once且执行过一次后list才会白置为未定义）<br>        if ( list ) {<br>            …<br>        }<br>        return this;<br><br>当有回调真正执行的时候，需要重新设定回调列表的结束位置firingLength，使后续添加的函数也会执行。实际上这个功能很受争议，不过正常情况一般不会出现添加函数的时候正在执行某个回调。<br><br>　　还有一个比较重要的判断：对于设置了’memory’选项并fire过了回调列表，并且没有还在等待中的回调要fire,则应当马上执行新添加的回调（执行fire(memory)）<br><br>    // 如果正在fire，则设定要执行结束的点firingLength，使后续添加的函数最后不会执行<br>            if ( firing ) {<br>                firingLength = list.length;<br>            // 对于memory（设置了’memory’ option并fire过了，memory才能通过该else if语句）,<br>            //如果没有回调真正fire,应当马上执行fire(memory)。<br>            } else if ( memory ) {<br>                //这里保证了前面执行过得函数不再执行<br>                firingStart = start;<br>                fire( memory );<br>            }<br><br>完整的源码如下<br><br>    add: function() {<br>        //如果列表没有定义或null（一般只有在用户设置once且执行过一次后list才会白置为未定义）<br>        if ( list ) {<br>            // 保存当前list长度，为memory处理备用<br>            var start = list.length;<br>            (function add( args ) {<br>                jQuery.each( args, function( </em>, arg ) {<br>                    var type = jQuery.type( arg );<br>                    if ( type === “function” ) {<br>                        //当$.Callbacks(‘unique’)时，保证列表里面不会出现重复的回调<br>                        if ( !options.unique || !self.has( arg ) ) {<br>                            list.push( arg );<br>                        }<br>                    //如果是数组则递归添加<br>                    } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== “string” ) {<br>                        add( arg );<br>                    }<br>                });<br>            })( arguments );<br>            // 如果正在fire，则设定要执行结束的点firingLength，使后续添加的函数最后执行<br>            if ( firing ) {<br>                firingLength = list.length;<br>            // 对于memory（设置了’memory’ option并fire过了，memory才能通过该else if语句）,<br>            //如果我们后续没有fire,应当马上执行fire(memory)。<br>            } else if ( memory ) {<br>                //这里保证了前面执行过得函数不再执行<br>                firingStart = start;<br>                fire( memory );<br>            }<br>        }<br>        return this;<br>    }<br><br>d. fire函数详解<br><br>　　该函数执行回调，最终执行代码段为<br><br>    if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {<br>           memory = false; // 阻止未来可能由于add所产生的回调<br>           break;<br>    }<br>    fire = function( data ) {<br>    　　//有memory才给memory赋值当前场景data<br>    　　memory = options.memory &amp;&amp; data;<br>    　　fired = true;<br>    　　firingIndex = firingStart || 0;<br>    　　//每次fire后都会重置成0，下次$.callbacks.fire调用都会从0开始。当然设置为‘memory’使用add函数内部fire会设置firingStart的值导致回调函数列表执行起始位置更改<br>    　　firingStart = 0;<br>    　　firingLength = list.length;<br>    　　firing = true;<br><br>    　　//函数开始执行从firingStart到firingLength的所有函数<br>    　　for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {<br>    　　　　//执行firingIndex对应的函数，如果设置是遇到false返回就停止，则设置memory，阻止后续函数执行<br>    　　　　if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {<br>    　　　　　　memory = false; // 阻止未来可能由于add所产生的回调<br>    　　　　　　break;<br>    　　　　}<br>    　　}<br><br>    　　//标记回调结束<br>    　　firing = false;<br><br>    　　//如果列表存在<br>    　　if ( list ) {<br>    　　　　//如果堆栈存在（一般没有设置once的时候都进入该分支）<br>    　　　　if ( stack ) {<br>    　　　　　　//如果堆栈不为空<br>    　　　　　　if ( stack.length ) {<br>    　　　　　　　　//执行stack中第一个元素<br>    　　　　　　　　fire( stack.shift() );<br>    　　　　　　}<br>    　　　　//如果有记忆，则清空列表(在设置为once且memory的时候会进入到此分支)<br>    　　　　} else if ( memory ) {<br>    　　　　　　list = [];<br>    　　　　//禁用回调,该callbacks将不可用，将list/stack/memory都设为未定义<br>    　　　　} else {<br>    　　　　　　self.disable();<br>    　　　　}<br>    　　}<br>    },<br><br>真正重要的是执行完成回调以后的处理<br><br>    //如果列表存在<br>    　　if ( list ) {<br>    　　　　//如果堆栈存在（一般没有设置once的时候都进入该分支）<br>    　　　　if ( stack ) {<br>    　　　　　　//如果堆栈不为空<br>    　　　　　　if ( stack.length ) {<br>    　　　　　　　　//执行stack中第一个元素<br>    　　　　　　　　fire( stack.shift() );<br>    　　　　　　}<br>    　　　　//如果有记忆，则清空列表(在设置为once且memory的时候会进入到此分支)<br>    　　　　} else if ( memory ) {<br>    　　　　　　list = [];<br>    　　　　//禁用回调,该callbacks将不可用，将list/stack/memory都设为未定义<br>    　　　　} else {<br>    　　　　　　self.disable();<br>    　　　　}<br>    　　}<br><br>首先看最外层的判断<br><br>    if ( list ){<br>        …<br>    }<br><br>什么时候会进不了这个分支呢？唯有当self.disable()被调用的时候，下一次fire就进入不了这个分支。查看self.disable源码<br><br>    disable: function() {<br>                        list = stack = memory = undefined;<br>                        return this;<br>                    }<br><br>根据里面的判断唯有当options选项有once，并且选项中没有memory或选项中有stopOnFalse且执行的回调返回false。这个时候回进入到里面的分支直接将整个回调禁用掉。<br><br>    　　　　//禁用回调,该callbacks将不可用，将list/stack/memory都设为未定义<br>    　　　　} else {<br>    　　　　　　self.disable();<br>    　　　　}<br><br>　　第一个内部分支if ( stack )主要是选项中没有once就进入。<br><br>　　第二个内部分支只有在选项至少有once和memory的时候才会进入。当然，如果还有stopOnFalse且执行的回调返回false会进入到第三个分支。<br><br>　　　　//如果有记忆，则清空列表(在设置为once且memory的时候会进入到此分支)<br>　　　　<br>    } else if ( memory ) {<br><br><br><div align="center"><br>实例1<br><img src="/images/jquery/3_1.png"><br>实例2<br><img src="/images/jquery/3_2.png"><br>实例3<br><img src="/images/jquery/3_3.png"><br>实例4<br><img src="/images/jquery/3_4.png"><br>实例5<br><img src="/images/jquery/3_5.png"><br></div><br>##### 问题：Deferred<br><div align="center"><br>实例1<br><img src="/images/jquery/2_1.png"><br>实例2<br><img src="/images/jquery/2_2.png"><br>实例3<br><img src="/images/jquery/2_3.png"><br>实例4<br><img src="/images/jquery/2_4.png"><br>实例5<br><img src="/images/jquery/2_5.png"><br>实例6<br><img src="/images/jquery/2_6.png"><br>实例7<br><img src="/images/jquery/2_7.png"><br>实例8<br><img src="/images/jquery/2_8.png"><br>实例9<br><img src="/images/jquery/2_9.png"><br>实例10<br><img src="/images/jquery/2_10.png"><br>实例11<br><img src="/images/jquery/2_11.png"><br>实例12<br><img src="/images/jquery/2_12.png"><br></div><br>when方法要求返回的一定是延迟对象状态，若果某个函数不返回状态，则它将不会被认定为延迟对象。因此会被跳过。<br>如下图运行结果可证：<br><div align="center"><br><img src="/images/jquery/2_13.png"><br></div>    

<p>详解</p>
<pre><code>//document ready简便写法$(function(){…})
} else if ( jQuery.isFunction( selector ) ) {
    return rootjQuery.ready( selector );
}        
</code></pre><p>所以$(fn)===$(document).ready(fn)。</p>
<p>　　来看一下jQuery.fn.ready的源码</p>
<pre><code>ready: function( fn ) {
    // Add the callback
    jQuery.ready.promise().done( fn );

    return this;
}    
</code></pre><p>很明显在jQuery.ready.promise函数中设置了延时，当延时对象解决的时候执行fn函数。<br>主要的处理流程：<br>　　创建一个延时对象，并将文档准备好后的处理事件添加到该延时对象成功事件列表上。    </p>
<pre><code>jQuery.ready.promise = function( obj ) {
　　if ( !readyList ) {
　　　　readyList = jQuery.Deferred();

　　　　...

　　}
    return readyList.promise( obj );
}
</code></pre><p>添加文档准备状态的监听函数(jQuery.ready.promise函数片段)</p>
<pre><code>//标准浏览器支持DOMContentLoaded事件
    } else if ( document.addEventListener ) {
            //绑定DOMContentLoaded事件和响应函数，响应函数会解决延时
            document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );

            //回退到window.onload事件绑定，所有的浏览器都支持
            window.addEventListener( &quot;load&quot;, completed, false );

    //如果是IE事件模型
    } else {
            //确保在onload之前执行延时，可能时间比较迟，但是对于iframes来说比较安全
            document.attachEvent( &quot;onreadystatechange&quot;, completed );

            //回退到window.onload事件绑定，所有的浏览器都支持
            window.attachEvent( &quot;onload&quot;, completed );

            //如果IE并且不是一个frame
            //不断地检查，看是否该文件已准备就绪
            var top = false;
            try {
                top = window.frameElement == null &amp;&amp; document.documentElement;
            } catch(e) {}
            if ( top &amp;&amp; top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery.isReady ) {
                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll(&quot;left&quot;);
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        //移除之前绑定的事件
                        detach();

                        //执行延迟
                        jQuery.ready();
                    }
                })();
            }
        }    
</code></pre><p>一旦监听到文档准备完成，则调用jQuery.ready执行延时对象的成功回调列表：即所有通过jQuery.ready(fn)【或jQuery(fn)】方式添加的函数fn。</p>
<pre><code>//ready事件处理函数
completed = function( event ) {
    // readyState === &quot;complete&quot;在老版本IE上适用
    if ( document.addEventListener || event.type === &quot;load&quot; || document.readyState === &quot;complete&quot; ) {
        detach();
        jQuery.ready();
    }
},
//清除ready事件绑定
detach = function() {
    if ( document.addEventListener ) {
        document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false );
        window.removeEventListener( &quot;load&quot;, completed, false );

    } else {
        document.detachEvent( &quot;onreadystatechange&quot;, completed );
        window.detachEvent( &quot;onload&quot;, completed );
    }
};
    //处理当DOM准备完成
jQuery.ready: function( wait ) { 　　 　　
    ... 　　　　 　　
    //设置DOM已经准备好的标志 　　 　　
    jQuery.isReady = true;  　　
    ... 　　
    //执行绑定的延时事件 　　
    readyList.resolveWith( document, [ jQuery ] ); 　　
    //触发任何绑定的就绪事件 　　
    if ( jQuery.fn.trigger ) { 　　　　
        jQuery( document ).trigger(&quot;ready&quot;).off(&quot;ready&quot;); 　　
    }  
}
</code></pre><p>a. 文档加载状态document.readyState</p>
<p>　　document.readyState用来判断文档加载状态，是一个只读属性，可能的值有：</p>
<p>　　0-uninitialized：XML 对象被产生，但没有任何文件被加载。<br>　　1-loading：加载程序进行中，但文件尚未开始解析。<br>　　2-loaded：部分的文件已经加载且进行解析，但对象模型尚未生效。<br>　　3-interactive：仅对已加载的部分文件有效，在此情况下，对象模型是有效但只读的。<br>　　4-complete：文件已完全加载，代表加载成功。</p>
<p>　　实例:</p>
<pre><code>document.onreadystatechange = stateChange;//当页面加载状态改变的时候执行这个方法.
function stateChange() { 　　
　　if(document.readyState == &quot;complete&quot;){ //当页面加载状态为完全结束时进入 　　　　
　　　　alert(&quot;文档加载成功&quot;) 　　
　　} 
}
</code></pre><p>但是，老版本的Firefox并不支持document.readyState【最新的Firefox已经支持了】。所以想要兼容所有浏览器监听文档准备完成分两种情况来处理：</p>
<p>　　- 标准浏览器使用addEventListener添加DOMContentLoaded和load监听，任何一个事件被触发即可</p>
<p>　　- 老版本IE浏览器使用attachEvent添加onreadystatechange和onload来监听，任何一个被触发，并且onreadystatechange时document.readyState === “complete”即可。</p>
<p>　　jQuery的处理也就是如此了</p>
<pre><code>jQuery.ready.promise = function(){
　　...
　　//标准浏览器支持DOMContentLoaded事件
　　else if ( document.addEventListener ) {
            //绑定DOMContentLoaded事件和响应函数，响应函数会解决延时
            document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );

            //回退到window.onload事件绑定，所有的浏览器都支持
            window.addEventListener( &quot;load&quot;, completed, false );

    //如果是IE事件模型
    } else {
            //确保在onload之前执行延时，可能时间比较迟，但是对于iframes来说比较安全
            document.attachEvent( &quot;onreadystatechange&quot;, completed );

            //回退到window.onload事件绑定，所有的浏览器都支持
            window.attachEvent( &quot;onload&quot;, completed );
　　　　　　　...
　　}
}
//ready事件处理函数
completed = function( event ) {
    // readyState === &quot;complete&quot;在老版本IE上适用
    if ( document.addEventListener || event.type === &quot;load&quot; || document.readyState === &quot;complete&quot; ) {
        detach();
        jQuery.ready();
    }
}    
</code></pre><p>b.doScroll检测文档加载完成</p>
<p>　　这是Diego Perini 发现的一种检测IE是否加载完成的方式。详细链接</p>
<p>　　原理是当页面 DOM 未加载完成时调用 doScroll 方法时会产生异常。那么不断的取检测异常是否发生就可以知道文档有没有加载完成。当没有发生异常，表明文档加载完成了。</p>
<pre><code>(function doScrollCheck() {
                    if ( !jQuery.isReady ) {
                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll(&quot;left&quot;);
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        //移除之前绑定的事件
                        detach();

                        //执行延迟
                        jQuery.ready();
                    }
                })();    
</code></pre><h5 id="问题：Support-功能检测，重点是内部使用-主要检测样式style的兼容性"><a href="#问题：Support-功能检测，重点是内部使用-主要检测样式style的兼容性" class="headerlink" title="问题：Support(功能检测，重点是内部使用,主要检测样式style的兼容性)"></a>问题：Support(功能检测，重点是内部使用,主要检测样式style的兼容性)</h5><p>Support所解决的并不是常用性的浏览器兼容问题</p>
<p><div align="center"><br><img src="/images/jquery/4_1.png"><br><img src="/images/jquery/4_2.png"><br><img src="/images/jquery/4_3.png"><br></div><br>则上图中通过检测返回false的就需要我们做兼容性处理了（针对不同的浏览器）<br>Support只是用来检测不同浏览器存在哪些兼容性问题，而具体的解决是由Hooks(钩子机制)来完成的</p>
<pre><code>jQuery.support = {
　　//当使用.innerHTML的时候,IE吞掉开头的空白。
　　leadingWhitespace:  true/false(空白还在/空白被吞掉（IE）), 

　　//IE浏览器会自动给空表插入tbody标签。
　　tbody:  true/false(tbody可用/tbody会被自动插入（IE）),
　　
　　// IE6-8下确保link/ script/ style或其他html5标签元素能使用innerHTML正确载入的前提是需要一个元素包裹他们。使用div元素来包裹，并且div之前要一个不换行的字符。例如“X&lt;div&gt;&lt;link/&gt;&lt;/div&gt;”。
　　htmlSerialize:  true/false(不用包裹能正确加载/需要包裹（IE）),
　　
　　//获取节点的style属性时：现代浏览器使用elem.getAttribute(&quot;style&quot;),而IE使用elem.style.cssText
　　style:  true/fasle(使用. getAttribute/IE下使用.cssTex),
　　
　　//确保节点的css特征opacity存在 (IE使用filter)
　　opacity:  true/false(opacity存在/opacity不存在),
　　
　　//验证float样式存在, (IE使用styleFloat而不是cssFloat)
　　cssFloat:  true/fasle(float样式使用cssFloat特征名/使用styleFloat特征名),
　　
　　//检查checkbox/radio的默认值(老版本WebKit 默认为&quot;&quot;，其他浏览器默认为&quot;on&quot;)
　　checkOn:  true/false(默认值为on/默认值为空),
　　
　　//确保一个默认选项有一个可用的selected特征值.
　　//(如果他是一个option组，WebKit的默认选项的selected特征值为false，IE也是。)
　　optSelected:  true/false(有默认选中/没有默认选中，兼容处理时需要设置一个),
　　 
　　//确保克隆的html5节点（没有内容）不会出现问题。
　　//比如document.createElement(&quot;nav&quot;).cloneNode( true ).outerHTML应该得到&quot;&lt;nav&gt;&lt;/nav&gt;&quot;,而IE却是&quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;
　　html5Clone:  true/false(能够正常克隆/IE下使用cloneNode有问题),
　　 
　　//确保节点的checked状态也能被克隆
　　noCloneChecked:  true/false(能够正常克隆/IE下克隆checked状态没有被克隆),
　　 
　　//确保option选项disabled而select不被标记为disabled(WebKit会把两者都标记为disabled)
　　optDisabled:  true/false(disabled正常/两者都会标记为disabled)
　　 
　　//测试是否能使用delete div.test的方式来删除特征，否则使用delete div[test]（IE&lt;9）
　　deleteExpando: true/false(可以使用delete div.test/不能使用delete div.test)
　　 
　　//检查input标签是否可以使用getAttribute(&quot;value&quot;)来获取值（IE下不行，需要使用elem[‘value’]）
　　input: true/false(能信任getAttribute(&quot;value&quot;)/不能信任getAttribute(&quot;value&quot;))
　　 
　　//检查一个input标签在更改为radio类型后他的值是否还是先前的值（ie会变成默认值”on”,其他浏览器不变）
　　radioValue: true/false(值不会改变/会改变成默认值),
　　 
　　// webkit不能正确克隆fragments中的checked状态
　　checkClone:  true/false(能正确克隆/不能正确克隆)
　　 
　　//判断事件是否被克隆。（兼容IE&lt;9。 Opera不克隆事件(并且typeof div.attachEvent === undefined). IE9-10克隆事件通过attachEvent,但是不能通过 .click()来触发）
　　noCloneEvent:  true/false(现代浏览器克隆节点时事件不被克隆/ie8浏览器克隆节点的时候事件也被克隆)
　　 
　　// IE&lt;9 (缺少submit/change事件冒泡)，Firefox 17+ (缺少focusin事件)
　　submitBubbles:  true/false(支持冒泡/不支持冒泡),
　　changeBubbles:  true/false（支持冒泡/不支持冒泡）,
　　focusinBubbles:  true/false（支持冒泡/不支持冒泡）,
　　 
　　//检查是否能准确克隆css样式，比如一些可以继承父节点的样式没有设值的时候值应该是inherit，但是并非每个浏览器都能获取到该值。
　　clearCloneStyle：true/false（能准确克隆/不能准确克隆）,
　　 
　　//（判断前提条件：DOM加载完成）判断offsetWidth/Height是否可靠（主要用于判断元素是否占用空间，如果元素占用空间了，就认为是可见的，否则就认为是不可见：hidden）；IE8下表格的空cell依然有offsetWidth/Height。
　　reliableHiddenOffsets： true/false（【offsetWidth/Height值可靠】/【offsetWidth/Height值不可靠】）
　　 
　　//（判断前提条件：DOM加载完成）测试getComputedStyle获取的位置是否是像素单位。webkit的bug,使用getComputedStyle返回的最终样式中top/left/right/bottom不一定是像素为单位的，可能是指定的百分比等
　　pixelPosition： true/false（位置css样式以像素为单位返回/位置css样式以指定的格式返回）
　　 
　　//（判断前提条件：DOM加载完成）测试设置的boxSizing是否可靠。使用getComputedStyle获取的最总计算样式的浏览器可能会出现问题。
　　boxSizingReliable:  true/false（可靠/不可靠）
　　 
　　//（判断前提条件：DOM加载完成）检测使用getComputedStyle 返回的margin-right值是否正确：WebKit Bug 13343 – getComputedStyle返回错误的margin-right值。解决办法：处理元素的display临时设置为inline-block的解决来计算。
　　reliableMarginRight： true/false(返回值可靠/返回值不可靠)
}

//还有一部分没有在jQuery.support中，但是在Sizzle引擎中有描述
support = {
　　//IE8下对节点的一些没有存在的属性（attributes）获取值返回一个字符串
　　attributes:  true/false(返回正确/返回字符串)
　　
　　//检测getElementsByClassName是否可靠。IE8不支持；Opera中如果同一个标签有多个classname,那么他只能找到第一个classname (在 9.6版本中)；Safari 3.2会缓存class属性并且使用. className修改后不会更改缓存。
　　getByClassName： true/false(可以信赖/不值得信赖)
　　
　　//检测getElementsByName是否可靠。IE下某些标签是没有name属性的，比如div。
　　getByName： true/false(可靠/不可靠)
　　 
　　//检测浏览器是否支持querySelectorAll方法。这里说一个关于context.querySelector/querySelectorAll的要点。context.querySelector查找的是context下匹配的第一个子元素。但是有一个特点就是选择器可以从context本身开始。比如有一个div如&lt;div id=’chua’ class=’chua’&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;。我们查找p可以使用document.getElementById(&apos;chua&apos;) .querySelector(&apos;p &apos;)。页可以是document.getElementById(&apos;chua&apos;) .querySelector(&apos;.chua p&apos;)。当然document.getElementById(&apos;chua&apos;) .querySelector(&apos;.chua&apos;)是查不到值的。
　　qsa： ture/false(支持/不支持)
　　 
　　//检测对matchesSelector的支持情况。目前除IE6-IE8，Firefox/Chrome/Safari/Opera/IE 的最新版本均已实现，但方法都带上了各自的前缀
　　matchesSelector： ture/false(支持/不支持)　　      
}       
</code></pre><p>知识小点：1.elem.getAttribute(“href”/”src”)都是写入什么返回什么，elem.href/elem.src都是返回绝对路径</p>
<h6 id="钩子（hooks）机制"><a href="#钩子（hooks）机制" class="headerlink" title="钩子（hooks）机制"></a>钩子（hooks）机制</h6><p>钩子机制是jQuery用来处理浏览器兼容的手法。钩子在.attr(), .prop(), .val() and .css() 四种操作中会涉及。<br>钩子机制是怎么样的？<br>我们将以一个属性（attribute）钩子来举例。IE9-浏览器中，将input标签更改类型（type）为radio类型以后，value属性可能出现异常。所以我们定义了一个属性钩子（attrHooks）中类型（type）在更改设置（set）的一个处理。结构如下　</p>
<pre><code>//属性钩子对象（所有的属性钩子都放在里面）
attrHooks: {
　　//属性为type的钩子
　　type: {
　　　　//操作为set的钩子
　　　　set: function( elem, value ) {
　　　　　　if ( !jQuery.support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
　　　　　　　　//IE6-9设置完type后恢复value属性（attr）
　　　　　　　　var val = elem.value;
　　　　　　　　elem.setAttribute( &quot;type&quot;, value );
　　　　　　　　if ( val ) { elem.value = val; }
　　　　　　　　　　return value;
　　　　　　　　}
　　　　　　}
　　　　}
　　}
}
</code></pre><p>后续的钩子结构都是这样的：钩子对象：{钩子类型：{钩子操作：xxx},……}<br>　　钩子结构我们就清楚了。然后我们来看看jQuery如何使用这些钩子。只看与钩子例子相关的部分</p>
<pre><code>//先获取钩子，此时name=&quot;type&quot;　　
hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
　　
//此时value=&quot;radio&quot;
if ( value !== undefined ) {
　　...
　　} else if ( hooks &amp;&amp; notxml &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
　　　　return ret;
　　} else {
　　　　...
　　}
}
</code></pre><p>使用流程也比较清晰，先获取指定类型（”type”）的钩子(hooks)对象，然后判断如果钩子操作(“set”)在钩子对象中，则执行之。<br>　　可以想象，任何标签属性的任何类型的操作需要做兼容就都可以放在钩子对象中，如果是新的没有出现过的新操作则在实现的时候添加一行对新操作的判断语句处理即可；绝大多数情况是不会出现新操作兼容的，执行添加一个新的钩子对象的元素即可。可以说拓展性非常好。<br>接下来一一分析各种钩子，顺便了解相关的浏览器的兼容问题。</p>
<p>a. 属性操作的钩子</p>
<p>　　属性钩子种类：</p>
<p>　　propFix</p>
<p>　　propHooks</p>
<p>　　attrHooks</p>
<p>　　valHooks</p>
<p>jQuery.propFix</p>
<pre><code>propFix: {
        tabindex: &quot;tabIndex&quot;,
        readonly: &quot;readOnly&quot;,
        &quot;for&quot;: &quot;htmlFor&quot;,
        &quot;class&quot;: &quot;className&quot;,
        maxlength: &quot;maxLength&quot;,
        cellspacing: &quot;cellSpacing&quot;,
        cellpadding: &quot;cellPadding&quot;,
        rowspan: &quot;rowSpan&quot;,
        colspan: &quot;colSpan&quot;,
        usemap: &quot;useMap&quot;,
        frameborder: &quot;frameBorder&quot;,
        contenteditable: &quot;contentEditable&quot;
}
</code></pre><p>propFix对属性名称做了驼峰修正（修正为浏览器所支持的标签属性），即使用户大小写输入错误也能得到修正。<br>　　需要特别提示的是由于class属于JavaScript保留值，因此当我们要操作元素的class属性（attribute）值时，直接使用obj.getAttribute(‘class’)和obj.setAttribute(‘class’, ‘value’)可能会遭遇浏览器兼容性问题，W3C DOM标准为每个节点提供了一个可读写的className属性（attribute），作为节点class属性的映射，标准浏览器的都提供了这一属性的支持，因此，可以使用e.className访问元素的class属性值，也可对该属性进行重新斌值。而IE和Opera中也可使用e.getAttribute(‘className’)和e.setAttribute(‘className’, ‘value’)访问及修改class属性值。相比之下，e.className是W3C DOM标准，仍然是兼容性最强的解决办法。、<br>　　同理htmlFor用于读取label标签的for属性<br>jQuery.propHooks特征（property）方法</p>
<pre><code>    propHooks: {
    　　tabIndex: {
    　　　　get: function( elem ) {
    　　　　　　// elem.tabIndex在没有明确设置的情况下并不一定能返回正确值                                  
    　　　　　　// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
    　　　　　　var attributeNode = elem.getAttributeNode(&quot;tabindex&quot;);
    　　　　　　return attributeNode &amp;&amp; attributeNode.specified ?
               parseInt( attributeNode.value, 10 ) :
               rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ?
               0 :
               undefined;
            }
        }
    }
    //其中
    //rfocusable = /^(?:input|select|textarea|button|object)$/i,
    //rclickable = /^(?:a|area)$/i,

    // Safari 错误报告一个选项的默认选中状态
    // 通过父节点的 selectedIndex特征（property）修正他
    if ( !jQuery.support.optSelected ) {
    　　jQuery.propHooks.selected =
    　　　　jQuery.extend( jQuery.propHooks.selected, {
    　　　　　　get: function( elem ) {
    　　　　　　　　var parent = elem.parentNode;
    　　　　　　　　if ( parent ) {
    　　　　　　　　　　parent.selectedIndex;
    　　　　　　　　　　// 确保他依然适用于option组,详见 #5701
    　　　　　　　　　　if ( parent.parentNode ) {
    　　　　　　　　　　　　parent.parentNode.selectedIndex;
    　　　　　　　　　　}
    　　　　　　　　}
    　　　　　　　　return null;
    　　　　　　}
    　　　　});
    }      

jQuery.attrHooks 方法

attrHooks: {
　　type: {
　　　　set: function( elem, value ) {
　　　　　　if ( !jQuery.support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
　　　　　　　　//IE6-9设置完type后恢复value属性（attr）
　　　　　　　　...
　　　　　　}
　　　　}
　　},


//修正老版本IE value属性（attr）获取和设置 fix oldIE value attroperty
if ( !getSetInput || !getSetAttribute ) {
　　jQuery.attrHooks.value = {
　　　　get: function( elem, name ) {
　　　　　　var ret = elem.getAttributeNode( name );
　　　　　　return jQuery.nodeName( elem, &quot;input&quot; ) ?
　　　　　　//input返回defaultValue，而非特征（property）
　　　　　　elem.defaultValue :
　　　　　　ret &amp;&amp; ret.specified ? ret.value : undefined;
　　　　},
　　　　set: function( elem, value, name ) {
　　　　　　if ( jQuery.nodeName( elem, &quot;input&quot; ) ) {
　　　　　　　　//input设置defaultValue
　　　　　　　　elem.defaultValue = value;
　　　　　　} else {
　　　　　　　　//使用nodeHook，否则将有误
　　　　　　　　return nodeHook &amp;&amp; nodeHook.set( elem, value, name );
　　　　　　}
　　　　}
　　};
}    
</code></pre><p>拓展</p>
<pre><code>//其中nodeName判断节点名称的小写是否和参数name的小写相同
jQuery.nodeName: function( elem, name ) {
　　return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
}
//bool类型属性（attr）还用到boolHook
boolHook = {
　　get: function( elem, name ) {
　　　　var
　　　　//使用 .prop来确定这个属性是否能被理解成布尔类型
　　　　prop = jQuery.prop( elem, name ),
　　　　//获取
　　　　attr = typeof prop === &quot;boolean&quot; &amp;&amp; elem.getAttribute( name ),
　　　　//备注getSetInput = jQuery.support.input;
　　　　//getSetAttribute = jQuery.support.getSetAttribute
　　　　detail = typeof prop === &quot;boolean&quot; ?
　　　　getSetInput &amp;&amp; getSetAttribute ?
　　　　attr != null :

　　　　// 老IE对缺失的布尔属性会会构造一个空字符
　　　　// checked/selected需要使用&quot;default-&quot; +
　　　　//备注ruseDefault = /^(?:checked|selected)$/i
　　　　ruseDefault.test( name ) ?
　　　　elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] :
　　　　!!attr :
　　　　//非布尔类型的属性处理 
　　　　elem.getAttributeNode( name );

　　　　return detail &amp;&amp; detail.value !== false ?
　　　　　　name.toLowerCase() :
　　　　　　undefined;
　　},
　　set: function( elem, value, name ) {
　　　　if ( value === false ) {
　　　　　　// 如果设置false则移除布尔属性
　　　　　　jQuery.removeAttr( elem, name );
　　　　} else if ( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) {
　　　　　　// IE&lt;8对input的checked/selected 需要特征（property）名称
　　　　　　elem.setAttribute( !getSetAttribute &amp;&amp; jQuery.propFix[ name ] || name, name );

　　　　// 老IE使用defaultChecked 和defaultSelected
　　　　} else {
　　　　　　elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] = elem[ name ] = true;
　　　　}

　　　　return name;
　　}
};


// IE一些attributes需要特殊处理
if ( !jQuery.support.style ) {
　　jQuery.attrHooks.style = {
　　　　get: function( elem ) {
　　　　　　// 参数为空字符串返回undefined
　　　　　　// 备注: IE会将css属性名称大写，但是如果我们使用 .toLowerCase()，那么将破坏url中的敏感度导致错误，比如background中设置了url
　　　　　　return elem.style.cssText || undefined;
　　　　},
　　　　set: function( elem, value ) {
　　　　　　return ( elem.style.cssText = value + &quot;&quot; );
　　　　}
　　};
}     
</code></pre><p>jQuery.valHooks 方法</p>
<pre><code>valHooks: {
　　option: {
　　　　get: function( elem ) {
           // Blackberry 4.7没有定义.attributes.value而使用.value
           var val = elem.attributes.value;
           return !val || val.specified ? elem.value : elem.text;
        }
　　},
　　select: {
        get: function( elem ) {
            var value, option,
               options = elem.options,
               index = elem.selectedIndex,
               one = elem.type === &quot;select-one&quot; || index &lt; 0,
               values = one ? null : [],
               max = one ? index + 1 : options.length,

               i = index &lt; 0 ?
               max :
               one ? index : 0;

           // Loop through all the selected options
           for ( ; i &lt; max; i++ ) {
               option = options[ i ];
               //IE6-9在重置后不会更新选中状态
               if ( ( option.selected || i === index ) &amp;&amp;
               //不可用或在不可用option组的option不要返回值
                ( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null ) &amp;&amp;
               ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {
                    //获取置顶的option值
                    value = jQuery( option ).val();

                    //单选select直接返回值
                   if ( one ) {
                       return value;
                   }

                   //多选Selects循环
                   values.push( value );
                }
           }

           return values;
        },
        set: function( elem, value ) {
           var values = jQuery.makeArray( value );

           jQuery(elem).find(&quot;option&quot;).each(function() {
                this.selected = jQuery.inArray( jQuery(this).val(), values ) &gt;= 0;
               });

           if ( !values.length ) {
               elem.selectedIndex = -1;
           }
           return values;
        }
    }
},

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
    jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
           jQuery.valHooks[ this ] = {
               get: function( elem ) {
                // Webkit在没有置顶值的时候会返回 &quot;&quot;，我们用on替代
                return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value;
               }
           };
    });
}
jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
    jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
           set: function( elem, value ) {
               if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );
               }
           }
    });
});     
</code></pre><p>对于val方法的取值部分</p>
<pre><code>if ( elem ) {
    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ]; 

    if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
        return ret;
    }
    ret = elem.value;
    return typeof ret === &quot;string&quot; ?
        // handle most common string cases
        ret.replace(rreturn, &quot;&quot;) :
        // handle cases where value is null/undef or number
        ret == null ? &quot;&quot; : ret;
}    
</code></pre><p>通过jQuery.valHooks匹配对应的钩子处理方法</p>
<p><div align="center"><br><img src="/images/jquery/4_4.png"><br></div><br>节点属性的差异对比:<br>　　select : 创建单选或多选菜单 </p>
<pre><code>type:&quot;select-one&quot;
tagName: &quot;SELECT&quot;
value: &quot;111&quot;
textContent: &quot;↵ Single↵ Single2&quot;  
</code></pre><p>option : 元素定义下拉列表中的一个选项</p>
<pre><code>tagName: &quot;OPTION&quot;
value: &quot;111&quot;
text: &quot;Single&quot;
textContent: &quot;Single&quot;
</code></pre><p>radio : 表单中的单选按钮</p>
<pre><code>type: &quot;radio&quot;
value: &quot;11111&quot;
</code></pre><p>　　<br>checkbox : 选择框</p>
<pre><code>type: &quot;checkbox&quot;
value: &quot;11111&quot;     
</code></pre><p>根据对比select的节点type是’select-one’与其余几个还不同，所以jQuery在适配的时候采用优先查找type,否则就找nodeName的策略</p>
<pre><code>hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
//如果钩子匹配到了，并且还存在get方法，那么就要调用这个方法了,如果有返回值就返回当前的这个最终值
if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
    return ret;
} 
</code></pre><p>上面分析了jQuery.support、钩子原理和属性钩子。下面主要分析CSS钩子<br>b. css操作的钩子</p>
<p>　　CSS钩子种类：</p>
<p>　　cssHooks</p>
<p>　　cssNumber</p>
<p>　　cssProps</p>
<p>jQuery.cssHooks的对象</p>
<p>　　不过cssHooks中的set函数的作用有些不同，set函数并没有真正的设置相应的值，而是修正要设置到CSS中的值。获取到修正值以后，设置在jQuery.style函数中进行。后面分析几个CSS钩子</p>
<p>　　获取opacity返回的值需要时数字</p>
<pre><code>cssHooks: {
　　opacity: {
　　　　get: function( elem, computed ) {
　　　　　　if ( computed ) {
　　　　　　　　//需要返回数字                      
　　　　　　　　var ret = curCSS( elem, &quot;opacity&quot; );
　　　　　　　　return ret === &quot;&quot; ? &quot;1&quot; : ret;
　　　　　　}
　　　　}
　　}
},
</code></pre><p>当设置display为none等的时候是不能获取到宽高的，所以需要将元素设为display为block，visibility设置为hidden来获取宽高；设置宽高需要根据CSS样式boxSizing的取值来确定。</p>
<pre><code>jQuery.each([ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
　　jQuery.cssHooks[ name ] = {
　　　　get: function( elem, computed, extra ) {
　　　　　　if ( computed ) {
               //当设置display为none等的时候是不能获取到宽高的，
                //所以需要将元素设为display为block,
               //visibility设置为hidden来获取宽高
               // rdisplayswap = /^(none|table(?!-c[ea]).+)/,
               //cssShow ={ position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; }

               return elem.offsetWidth === 0 &amp;&amp; rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) ?
                jQuery.swap( elem, cssShow, function() {
                    return getWidthOrHeight( elem, name, extra );

                }) :
                getWidthOrHeight( elem, name, extra );
           }
       },

       set: function( elem, value, extra ) {
　　　　　　var styles = extra &amp;&amp; getStyles( elem );
　　　　　　return setPositiveNumber( elem, value, extra ?
　　　　　　　　augmentWidthOrHeight(elem, name, extra,
　　　　　　　　　　jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,styles) : 
　　　　　　　　0
　　　　　　);
　　　　}
　　};
});
</code></pre><p>IE使用filters来设置不透明度；IE要设置不透明度更加复杂，需保证有布局，如果设置不透明度为1，并且没有别的filters存在，尝试移除filter属性等</p>
<pre><code>if ( !jQuery.support.opacity ) {
　　jQuery.cssHooks.opacity = {
　　　　get: function( elem, computed ) {
　　　　　　// IE使用filters来设置不透明度，ropacity = /opacity\s*=\s*([^)]*)/
　　　　　　return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ?
　　　　　　( 0.01 * parseFloat( RegExp.$1 ) ) + &quot;&quot; :
　　　　　　computed ? &quot;1&quot; : &quot;&quot;;
　　　　},
　　　　set: function( elem, value ) {
　　　　　　var style = elem.style,
　　　　　　currentStyle = elem.currentStyle,
　　　　　　opacity = jQuery.isNumeric( value ) ? &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;,
　　　　　　filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;;

　　　　　　//IE7中滤镜（filter）必须获得布局才能生效，我们用zoom这个IE私有属性让其获得布局
　　　　　　style.zoom = 1;

　　　　　　//ie处理，如果设置不透明度为1，并且没有别的filters存在，尝试移除filter属性
　　　　　　//如果只为“”，删除内联的opacity，ralpha = /alpha\([^)]*\)/i
　　　　　　if ( ( value &gt;= 1 || value === &quot;&quot; ) &amp;&amp; jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; &amp;&amp; style.removeAttribute ) {
　　　　　　　　//设置style.filter为null, &quot;&quot; 或 &quot; &quot;，结果是&quot;filter:&quot;依然在cssText中
　　　　　　　　//如果当下&quot;filter:&quot;存在则清除类型不可用，我们应当避免
　　　　　　　　// style.removeAttribute是IE独有
　　　　　　　　style.removeAttribute( &quot;filter&quot; );

　　　　　　　　//如果当前没有filter样式应用于css rule或未设置内联的不透明则返回
　　　　　　　　if ( value === &quot;&quot; || currentStyle &amp;&amp; !currentStyle.filter ) {
　　　　　　　　　　return;
　　　　　　　　}
　　　　　　}

　　　　　　// 其他情况设置filter values
　　　　　　style.filter = ralpha.test( filter ) ?
　　　　　　filter.replace( ralpha, opacity ) :
　　　　　　filter + &quot; &quot; + opacity;
　　　　}
　　};
}
</code></pre><p>webkit的bug:getComputedStyle返回margin-right值错误；当指定为top/left/bottom/right时，使用getComputedStyle 返回百分比结果，使用jQuery( elem ).position()来获取。</p>
<pre><code>//DOM加载完成后才能做support测试，在添加下面的Hooks
jQuery(function() {
    if ( !jQuery.support.reliableMarginRight ) {
           jQuery.cssHooks.marginRight = {
               get: function( elem, computed ) {
                   if ( computed ) {
                       // WebKit Bug 13343 - getComputedStyle返回margin-right值错误
                       //设置元素的display为inline-block来解决
                       return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; },
                               curCSS, [ elem, &quot;marginRight&quot; ] );
                   }
               }
           };
    }

    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle 返回百分比当指定为top/left/bottom/right
    //我们使用jQuery( elem ).position()来获取
    if ( !jQuery.support.pixelPosition &amp;&amp; jQuery.fn.position ) {
           jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
               jQuery.cssHooks[ prop ] = {
                    get: function( elem, computed ) {
                       if ( computed ) {
                               computed = curCSS( elem, prop );
                               // if curCSS returns percentage, fallback to offset
                               //rnumnonpx = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; ),
                               return rnumnonpx.test( computed ) ?
                               jQuery( elem ).position()[ prop ] + &quot;px&quot; :
                               computed;
                       }
                   }
               };
           });
    }
});    
</code></pre><p>后面这个钩子与众不同，他使用在动画的展开上。我们知道margin/padding/borderWidth实际上不是一个CSS属性，而是四个CSS属性的集合。所以三个CSS的expand钩子实际上是将他们拆分成四个属性给提取出来。</p>
<pre><code>// 这里的hooks用在动画的展开特征上
　　jQuery.each({
        margin: &quot;&quot;,
        padding: &quot;&quot;,
        border: &quot;Width&quot;
        }, function( prefix, suffix ) {
            jQuery.cssHooks[ prefix + suffix ] = {
                expand: function( value ) {
                    var i = 0,
                    expanded = {},

                        //如果不是字符串则假设为一个单独的数字
                        parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ];

                        for ( ; i &lt; 4; i++ ) {
                            //cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ],
                            expanded[ prefix + cssExpand[ i ] + suffix ] =
                            parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                        }

                        return expanded;
                    }
            };

            if ( !rmargin.test( prefix ) ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    });    
</code></pre><p>jQuery. cssNumber和jQuery.cssProps的对象</p>
<pre><code>//下面的css特征值后面不能添加“px”字段
cssNumber: {
    &quot;columnCount&quot;: true,
    &quot;fillOpacity&quot;: true,
    &quot;fontWeight&quot;: true,
    &quot;lineHeight&quot;: true,
    &quot;opacity&quot;: true,
    &quot;orphans&quot;: true,
    &quot;widows&quot;: true,
    &quot;zIndex&quot;: true,
    &quot;zoom&quot;: true
},

//float对应的css特征名需要在使用前修正
cssProps: {
    // normalize float css property
    &quot;float&quot;: jQuery.support.cssFloat ? &quot;cssFloat&quot; : &quot;styleFloat&quot;
},
</code></pre><p>拓展：</p>
<p>　　有一些CSS属性需要在某些特定条件下才能获取正确。这种情况需要模拟场景获取值，然后恢复先前的场景。swap就是用来专门模拟场景，获取值以后恢复场景的函数。</p>
<pre><code>// 一种快速切换输入/输出css特征值（计算前保存css特征，计算中更改css特征以获取计算结果，计算结束后恢复先前保存的css特征）以获取正确计算结果的方法
swap: function( elem, options, callback, args ) {
    var ret, name,
        old = {};

    // 保存原来的特征值,设置为保证计算成功而修改的特征（property）值
    for ( name in options ) {
           old[ name ] = elem.style[ name ];
           elem.style[ name ] = options[ name ];
    }
    //调用回调计算结果
    ret = callback.apply( elem, args || [] );

    // 恢复原来的特征值
    for ( name in options ) {
           elem.style[ name ] = old[ name ];
    }
    //返回计算结果
    return ret;
}
</code></pre><p>　　setPositiveNumber函数对要设置给CSS属性的值做修正，比如添加”px”结尾等</p>
<pre><code>// rnumsplit = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(.*)$&quot;, &quot;i&quot; ),
//用来匹配数字，.source返回表达式字符串自身
//core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
//返回指定value和subtract对应应该设置的css样式值
function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
    // 注意没有定义的&quot;subtract&quot;,例如在cssHooks中使用时
    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || &quot;px&quot; ) :
    value;
}
</code></pre><p>　　getWidthOrHeight函数提供获取CSS宽高属性的计算方法</p>
<pre><code>//获取宽度或高度
function getWidthOrHeight( elem, name, extra ) {
    //首先获取offset特征值，相当于包括边框在内的盒宽高
    var valueIsBorderBox = true,
        val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;

    //一些非html元素offsetWidth返回undefined,因此检查null/undefined
    if ( val &lt;= 0 || val == null ) {
        //如果计算失败则在必要的情况下使用未计算的结果
        val = curCSS( elem, name, styles );
        if ( val &lt; 0 || val == null ) {
            val = elem.style[ name ];
        }

        //已计算的单元为非像素单位则终止并返回
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        //我们需要检查style,避免浏览器使用getComputedStyle返回不可靠的值而悄悄的回到可靠的elem.style值
        valueIsBorderBox = isBorderBox &amp;&amp; ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

        //规范“”,auto为拓展做准备
        val = parseFloat( val ) || 0;
    }

    //使用动态box-sizing模型来添加/减少不相干的样式
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
            valueIsBorderBox,
            styles
            )
        ) + &quot;px&quot;;
}

//extra表示计算时要包括的部分
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    //在循环中遍历cssExpand时使用
    //其中cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ],
    var i = extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ?
        //如果我们有了正确的测量结果，避免增大，正常情况下会走这一步
        4 :
        //否则初始化为水平或垂直特征（property)
        name === &quot;width&quot; ? 1 : 0,

    val = 0;

    for ( ; i &lt; 4; i += 2 ) {
        //两种盒模型都排除margin,如果计算要包括margin，则加上他
        if ( extra === &quot;margin&quot; ) {
            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        //如果是border-box模型
        if ( isBorderBox ) {
            // border-box包括padding,如果我们需要内容部分因此要减去他
            if ( extra === &quot;content&quot; ) {
                val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
            }

            //此时，extra不是边框也非margin时,减去边框
            if ( extra !== &quot;margin&quot; ) {
                val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
            }
        //如果是content-box模型
        } else {
            //此时，extra不是内容，所以加上padding
            val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );

            //此时，extra不是内容也不是padding，所以加上边框
            if ( extra !== &quot;padding&quot; ) {
                val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
            }
        }
    }
    return val;
}
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/jquery源码总结(中) /#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jquery源码总结(上)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/jquery源码总结(上)/">jquery源码总结(上)</a>
    </h1>
  

        <a href="/2016/08/18/jquery源码总结(上)/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="jquery整体架构"><a href="#jquery整体架构" class="headerlink" title="jquery整体架构"></a>jquery整体架构</h5><div align="center"><br><img src="/images/jquery/1_1.png"><br></div><br>
        <a class="article-more-a"  href="/2016/08/18/jquery源码总结(上)/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/jquery源码总结(上)/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/jade/">jade</a>
    </h1>
  

        <a href="/2016/08/18/jade/" class="archive-article-date">
  	<time datetime="2016-08-18T01:13:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-08-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jade/">jade</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/08/18/jade/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
	
</script>
<script src="/./js/jquery-1.10.2.min.js"></script>
<script src="/./js/main.js"></script>
<script src="/./js/myJs.js"></script>



    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Git/" style="font-size: 16px;">Git</a> <a href="/tags/Github/" style="font-size: 12px;">Github</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/essay/" style="font-size: 10px;">essay</a> <a href="/tags/hexo/" style="font-size: 12px;">hexo</a> <a href="/tags/html/" style="font-size: 14px;">html</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/jade/" style="font-size: 12px;">jade</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/jquery/" style="font-size: 18px;">jquery</a> <a href="/tags/js/" style="font-size: 16px;">js</a> <a href="/tags/karma/" style="font-size: 10px;">karma</a> <a href="/tags/life/" style="font-size: 20px;">life</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/swiftype/" style="font-size: 10px;">swiftype</a> <a href="/tags/yilia/" style="font-size: 10px;">yilia</a> <a href="/tags/科研/" style="font-size: 10px;">科研</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
    
  </div>
</body>
</html>