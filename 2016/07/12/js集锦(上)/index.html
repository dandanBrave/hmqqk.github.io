<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>js集锦(上) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="此部分介绍了。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="js集锦(上)">
<meta property="og:url" content="http://yoursite.com/2016/07/12/js集锦(上)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="此部分介绍了。。。">
<meta property="og:updated_time" content="2016-12-29T06:58:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js集锦(上)">
<meta name="twitter:description" content="此部分介绍了。。。">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/myStyle.css">
  

  
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">

		<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
			<input type="text" id="st-search-input" class="st-search-input_my" maxlength="30" placeholder="憋别说,搜我！" />
			<a hre="" class="go"></a>
		</form>
	
	<header id="header" class="inner">
		<a href="/categories/myPage/myPage.html" class="profilepic">
			
			<img src="/images/title.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/categories/myPage/myPage.html">轻刻美</a></h1>
		</hgroup>

		
		<p class="header-subtitle">因上努力,果上随缘</p>
		
		
		<nav class="header-menu">
			<ul>
			
				<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
	        
				<li><a href="/">所有文章</a></li>
	        
				<li><a href="/categories/studies">学习</a></li>
	        
				<li><a href="/categories/lives">生活</a></li>
	        
				<li><a href="/categories/essays">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/hmqqk" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
		
		<div id="music-panel">
    <a id="music-control" href="javascript:void(0);" target="_blank"></a>
    <div id="music-content" class="hide">
       <div class="cover"><img src="/images/title.png"></div>
       <div class="ctrl">
					<div class="tag"></div>
					<div class="control">
						<div>
							<div class="rewind icon"></div>
							<div class="playback icon"></div>
							<div class="fastforward icon"></div>
						</div>
					</div>
					<div class="progress">
						<div class="control-icon right">
							<div class="repeat icon"></div>
							<div class="shuffle icon"></div>
						</div>
					</div>
					<audio></audio>
					<ul id="playlist"></ul>
				</div>
				
			</div>
		
</div>
    </div>
	</header>		
	
	
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">轻刻美</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/title.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">轻刻美</h1>
			</hgroup>
			
			<p class="header-subtitle">因上努力,果上随缘</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
		        
					<li><a href="/">所有文章</a></li>
		        
					<li><a href="/categories/studies">学习</a></li>
		        
					<li><a href="/categories/lives">生活</a></li>
		        
					<li><a href="/categories/essays">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hmqqk" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-js集锦(上)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      js集锦(上)
    </h1>
  

        <a href="/2016/07/12/js集锦(上)/" class="archive-article-date">
  	<time datetime="2016-07-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-07-12</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>此部分介绍了。。。<br><a id="more"></a></p>
<h5 id="记"><a href="#记" class="headerlink" title="记"></a>记</h5><p>由于鼠标从子元素移动到父元素上时，会触发子元素的移出事件，通过冒泡也会触发父元素移出事件。此时，有两种方法解决该问题。一种是在子元素移出事件中阻止冒泡，另一种是在父元素移出事件设置target判断条件。当target为父元素本身时才执行</p>
<h5 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h5><p>透明度是一个比较特殊的样式，因为IE8-浏览器不支持opacity，只能通过滤镜的方式写成filter:alpha(opacity=透明值)但是，由于IE浏览器获取计算样式时，可以获得自定义样式，所以虽然opacity属性在IE8-浏览器无法生效，但是可以获得它的值如果透明度做运动的话，则需要对运动函数进行重新封装<br>[注意]由于透明度涉及小数计算，如0.07*100=&gt; 7.000000000000001，所以需要用Math.round()去掉尾巴</p>
<pre><code>history.go();
</code></pre><p>计算样式的兼容函数getCSS()</p>
<pre><code>function getCSS(obj,style){
   if(window.getComputedStyle){
     return getComputedStyle(obj)[style];
   }
   return obj.currentStyle[style];
 }
</code></pre><p>使用style可以获取行内嵌的样式，却不能得到内联或者链接的样式。但是通过获取或者设置计算后的样式来解决这个问题。之所以可以实现是因为不管你在哪里设置的样式，最终都会驻留在浏览器的计算样式里。<br>DOM2 级样式，window 对象下提供了getComputedStyle()方法。接受两个参数，需要计算的样式元素，第二个伪类(:hover)，如果没有没有伪类，就填null。<br>PS：IE 不支持这个DOM2 级的方法，但有个类似的属性可以使用currentStyle 属性。</p>
<pre><code>var box = document.getElementByIdx_x_x_x(&apos;box&apos;);
var style = window.getComputedStyle ?window.getComputedStyle(box, null) : null || box.currentStyle;//兼容方法
alert(style .color); //颜色在不同的浏览器会有rgb()格式
alert(style .border); //不同浏览器不同的结果
alert(style .fontFamily); //计算显示复合的样式值
alert(box.style.fontFamily); //空
</code></pre><p>还有一个问题就是：通过计算获取元素的大小，无关你是否是行内、内联或者链接，它经过计算后得到的结果返回出来。如果本身设置大小，它会返回元素的大小，如果本身没有设置，非IE浏览器会返回默认的大小，IE 浏览器返回auto。<br>注意：border 属性是一个综合属性，所以他在Chrome 显示了，Firefox 为空，IE 为undefined。<br>所谓综合性属性，就是XHTML 课程里所的简写形式，所以，DOM 在获取CSS 的时候，最<br>好采用完整写法兼容性最好，比如：border-top-color 之类的。<br>多值<br>如果一个元素有多个值同时运动时，像下面这样直接调用move()函数是有问题的</p>
<pre><code>move(test,&apos;opacity&apos;,0.1,-0.05);
move(test,&apos;left&apos;,-100,-1);
</code></pre><p>因为函数里面定时器的变量timer是一个公共变量，当一个运动停止时，会清除定时器。这时另一个运动即使没有完成，定时器已经停止了，就无法继续运动了所以，合适的做法是在参数对象obj下面设置一个自定义属性timers，timers为一个空对象，然后将定时器返回值储存在timers对象下的attr属性中，此时两个定时器不会相互干扰</p>
<pre><code>  &lt;style&gt;
     #test{width: 100px;height: 100px;background-color: lightblue;text-align:center;position:absolute;top: 0;left:    -100px;opacity:1;} 
     #test-in{width: 30px;height: 60px;background-color: orange;margin-left: 100px;position:relative;top: 20px;}
 &lt;/style&gt;
 &lt;div id=&quot;test&quot;&gt;
   &lt;div id=&quot;test-in&quot;&gt;分享到&lt;/div&gt;
 &lt;/div&gt; 
&lt;script&gt;

 test.onmouseover = function(){
    move(test,&apos;opacity&apos;,0.1,-0.05);
    move(test,&apos;left&apos;,0,10);
 }
 test.onmouseout = function(){
    move(test,&apos;opacity&apos;,1,0.05);
    move(test,&apos;left&apos;,-100,-10);
 }
 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   
 function move(obj,attr,target,speed){
    if(!obj.timers){
        obj.timers = {};
    }
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>多物体<br>　　如果在页面中有多个元素利用运动函数进行运动。由于定时器返回值在不同元素不同属性中都不会受影响。<br>所以，上面的运动函数可以直接使用</p>
<pre><code>&lt;style&gt; 
  div{height: 100px;width: 100px;position: absolute;left: 0;} 
  #test1{background-color: pink;top: 40px;}  
  #test2{background-color: lightblue;top: 150px;} 
 &lt;/style&gt; 
 &lt;div id=&quot;test1&quot;&gt;元素一&lt;/div&gt; 
 &lt;div id=&quot;test2&quot;&gt;元素二&lt;/div&gt; 
 &lt;button id=&quot;btn&quot;&gt;开始运动&lt;/button&gt;  
 &lt;button id=&quot;reset&quot;&gt;还原&lt;/button&gt;    
  &lt;script&gt; 
 reset.onclick = function(){history.go();}
 btn.onclick = function(){
    move(test1,&apos;width&apos;,300,10);
    move(test1,&apos;left&apos;,100,10);
    move(test2,&apos;width&apos;,500,20);
    move(test2,&apos;left&apos;,200,10);
 }

 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   

 function move(obj,attr,target,speed){
    if(!obj.timers){
        obj.timers = {};
    }
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>回调<br>　 物体的多个属性可能不是同时运动，可能是一个属性运动完成之后，另一个属性再运动。如果要完成这种需求，就需要用到回调函数在运动函数中，定时器停止时，再调用运动函数，就可以接续运动效果</p>
<pre><code>&lt;style&gt;
 div{height: 100px;width: 100px;position: absolute;left: 0;}
 #test{background-color: pink;top: 40px;}
&lt;/style&gt;
 &lt;div id=&quot;test&quot;&gt;元素&lt;/div&gt;
 &lt;button id=&quot;btn&quot;&gt;开始运动&lt;/button&gt;
 &lt;button id=&quot;reset&quot;&gt;还原&lt;/button&gt; 
 &lt;script&gt;
 reset.onclick = function(){history.go();}
 btn.onclick = function(){
    move(test,&apos;left&apos;,100,20,function(){
        move(test,&apos;width&apos;,300,10)
    });
 }
 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   
 function move(obj,attr,target,speed,fn){
    if(!obj.timers){obj.timers = {};}
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
                fn &amp;&amp; fn.call(obj);
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
                fn &amp;&amp; fn.call(obj);
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>函数完善<br>【速度参数】<br>上面封装的函数中，传递速度参数时，需要在速度参数前添加正负号作为方向标识。实际上，这步可以写在函数的程序内，而只传递正的速度参数即可</p>
<pre><code>speed = parseInt(getCSS(obj,attr)) &lt; target ? speed : -speed;
</code></pre><p>【拉回操作】<br>　　还有一个可以升级的地方，就是拉回操作。通过判断元素是否到达目标点，如果超过目标点后，将元素拉回到目标点位置</p>
<pre><code>cur = parseInt(getCSS(obj,attr));
  if((cur - target)*speed &lt; 0){
     obj.style[attr] = cur + speed + &apos;px&apos;;
  }else{
     obj.style[attr] = target + &apos;px&apos;;
     clearInterval(obj.timers[attr]);
     obj.timers[attr] = 0;
     fn &amp;&amp; fn.call(obj);
  } 
</code></pre><p>更合理的操作，应该是元素肯定不能超过目标点<br>所以应该把判断条件用来处理speed，当speed是一个合适的值时，再赋值给obj.style[attr]，可更改如下</p>
<pre><code> cur = parseInt(getCSS(obj,attr));
//若速度设置值使得元素超过目标点时，将速度设置值更改为目标点值 - 当前值
 if((cur +speed - target)*speed &gt; 0){
    speed = target - cur; 
 }
//将合适的speed值赋值给元素的样式
obj.style[attr] = cur + speed + &apos;px&apos;;

//当元素到达目标点后，停止定时器
if(speed == target - cur){
  clearInterval(obj.timers[attr]);
  obj.timers[attr] = 0;
  fn &amp;&amp; fn.call(obj); 
}
</code></pre><p>【使用步长】<br>　　其实，把元素的位移变化命名为速度并不合适，只是因为约定俗成的关系才如此起名，将其命名为步长step更为合适，定时器每运行一次，该元素前面一步<br>最终函数</p>
<pre><code>function getCSS(obj,style){
   if(window.getComputedStyle){
       return getComputedStyle(obj)[style];
   }
   return obj.currentStyle[style];
} 
function move(obj,attr,target,step,fn){
   //如果没有建立定时器对象，则在obj下建立定时器对象
   if(!obj.timers){obj.timers = {};}
   //清除定时器
   clearInterval(obj.timers[attr]);
   //声明当前值变量cur
   var cur;
   //判断步长step的正负值
   step = parseInt(getCSS(obj,attr)) &lt; target ? step : -step;
   //开启定时器
   obj.timers[attr] = setInterval(function(){
       //如果样式是透明度
       if(attr == &apos;opacity&apos;){
           //对当前值的取值进行四舍五入，去除由于javascript小数计数中的bug存在的小尾巴
           cur = Math.round(getCSS(obj,attr)*100);
           if((cur - target*100)*step &lt; 0){
               //设置透明度
               obj.style.opacity = (cur + step*100)/100;
               //IE兼容
               obj.style.filter = &apos;alpha(opacity=&apos; + (cur + step*100) + &apos;)&apos;;
           //透明度到达指定目标时
           }else{
               obj.style.opacity = target;
               obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
               //清除定时器
               clearInterval(obj.timers[attr]);
               obj.timers[attr] = 0;
               //设置回调函数
               fn &amp;&amp; fn.call(obj);
           }
       //当样式不是透明度时
       }else{
           //获取样式当前值并赋值给cur
           cur = parseFloat(getCSS(obj,attr));
           ////若步长设置值使得元素超过目标点时，将步长设置值更改为目标点值 - 当前值
           if((cur + step - target)*step &gt; 0){
               step = target - cur;
           }
           //将合适的步长值赋值给元素的样式
           obj.style[attr] = cur + step + &apos;px&apos;;
           //当元素到达目标点后，停止定时器
           if(step == target - cur){
               clearInterval(obj.timers[attr]);
               obj.timers[attr] = 0;
               fn &amp;&amp; fn.call(obj);    
           }
       }        
   },30);        
}
</code></pre><p>【实例】<br>　　下面以一个实例来说明move函数的应用，点击document即可查看效果</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;Document&lt;/title&gt;
   &lt;style&gt;
    div{
     width: 50px;
     height: 50px;
     position: absolute;
     top: 0;
     background-color:lightblue;
    }
    div:nth-child(odd){
      background-color:pink;
    }
   &lt;/style&gt;
  &lt;/head&gt;
 &lt;body&gt;
 &lt;script src=&quot;move.js&quot;&gt;&lt;/script&gt;
 &lt;script&gt;
   var str = &apos;&apos;;
   var len = 10;
   var timer;
   var num = 0;
   for(var i = 0; i &lt; len; i++){
      str+= &apos;&lt;div style=&quot;left:&apos;+60*i+&apos;px;&quot;&gt;&lt;/div&gt;&apos;;
    }
   document.body.innerHTML = str;
   document.onclick = function(){
     var aDiv = document.getElementsByTagName(&apos;div&apos;);
     if(timer) return;
     timer = setInterval(function(){
       move(aDiv[num++],&apos;top&apos;, 200,10,function(){
          var _this = this;
          setTimeout(function(){
            move(_this,&apos;top&apos;, 0,10);
          },1000)
     });
     if(num == len){
       clearInterval(timer);
       num = 0;
       setTimeout(function(){
        timer = 0;
        },2000);
       }
    },100);
   }
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>XML代表可扩展标记语言，是一种比较灵活的数据格式，很多应用程序存储数据都喜欢用到它，结构像HTML，也包含元素，标签以及属性，模型都一样。它的一大优势在于它是一种可扩展的格式，你并不会受制于某种预设的数据结构；并且它还符合DOM标准，使用AJAX调用获取到的数据就像解析HTML一样，通过相应的DOM方法和属性解析它：<br>但是XML的一个严重的缺陷在于它不能用于跨域名的Aiax调用，也就是说每一个Ajax调用的XML数据都必须和执行调用的脚本处于同一域名内，否则请求会失败。<br>HTML存储也相似，它与Ajax结合起来最简单。采用这种方式的数据格式的重要因素是速度，HTML代码段无需在客户端解析就能直接将其输出到DOM之中，所以我们不需要再额外的编写JavaScript代码解析HTML。<br>说说它的缺点，它存储的数据可能和HTML代码混合在一起，所以说可维护性降低。另外在编写处理代码时，开发者可能需要在服务器端做一些精细的控制手段。<br>以下是使用JavaScript进行数据存储的手段，循序渐进…</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p> JavaScript最为基础的数据存储方式，它接受字符串、数值、布尔等。最核心的内容是它的作用域问题。<br>于变量相关的性能问题：<br>  变量在声明完之后，就会被缓存到JavaScript文件中，于是在作用域内就可以反复的使用它们了，获取变量的开销微乎其微，只要数据的使用次数大于1，就应该将其存入变量。<br>数组<br>   数组跟普通数组、关联数组和多维数组，它们都是元素列表，这种形式是各种数据存储中非常灵活的一种。掌握了数组最基本的形式，也会对其他复杂形式的运用大有脾益。数组元素的访问合一处是常见的基本交互代码。鉴于数组这种数据存储类型的重要性，JavaScript为数组交互操作提供了大量的专属方法：<br>.join() 方法 可以指定某个字符作为数组内每个元素的连接符；slice() 方法可以输出数组中某个范围内的元素；shift()和unshift() 方法 分别用于在数组头部移除或新增元素；pop() 方法用于移除并返回数组中的最后一个元素；concat() 方法用于将多个数组拼接成一个数组，按参数的先后而定；sort()方法可以按照字母表顺序或自定义顺序来排列数组的元素.</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>  在数据变得更加复杂、更加难以管理的情况下，我就会选择将数组转换为对象。因为对象的存储方式更加易读。<br>  对象对效率的影响<br>  上面的代码只有一层，然而它是可以无限嵌套的。对象能更好的组织代码，提高模块化的程度。不过与此同时，还是需要考虑性能和可维护性的权衡问题，因为它需要寻找这三者中的一个。如果是运用面向对象编程技术，嵌套达到3层及以上，就会引发性能问题；但是在服务器端运用时就不是这样了，所以前端开发者要决定什么时候使用面向对象编程技术。</p>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>JSON是一种易于同jacascript 集成的数据格式，它通常是在用JavaScript调用外部服务器时使用的。JSON数据存放于独立的文件中，而且通常位于另一台完全不同的服务器上。它现在是最常见的一种调用API服务时所使用的数据格式，人们之所以选中它，是因为此格式非常易于阅读。起初，JSON格式是作为一种XML格式的替代方案而出现的，但很快它就在数据交换领域占据了主流的地位。它是一种轻量级的数据格式，易于通过远程Ajax调用进行跨域名访问。尽管JavaScript对JSON格式的解析提供了原生的支持，但它还是一种独立于平台的格式，客户端与服务器端在数据交换时都可以使用。<br>由于JSON格式具备跨域名访问的能力，所以为了防止一切恶意行为，我们务必只使用从可信的数据源中获取JSON<br>JSON最常见的用途就是配合API调用，在于API为基础的网络程序开发环境中，使用何种后端语言进行开发，数据格式都无需改变.<br>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间，而事件流(又叫事件传播)描述的是从页面中接收事件的顺序。<br>IE的事件流叫做事件冒泡(event bubbling)，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)<br>[注意]所有现代浏览器都支持事件冒泡，但在具体实现在还是有一些差别。IE9、Firefox、Chrome、Safari将事件一直冒泡到window对象</p>
<h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前就捕获它<br>[注意]IE9、Firefox、Chrome、Safari等现代浏览器都支持事件捕获，但是从window对象开始捕获<br>addEventListener()方法中的第三个参数设置为true时，即为事件捕获阶段</p>
<h5 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h5><p>事件流又称为事件传播，DOM2级事件规定的事件流包括三个阶段：事件捕获阶段(capture phase)、处于目标阶段(target phase)和事件冒泡阶段(bubbling phase)<br>首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应<br>事件处理程序又叫事件侦听器，实际上就是事件的绑定函数。事件发生时会执行函数中相应代码。事件处理程序有HTML事件处理程序、DOM0级事件处理程序、DOM2级事件处理程序和IE事件处理程序四类<br>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。<br>事件流<br>eventPhase<br>　　eventPhase属性返回一个整数值，表示事件目前所处的事件流阶段<br>　　0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段<br>　　[注意]IE8-浏览器不支持</p>
<h5 id="如何判断是手机还是电脑访问网站"><a href="#如何判断是手机还是电脑访问网站" class="headerlink" title="如何判断是手机还是电脑访问网站:"></a>如何判断是手机还是电脑访问网站:</h5><p>   现在由于手机功能的强大，使用手机上网的用户越来越多，那么就需要判断用户是用何种客户端登陆的网站，如果使用的是电脑则使用电脑版本的网页，如果使用的手机则使用手机版本的网页，下面是一段能够判断是手机还是电脑的代码：</p>
<pre><code>function check() { 
 var userAgentInfo=navigator.userAgent; 
 var Agents =new Array(&quot;Android&quot;,&quot;iPhone&quot;,&quot;SymbianOS&quot;,&quot;Windows Phone&quot;,&quot;iPad&quot;,&quot;iPod&quot;); 
 var flag=true; 
 for(var v=0;v&lt;Agents.length;v++) { 
    if(userAgentInfo.indexOf(Agents[v])&gt;0) { 
      flag=false; 
      break; 
    } 
  } 
  return flag; 
 }
</code></pre><p>在以上代码中，如果如果flag返回值为true则说明是电脑客户端，如果是false，则说明使用的是移动客户端，代码比较简单这里就不多介绍了，直接套用就可以了.<br>javascript实现的验证码代码实例<br>代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html&gt;
  &lt;head&gt;
   &lt;meta charset=&quot;gbk&quot;&gt;
   &lt;meta name=&quot;author&quot; content=&quot;http://www.108js.com/&quot; /&gt;
   &lt;title&gt;javascript实现的验证码代码实例&lt;/title&gt;
  &lt;/head&gt;
  &lt;style type=&quot;text/css&quot;&gt;
   .code 
   {
    background:url(code_bg.jpg);
    font-family:Arial;
    font-style:italic;
    color:blue;
    font-size:30px;
    border:0;
    padding:2px 3px;
    letter-spacing:3px;
    font-weight:bolder;
    float:left;
    cursor:pointer;
    width:150px;
    height:60px;
    line-height:60px;
    text-align:center;
    vertical-align:middle;
   }
  a 
  {
   text-decoration:none;
   font-size:12px;
   color:#288bc4;
  }
  a:hover 
  {
   text-decoration:underline;
 }
 &lt;/style&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;
 var code;
 function createCode() 
 {
   code = &quot;&quot;;
   var codeLength = 6; //验证码的长度
   var checkCode = document.getElementById(&quot;checkCode&quot;);
   var codeChars = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
            &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,
            &apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,
            &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, 
            &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;);
             //所有候选组成验证码的字符，当然也可以用中文的
  for(var i = 0; i &lt; codeLength; i++) 
  {
    var charNum = Math.floor(Math.random() * 52);
    code += codeChars[charNum];
  }
  if(checkCode) 
  {
    checkCode.className = &quot;code&quot;;
    checkCode.innerHTML = code;
  }
 }
 function validateCode() 
 {
   var inputCode=document.getElementById(&quot;inputCode&quot;).value;
   if(inputCode.length &lt;= 0) 
   { 
     alert(&quot;请输入验证码！&quot;);
   }
   else if(inputCode.toUpperCase() != code.toUpperCase()) 
   { 
     alert(&quot;验证码输入有误！&quot;);
     createCode();
   }
   else 
   {
    alert(&quot;验证码正确！&quot;);
  }        
 }    
 &lt;/script&gt;
 &lt;body onload=&quot;createCode()&quot;&gt;
  &lt;form id=&quot;form1&quot; runat=&quot;server&quot; onsubmit=&quot;validateCode()&quot;&gt;
   &lt;div&gt;
    &lt;table border=&quot;0&quot; cellspacing=&quot;5&quot; cellpadding=&quot;5&quot; &gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;&lt;div class=&quot;code&quot; id=&quot;checkCode&quot; onclick=&quot;createCode()&quot; &gt;&lt;/div&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#&quot; onclick=&quot;createCode()&quot;&gt;看不清换一张&lt;/a&gt;&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td&gt;验证码：&lt;/td&gt;
       &lt;td&gt;&lt;input style=&quot;float:left;&quot; type=&quot;text&quot; id=&quot;inputCode&quot; /&gt;&lt;/td&gt;
       &lt;td&gt;请输入验证码&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;td&gt;&lt;/td&gt;
       &lt;td&gt;&lt;input id=&quot;Button1&quot; onclick=&quot;validateCode();&quot; type=&quot;button&quot; value=&quot;确定&quot; /&gt;&lt;/td&gt;
       &lt;td&gt;&lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/div&gt;
  &lt;/form&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>js拖拽DIV到页面任何位置<br>js拖拽到页面任何位置</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;Document&lt;/title&gt;
 &lt;style&gt;
   #main{width:100px;height:100px;background:#ffccff;position:absolute;}
 &lt;/style&gt;
 &lt;script&gt;
  /*1：拖拽的时候有文字选中会有问题；
          原因：这是浏览器的默认拖拽文字的行为
          解决方案：标准浏览器下：阻止默认行为,在onmousedown结尾加上return false即可
                    ie8及其以下版本：设置全局捕获，方法如下设置全局捕获setCapture最后释放releaseCapture*/
       window.onload = function(){
           var oDiv = document.getElementById(&quot;main&quot;);
           var odiv = document.getElementById(&quot;div&quot;);
           oDiv.onmousedown = function(ev){

                   var ev = ev || event;
                   var disX = ev.clientX - this.offsetLeft;
                   var disY = ev.clientY - this.offsetTop;

                   if(oDiv.setCapture){
                     oDiv.setCapture();
                   }
                document.onmousemove = function(ev){
                    //这里为什么使用document，是因为快速拖拽的话会鼠标丢失，
                    var ev = ev || event;
                    oDiv.style.left = ev.clientX - disX+&quot;px&quot;;
                    oDiv.style.top = ev.clientY - disY+&quot;px&quot;;
                }

                document.onmouseup = function(ev){
                    document.onmousemove = document.onmouseup = null;
                    //为何不用oDiv.onmouseup是因为被挡住之后会无视掉遮挡的元素
                    if(oDiv.releaseCapture){

                      oDiv.releaseCapture();
                    }
                }
                return false;
           }
       }
   &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    2015/11/17wf r3qr
   &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰<br>另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。<br>所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。<br>web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题!<br>前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse<em>*</em>等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控.<br>利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理.<br>有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.<br>下面是一个小例子，若我们要对divMain这个div元素里面的内容进行保护:<br>1.对divMain执行setCapture方法:<br>document.getElementById(“divMain”).setCapture()；<br>2.加入一按钮btnChange，可以进行setCapture和releaseCapture切换，定义一全局变量；<br>var isFreeze = true；<br>3.在btnChange的onclick事件中，加入下列代码:<br>代码如下:</p>
<pre><code>function change_capture(obj) { 
isFreeze = !isFreeze; 
if(isFreeze) { 
obj.value = &quot;releaseCapture&quot;; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
obj.value = &quot;setCapture&quot;; 
alert(&apos;保存！&apos;); //可以执行重要操作 
document.getElementById(&quot;divMain&quot;).releaseCapture(); 
} 
} 

divMain的onclick事件中，加入下列代码: 
复制代码 代码如下:

function click_func() 
{ 
if(event.srcElement.id == &quot;divMain&quot;) 
{ 
alert(&quot;处理中...&quot;)； //常规操作 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
else 
{ 
if(isFreeze &amp;&amp; event.srcElement.id != &quot;btnChange&quot;) 
{ 
alert(&apos;未执行releaseCapture，不能点击&apos;)； 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
} 
} 
</code></pre><p>对ALT+F4进行处理，在body的onkeydown事件中加入下列代码:<br>代码如下:</p>
<pre><code>function keydown_func() 
{ 
if (event.keyCode==115 &amp;&amp; event.altKey) //ALT+F4 
{ 
if(isFreeze) 
{ 
alert(&apos;保存！&apos;)； //可以执行重要操作 
} 
//window.showModelessDialog(&quot;about:blank&quot;，&quot;&quot;，&quot;dialogWidth:1px；dialogheight:1px&quot;)； 
//return false； 
} 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
</code></pre><p>完整代码如下: </p>
<pre><code>&lt;html&gt; 
&lt;head&gt; 
&lt;title&gt; 
setCapture和releaseCapture的小应用 
&lt;/title&gt; 
&lt;script&gt; 
&lt; !-- 
var isFreeze = true; 
function click_func() { 
if (event.srcElement.id == &quot;divMain&quot;) { 
alert(&quot;处理中...&quot;); //常规操作 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
if (isFreeze &amp;&amp; event.srcElement.id != &quot;btnChange&quot;) { 
alert(&apos;未执行releaseCapture,不能点击&apos;); 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} 
} 
} 
function keydown_func() { 
if (event.keyCode == 115 &amp;&amp; event.altKey) //ALT+F4 
{ 
if (isFreeze) { 
alert(&apos;保存！&apos;); //可以执行重要操作 
} 
//window.showModelessDialog(&quot;about:blank&quot;,&quot;&quot;,&quot;dialogWidth:1px;dialogheight:1px&quot;); 
//return false; 
} 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} 
function change_capture(obj) { 
isFreeze = !isFreeze; 
if (isFreeze) { 
obj.value = &quot;releaseCapture&quot;; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
obj.value = &quot;setCapture&quot;; 
alert(&apos;保存！&apos;); //可以执行重要操作 
document.getElementById(&quot;divMain&quot;).releaseCapture(); 
} 
} 
//--&gt; 
&lt;/script&gt; 
&lt;/head&gt; 
&lt;body onkeydown=&quot;keydown_func();&quot;&gt; 
&lt;div id=&quot;divMain&quot; onclick=&quot;click_func();&quot;&gt; 
点一下IE的菜单或者按钮看看:) 又或者IE窗口外的地方 
&lt;input type=&quot;button&quot; value=&quot;releaseCapture&quot; onclick=&quot;change_capture(this);&quot; 
id=&quot;btnChange&quot;&gt; 
&lt;script language=&quot;javascript&quot;&gt; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
&lt;/script&gt; 
&lt;/div&gt; 
&lt;/body&gt; 
&lt;/html&gt; 
</code></pre><p>关于javascript中call和apply函数的应用<br>我们经常在javascipt中的面向对象应用中遇到call和apply函数；有时会被搞糊涂。其实它们可以改变函数或对象中的this保留字的值；this保留字的默认值就是这个类本身。举例说明：<br>代码如下:</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 
&lt;head&gt; 
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html； charset=gb2312&quot; /&gt; 
&lt;script language=&quot;javascript&quot;&gt; 
test = { 
value: &apos;default&apos;，exec: function() { 
alert(this.value)； 
} 
} 
function hhh(obj) { 
test.exec()；test.exec.apply(obj)； 
} 
&lt;/script&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;input type=&quot;button&quot; onclick=&quot;hhh(this)；&quot; value=&quot;test&quot; /&gt; 
&lt;/body&gt; 
&lt;/html&gt; 
</code></pre><p>运行以上的页面就很快明白了.<br>call和apply函数可以处理匿名函数<br>关于类的初始化应用如下：<br>代码如下:</p>
<pre><code>Person = function() { 
this.Init.apply(this, arguments); 
}; 
Person.prototype = { 
first: null, 
last: null, 
Init: function(first, last) { 
this.first = first; 
this.last = last; 
}, 
fullName: function() { 
return this.first + &apos; &apos; + this.last; 
}, 
fullNameReversed: function() { 
return this.last + &apos;, &apos; + this.first; 
} 
}; 
var s = new Person2(&apos;creese&apos;, &apos;yang&apos;); 
alert(s.fullName()); 
alert(s.fullNameReversed()); 
</code></pre><p>call和apply函数可以赋值函数内容（带匿名参数；但不触发）<br>关于函数绑定事件应用如下：<br>代码如下:</p>
<pre><code>Function.prototype.BindForEvent = function() { 
var __m = this， object = arguments[0]， args = new Array()； 
for(var i = 1； i &lt; arguments.length； i++){ 
args.push(arguments[i])； 
} 
return function(event) { 
return __m.apply(object， [( event || window.event)].concat(args))； 
} 
} 
</code></pre><p>call和apply函数关于函数绑定参数应用如下：<br>代码如下:</p>
<pre><code>Function.prototype.Bind = function() { 
var __m = this， object = arguments[0]， args = new Array()； 
for(var i = 1； i &lt; arguments.length； i++){ 
args.push(arguments[i])； 
} 
return function() { 
return __m.apply(object， args)； 
} 
} 
</code></pre><p>call和apply函数功能是一样的；就是参数格式不同；fun.call(obj， arguments)；apply的arguments是数组形式；call则是单数形式。<br>screen对象通常包含下列属性(许多浏览器都加入了自己的属性)：<br> 1.availHeight : 窗口可以使用的屏幕的高度（以像素计）其中包括操作系统元素（如window工具栏）需要的空间。<br> 2.availWidth : 窗口可以使用的屏幕的宽度（以像素计）。<br> 3.colorDepth : 用户表示的颜色的位数，大多数系统采用32位的。<br> 4.height ：屏幕的高度，以像素计算。<br> 5.width ： 屏幕的宽度，以像素计算。<br>确定新窗口的大小时，availHeight和availWidth属性比较有用。比如可以用下面的代码填充用户的屏幕：<br>  window.moveTo(0,0);<br>  window.resizeTo(screen.availWidth,screen.availHeight);<br>另外，这些数据与站点的流量工具一起使用，可以判断用户的图形接受能力。<br>div应该是division的缩写吧！！！！</p>
<h5 id="任选一题（5分）a-ul、ol、dl的区别？b-div、section、article的区别？"><a href="#任选一题（5分）a-ul、ol、dl的区别？b-div、section、article的区别？" class="headerlink" title="任选一题（5分）a) ul、ol、dl的区别？b) div、section、article的区别？"></a>任选一题（5分）<br>a) ul、ol、dl的区别？<br>b) div、section、article的区别？</h5><p>a: ul是无序列表，ol是有序列表，dl是定义列表有层次关系。<br>b: div无语义，只是用作布局。<br> section是有一定语义的div，表示一个专题，一般有标题，但是不可以乱用。只有内容明确需要出现在大纲中时才会使用。<br> artical是更特殊的section，他是一个独立完整的内容块。比如用在文章，评论等。</p>
<h5 id="html5对input新增了哪些高级属性？（5分）"><a href="#html5对input新增了哪些高级属性？（5分）" class="headerlink" title="html5对input新增了哪些高级属性？（5分）"></a>html5对input新增了哪些高级属性？（5分）</h5><p>number ,date,color,range,email,search,tel,url</p>
<h5 id="每题都需回答（15分）a-如何用CSS控制文本单行溢出省略？并且大致说出多行省略的思路。b-谈谈响应式布局？c-CSS3有哪些高级选择器？"><a href="#每题都需回答（15分）a-如何用CSS控制文本单行溢出省略？并且大致说出多行省略的思路。b-谈谈响应式布局？c-CSS3有哪些高级选择器？" class="headerlink" title="每题都需回答（15分）a) 如何用CSS控制文本单行溢出省略？并且大致说出多行省略的思路。b) 谈谈响应式布局？c) CSS3有哪些高级选择器？"></a>每题都需回答（15分）<br>a) 如何用CSS控制文本单行溢出省略？并且大致说出多行省略的思路。<br>b) 谈谈响应式布局？<br>c) CSS3有哪些高级选择器？</h5><p>a:css实现单行溢出省略是利用text-overflow：ellipsis，white-space：nowrap和overflow：hidden属性实现的。<br>（新版主流浏览器测试通过）<br>b:响应式布局是为了解决现在市场上的浏览器尺寸不一的现状，让用户无论是使用移动端还是电脑端访问都有很好体验。html5也因此加入了媒体查询等一系列针对响应式布局的新元素。<br>c:css3有属性选择器{E[att$=’val’],E[att~=’val’],E[att^=’val’]}<br>伪类选择器{E:not(),E:last-child,E:only-child,E:nth-child(n),E:nth-last-child(),E:empty}<br>伪对象选择器{E::selection}<br>关系选择器{E~F}</p>
<h5 id="请逐一解释他们："><a href="#请逐一解释他们：" class="headerlink" title="请逐一解释他们："></a>请逐一解释他们：</h5><p>Node.js、React Native、Angular.js、Grunt/Gulp、Webpack、Git、JSONP（10分）<br>Node.js:<br>Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。<br>React Native:<br>React Native 结合了Web应用和Native应用的优势，可以使用JavaScript来开发iOS和Android原生应用。在JavaScript中用 React抽象操作系统原生的UI组件，代替DOM元素来渲染等。<br>Angular.js: （它有坑吗？？？？）<br>AngularJS诞生于2009年，由Misko Hevery等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。<br>Grunt/Gulp:<br>自动构建系统，开发者可以使用它在网站开发过程中自动执行常见任务。<br>Webpack：<br>是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。<br>Git：<br>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。·<br>JSONP：<br>为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端， 然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<h5 id="分别说出下述输出结果（15分）"><a href="#分别说出下述输出结果（15分）" class="headerlink" title="分别说出下述输出结果（15分）"></a>分别说出下述输出结果（15分）</h5><pre><code>!function(){
  this.length = 10;
  var fn = function(){
    console.log(this.length);//输出多少？?输出2,this指向数组arr
    console.log(this[1]);//输出多少？输出&quot;hello layui&quot;
  }, arr = [fn, &apos;hello layui&apos;];
  fn.length = 100;
  arr[0]();
}();
</code></pre><h5 id="封装一个cont方法，能实现如此调用："><a href="#封装一个cont方法，能实现如此调用：" class="headerlink" title="封装一个cont方法，能实现如此调用："></a>封装一个cont方法，能实现如此调用：</h5><pre><code>cout(a)(b)(c)(d)(e)… 并且返回的值为参数连剩的结果，即a*b*c*d*e*…。如cout(1)(3)(7) 得到21 （15分）
init=0;  //设置一个全局变量
var muti=function(m)
{
   init=init*m;
   return muti
 }

 muti.toString=function()  //这是关键的一步
 {
     return init;
  }

  function count(m)  //最终我们要调用的函数
  {
     init=m ;// 初始化，否则init是0，那么永远乘 都是 0，也是很关键的一步
     return muti;//最终返回的是 元对象（不是实例化过后的对象哦)
  }
  alert(count(3)(4)(5))
</code></pre><h5 id="任选一题（15分）a-谈谈你对模块化开发的理解？b-你认为什么是更科学效率的组件化？c-ES6有哪些你觉得不错的特性？"><a href="#任选一题（15分）a-谈谈你对模块化开发的理解？b-你认为什么是更科学效率的组件化？c-ES6有哪些你觉得不错的特性？" class="headerlink" title="任选一题（15分）a) 谈谈你对模块化开发的理解？b) 你认为什么是更科学效率的组件化？c) ES6有哪些你觉得不错的特性？"></a>任选一题（15分）<br>a) 谈谈你对模块化开发的理解？<br>b) 你认为什么是更科学效率的组件化？<br>c) ES6有哪些你觉得不错的特性？</h5><h5 id="任选一题（20分）a-实现一个手势滑动轮播图，可以直接用代码表述，也可以只说说思路。b-大致描述如何实现一个基于Express的MVC框架？"><a href="#任选一题（20分）a-实现一个手势滑动轮播图，可以直接用代码表述，也可以只说说思路。b-大致描述如何实现一个基于Express的MVC框架？" class="headerlink" title="任选一题（20分）a) 实现一个手势滑动轮播图，可以直接用代码表述，也可以只说说思路。b) 大致描述如何实现一个基于Express的MVC框架？"></a>任选一题（20分）<br>a) 实现一个手势滑动轮播图，可以直接用代码表述，也可以只说说思路。<br>b) 大致描述如何实现一个基于Express的MVC框架？</h5><h5 id="scrollWidth-clientWidth-offsetWidth的区别-http-www-108js-com-article-article2-20130-html-id-2380"><a href="#scrollWidth-clientWidth-offsetWidth的区别-http-www-108js-com-article-article2-20130-html-id-2380" class="headerlink" title="scrollWidth,clientWidth,offsetWidth的区别 http://www.108js.com/article/article2/20130.html?id=2380"></a>scrollWidth,clientWidth,offsetWidth的区别 <a href="http://www.108js.com/article/article2/20130.html?id=2380" target="_blank" rel="external">http://www.108js.com/article/article2/20130.html?id=2380</a></h5><p>（scrollHeight、offsetHeight、clientHeight 同样可按本文去理解。）<br>这是一个很复杂的问题，让我们想像一下：<br>document.documentElement.scrollWidth<br>document.documentElement.offsetWidth<br>document.documentElement.clientWidth<br>document.body.scrollWidth<br>document.body.offsetWidth<br>document.body.clientWidth<br>有 6 个属性要测，这 6 个属性要放在 4 种情况中：<br>没有指定 DOCTYPE，网页内容没有超过窗口宽度；<br>没有指定 DOCTYPE，网页内容超过窗口宽度；<br>指定 DOCTYPE，网页内容没有超过窗口宽度；<br>指定 DOCTYPE，网页内容超过窗口宽度；<br>然后这 4 种情况要放到几个主流浏览器中，假设只有 3 种浏览器：<br>IE<br>Firefox<br>Chrome<br>算一下，<code>6 * 4 * 3</code>，有 72 种情况要测试，天啊。并且不要指望 Firefox 和 Chrome 结果是一样的，不要指望 Firefox 不会出现让您费解的结果，所以这真是一件恼火的事。<br>从应用入手简化分析<br>72 种测试情况确实很恼火，但我们回过头来一想，我们到底想要什么？<br>我认为我们想要两个东西：<br>   一是 scrollWidth（scrollHeight），虽然它用处不大，但应该比 offsetWidth（offsetHeight）有用得多。它表示的是文档区的宽度（高度），比如一个网页，特别是门户网站，拖很长，就要把没有显示出来的内容都计算进去。<br>   二是视口 viewport，就是clientWidth，就是窗口中可显示内容的那块区域，就是我们常常看到页面上飞行广告，飞来飞去，碰到边边要反弹的那一块。<br>测试结果<br>   结果很复杂，就不说了(请下载测试代码），这里只说实际中怎么使用：<br>要使用 scrollWidth，取 document.documentElement.scrollWidth 与 document.body.scrollWidth 的最大值；<br>要使用 clientWidth，如果 document.documentElement.clientWidth &gt; 0，则使用 document.documentElement.clientWidth，否则使用 document.body.clientWidth。<br>表达式为：<br>  var scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);<br>  var clientWidth = document.documentElement.clientWidth || document.body.clientWidth<br>Javascript引擎是单线程运行的，浏览器只有一个线程在运行JavaScript程序。因为单线程的设计，所以免去了复杂的多线程同步问题。<br>当设置一个定时的时候，浏览器会在设定的时间后将你指定的回调函数插入任务序列，而非立即执行。如果设定定时时间为0，表示立即插入任务序列，而不是立即执行，仍然要等队列中任务执行完毕，轮到你，你才执行。<br>彻底弄清offset<br> <a href="http://www.108js.com/article/article2/20064.html?id=719" target="_blank" rel="external">http://www.108js.com/article/article2/20064.html?id=719</a><br> <a href="http://www.108js.com/article/article2/20063.html?id=718" target="_blank" rel="external">http://www.108js.com/article/article2/20063.html?id=718</a><br> JS对用户隐藏源代码</p>
<pre><code> &lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;例20.4 对用户隐藏源代码&lt;/title&gt;
  &lt;script&gt;
&lt;!--
   function clear(){
    Source=document.body.firstChild.data;
    //这段代码里我们看到一个新鲜的属性--data
    //它引用一个COMMENT_NODE类型的DOM对象的文本内容
    //这里用到了一个技巧，实际上我们把body的内容整个构建为一个COMMENT_NODE
    //然后用data取出内容再回写入body的innerHTML，其结果就是，在页面上
    //用鼠标右键查看源代码的时候查看不到body中的任何源代码
    document.open();
    document.close();
    document.title=&quot;&quot;;
    document.body.innerHTML=Source;
   }
--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=clear()&gt;
&lt;!--
  &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;770&quot; height=&quot;200&quot;&gt;
   &lt;tr&gt;
    &lt;td&gt;看看能不能看到源代码&lt;/td&gt;
   &lt;/tr&gt;
  &lt;/table&gt;
--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>JS浏览器检测代码</p>
<pre><code>&lt;html&gt;
&lt;title&gt;浏览器检测&lt;/title&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;

 function isIE(){   
  return navigator.appName.indexOf(&quot;Microsoft Internet Explorer&quot;)!=-1 &amp;&amp; document.all;   
 }   
 function isIE6() {   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 6.0&quot;)==&quot;-1&quot;?false:true;   
 }   
 function isIE7(){   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 7.0&quot;)==&quot;-1&quot;?false:true;   
 }   

 function isIE8(){   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 8.0&quot;)==&quot;-1&quot;?false:true;   
 }   
 function isNN(){   
   return navigator.userAgent.indexOf(&quot;Netscape&quot;)!=-1;   
 }   
 function isOpera(){   
   return navigator.appName.indexOf(&quot;Opera&quot;)!=-1;   
 }   
  function isFF(){   
   return navigator.userAgent.indexOf(&quot;Firefox&quot;)!=-1;   
  }   
  function isChrome(){   
    return navigator.userAgent.indexOf(&quot;Chrome&quot;) &gt; -1;     
   } 

  function showResult(){        
    if(isChrome()){
     alert(&quot;这是谷歌浏览器&quot;);    
    }

    if(isIE()){
     alert(&quot;这是IE&quot;);
    }

    if(isIE6()){
     alert(&quot;这是isIE6&quot;);
    }

    if(isIE7()){
     alert(&quot;这是isIE7&quot;);
    }

    if(isIE8()){
     alert(&quot;这是IisIE8&quot;);
     }

    if(isNN()){
     alert(&quot;这是isNN&quot;);
    }

    if(isOpera()){
     alert(&quot;这是isOpera&quot;);
     }

    if(isFF()){
     alert(&quot;这是Firefox&quot;);
    }
  }

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;center&gt;&lt;input type=&quot;button&quot; onclick=&quot;showResult()&quot; name=&quot;check&quot; value=&quot;检测&quot;&lt;/center&gt;
&lt;/body&gt;&lt;/html&gt;

javaScript防盗链代码

&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;防止盗链&lt;/title&gt;
  &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
   &lt;!--
    //当前文档的URL
    var currentURL = document.URL;
    //上一个文档的URL
    var frontURL = document.referrer;
    //如果上一个文档的URL为空，则是直接打开当前文档，则不存在盗链的问题。否则有可能是盗链。
    if (frontURL!=&quot;&quot;)
    {
     //通过分割，将当前文档的URL各部分存放在currentURLs数组中。
     var currentURLs = currentURL.split(&quot;/&quot;);
     //通过分割，将上一个文档的URL各部分存放在frontURLs数组中。
     var frontURLs = frontURL.split(&quot;/&quot;);
     //两个数组的第3个元素都为URL的域名部分
     //比较两个数组的第3个元素，如果域名相同，则不是盗链，否则就是盗链
     if (currentURLs[2]==frontURLs[2])
     {
      document.write(&quot;不是盗链，可以显示正常文档&quot;);
     }
     else
     {
      document.write(&quot;您不是从本站中访问到该网址，请通过本部访问&quot;);
      //可以使用以下代码跳转到网站的首页
      //history.location = &quot;http://&quot; + currentURLs[2];
     }
    }
    else
    {
     document.write(&quot;您是直接打开该文档的，不存在盗链问题&quot;);
    }
   --&gt;
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      

      
        <div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode"></div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/07/25/js集锦(中) /" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          上一篇：js集锦（中）
        
      </div>
    </a>
  
  
    <a href="/2016/07/03/Git和Github错误汇总/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">下一篇：Git和Github错误汇总</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="js集锦(上)" data-title="js集锦(上)" data-url="http://yoursite.com/2016/07/12/js集锦(上)/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
	
</script>
<script src="/./js/jquery-1.10.2.min.js"></script>
<script src="/./js/main.js"></script>
<script src="/./js/myJs.js"></script>



    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Git/" style="font-size: 16px;">Git</a> <a href="/tags/Github/" style="font-size: 12px;">Github</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/essay/" style="font-size: 10px;">essay</a> <a href="/tags/hexo/" style="font-size: 12px;">hexo</a> <a href="/tags/html/" style="font-size: 14px;">html</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/jade/" style="font-size: 12px;">jade</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/jquery/" style="font-size: 18px;">jquery</a> <a href="/tags/js/" style="font-size: 16px;">js</a> <a href="/tags/karma/" style="font-size: 10px;">karma</a> <a href="/tags/life/" style="font-size: 20px;">life</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/swiftype/" style="font-size: 10px;">swiftype</a> <a href="/tags/yilia/" style="font-size: 10px;">yilia</a> <a href="/tags/科研/" style="font-size: 10px;">科研</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div> 
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
    
  </div>
</body>
</html>