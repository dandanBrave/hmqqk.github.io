<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/myStyle.css">
  

  
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">

		<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
			<input type="text" id="st-search-input" class="st-search-input_my" maxlength="30" placeholder="搜一搜" />
		</form>
	
	<header id="header" class="inner">
		<a href="/categories/myPage/myPage.html" class="profilepic">
			
			<img src="/images/title.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/categories/myPage/myPage.html">轻刻美</a></h1>
		</hgroup>

		
		<p class="header-subtitle">因上努力,果上随缘</p>
		
		
		<nav class="header-menu">
			<ul>
			
				<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
	        
				<li><a href="/">所有文章</a></li>
	        
				<li><a href="/categories/studies">学习</a></li>
	        
				<li><a href="/categories/lives">生活</a></li>
	        
				<li><a href="/categories/essays">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/hmqqk/hmqqk.github.io" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">轻刻美</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/title.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">轻刻美</h1>
			</hgroup>
			
			<p class="header-subtitle">因上努力,果上随缘</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/categories/myPage/myPage.html">我的小窝</a></li>
		        
					<li><a href="/">所有文章</a></li>
		        
					<li><a href="/categories/studies">学习</a></li>
		        
					<li><a href="/categories/lives">生活</a></li>
		        
					<li><a href="/categories/essays">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hmqqk/hmqqk.github.io" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5738673016/home?wvr=5" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/hmqqk/activities" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:2442501113@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-js集锦(下)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/js集锦(下)/">js集锦（中）</a>
    </h1>
  

        <a href="/2016/12/14/js集锦(下)/" class="archive-article-date">
  	<time datetime="2016-12-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javaScript中的装箱和拆箱 <a href="http://www.108js.com/article/article1/10034.html?id=175" target="_blank" rel="external">http://www.108js.com/article/article1/10034.html?id=175</a></p>
<p>javaScript中的Object.valueOf()方法 <a href="http://www.108js.com/article/article1/10108.html?id=732" target="_blank" rel="external">http://www.108js.com/article/article1/10108.html?id=732</a></p>
<p>我的问题依然是（+Var）到底代表什么意思？</p>
<p>答案：变量前加上+后，变量将转换为数字，进行数字运算。比如：<br> var x = “3”;<br> var y = x + 10; // 310<br> var z = +x + 10 // 13</p>
<p>  赋予x值为3，y=x + 3，运算结果为310，其中的+号为连接作用，这不难理解。z=+x + 10，运算结果为13，这是将+x的值3与后方的10做数字运算，所以结果13，这就是+var的用意。</p>
<p> Javascript面向对象编程（三）：非构造函数的继承<br>   这个系列的第一部分介绍了”封装”，第二部分介绍了使用构造函数实现”继承”。<br>今天是最后一个部分，介绍不使用构造函数实现”继承”。<br>一、什么是”非构造函数”的继承？<br>比如，现在有一个对象，叫做”中国人”。<br>　 var Chinese = {<br>　   nation:’中国’<br>  };</p>
<p>还有一个对象，叫做”医生”。<br>  var Doctor ={<br>    career:’医生’<br>  }</p>
<p>   请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？<br>   这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<p>二、object()方法<br>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。<br> function object(o) {<br>   function F() {}<br>   F.prototype = o;<br>   return new F();<br> }</p>
<p>  这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。<br>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<p>  var Doctor = object(Chinese);</p>
<p>然后，再加上子对象本身的属性：<br>  Doctor.career = ‘医生’;</p>
<p>这时，子对象已经继承了父对象的属性了。<br>  alert(Doctor.nation); //中国</p>
<p>三、浅拷贝<br>  除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。<br>下面这个函数，就是在做拷贝：<br> function extendCopy(p) {<br>  var c = {};<br>  for (var i in p) {<br>    c[i] = p[i];<br>  }<br>  c.uber = p;<br>  return c;<br> }</p>
<p>使用的时候，这样写：<br>  var Doctor = extendCopy(Chinese);<br>  Doctor.career = ‘医生’;<br>  alert(Doctor.nation); // 中国</p>
<p>  但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。<br> Chinese.birthPlaces = [‘北京’,’上海’,’香港’];</p>
<p>通过extendCopy()函数，Doctor继承了Chinese。<br> var Doctor = extendCopy(Chinese);</p>
<p>然后，我们为Doctor的”出生地”添加一个城市：<br> Doctor.birthPlaces.push(‘厦门’);</p>
<p>发生了什么事？Chinese的”出生地”也被改掉了！<br> alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门<br> alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门<br>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<p>四、深拷贝<br>  所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。<br>  function deepCopy(p, c){<br>    var c = c || {};<br>    for (var i in p){<br>     if (typeof p[i] === ‘object’){<br>      c[i] = (p[i].constructor === Array) ? [] : {};<br>      deepCopy(p[i], c[i]);<br>     }else{<br>      c[i] = p[i];<br>　　 }<br>   }<br>   return c;<br>  }</p>
<p>使用的时候这样写：<br>　 var Doctor = deepCopy(Chinese);</p>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：<br>　 Chinese.birthPlaces = [‘北京’,’上海’,’香港’];<br>   Doctor.birthPlaces.push(‘厦门’);</p>
<p>这时，父对象就不会受到影响了。<br>alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门<br>alert(Chinese.birthPlaces); //北京, 上海, 香港<br>目前，jQuery库使用的就是这种继承方法。</p>
<p>prototype.js中创建类的方式<br>各种库的写类方式虽然千奇百怪，但仍然逃离不了本质—用构造函数和原型来组装类。<br>一、prototype.js中的代码<br> var Class = {<br>  create: function() {<br>   return function() {<br>     this.initialize.apply(this, arguments);<br>   }<br>  }<br>}<br>//简化后的<br> function Clazz() {<br>   return function(){<br>    this.initialize.apply(this,arguments);<br> }<br>} </p>
<p>Class用来创建一种类型，注意其属性create是一个方法，返回一个构造函数。 一般使用如下：</p>
<p> var X = Class.create(); </p>
<p>   返回一个类型，类似于java的一个Class实例。要使用X类型，需继续用new X()来获取一个实例，如同java的Class.newInstance()方法。 返回的构造函数会执行名为initialize的方法，此时initialize方法还没有定义，其后的代码中创建新类型时会建立相应的同名方法。<br>  Class.create实际上是返回一个函数，那么new的时候，做了些什么呢。new的时候会执行该返回的函数，即执行<br>   this.initialize.apply(this, arguments);<br>此时的this就是新生成的对象，这也就是说了所有对象的初始化工作全部委托给initialize函数了。</p>
<p>二、怎样写一个类</p>
<p>//类名Person<br>//这里得到的是Person的initialize调用, 所以是Person.initialize(arguments)<br>//相当于构造函数persion(name){ this.name=name }<br> var Person = Class.create();<br>//通过原型重写来定义Person<br>Person.prototype = {<br> initialize : function(name) {<br>  this.name = name;<br> },<br> getName : function() {<br>   return this.name;<br> },<br> setName : function(name) {<br>   this.name = name;<br> }<br>}<br>//创建对象<br> var p = new Person(“jack”);<br> alert(p.getName());<br> alert(p.constructor == Person);//false<br>  initialize完成对象的初始化（相当于构造函数），方法依次往下写即可。 有个问题，通过这句p.constructor == Person为false可以看到，这正是Prototype.js一个小小的缺陷。原因是重写了Person的原型。为了使constructor能指向正确的构造器，只需在原型重写时维护好constructor属性即可。</p>
<p> Person.prototype = {<br>  constructor : Person,//注意这里<br>  initialize : function(name) {<br>    this.name = name;<br>  },<br>  getName : function() {<br>    return this.name;<br>  },<br>  setName : function(name) {<br>    this.name = name;<br>  }<br> }</p>
<p>好了，这时候p.constructor == Person就是true了。</p>
<p>Js函数声明与函数表达式之区别</p>
<p>在定义函数时，我们一般使用下面这两种方法：<br>使用函数声明定义：<br> function sum (a, b) {<br>   return a + b;<br> }</p>
<p>  使用函数表达式定义：<br>  var sum = function (a, b) {<br>    return a + b;<br>  }</p>
<p>调用方法都是一样的：如求“1+1”等于几：<br>   alert(sum(1, 1)); </p>
<p>  但这两种方法还是有区别的。解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<p>示例：<br>  alert(sum(1, 1));<br>  function sum (a, b) {<br>    return a + b;<br>  }<br>   以上代码可以正常执行。因为在代码执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。在对代码求值时，Javascript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码放到了调用它的代码的后面，Javascript 引擎也能把函数声明提升到顶部。如果像下面例子所示，把上面的函数声明改为函数表达式，就会在执行期间导致错误。</p>
<p>  alert(sum(1, 1));<br>  var sum = function (a, b) {<br>   return a + b;<br>  }</p>
<p>  以上代码之所以会在执行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum不会保存有对函数的引用，并且第一行代码已经产生错误，也就不会执行到下一行。</p>
<p>总体来说，除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>通常我们会看到以下两种定义函数的方式：<br> // 函数语句<br> function fn(str)<br> {<br>  console.log(str);<br> };</p>
<p> // 表达式定义<br> var fnx=function(str)<br> {<br>   console.log(str+ ‘ from fnx’);<br> };</p>
<p>   以前都是凭借自己手指的感觉随心所欲使用两者 -_- || ，今天看了js基础，总算是解决了心中对他们的困惑：<br>   两种方式都创建了新的函数对象， 但函数声明语句的函数名是一个变量名，变量指向函数对象，和通过var声明变量一样，函数定义语句中的函数被显示地提前到了脚本或函数的顶部，因此它们在整个脚本和函数内都是可见的，但是使用var表达式定义函数，只有变量声明提前了，变量初始化代码仍然在原来的位置，用函数语句创建的函数，函数名称和函数体均被提前，所以我们可以在声明它之前就使用它。</p>
<p>代码例子如下:<br>  console.log(typeof(fn)); // function<br>  fn(‘abc’); // abc</p>
<p>  console.log(typeof(fnx)); // undefined</p>
<p>  if(fnx)<br>    fnx(‘abc’); // will not execute<br>  else<br>    console.log(‘fnx is undefined’); // fnx is undefined</p>
<p> // 函数语句<br> function fn(str)<br> {<br>   console.log(str);<br>  };</p>
<p>  // 表达式定义<br>   var fnx=function(str)<br>   {<br>    console.log(str+ ‘ from fnx’);<br>   };<br> 代码很简单， 希望和我之前一样没有弄明白两者区别的同学能有所收获 。</p>
<p> 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)，流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<p>javaScript中克隆对象的三种方法</p>
<p>方法1 （点击查看结果）<br>function clone(obj){<br>   var o;<br>   if(typeof obj == “object”){<br>      if(obj === null){<br>        o = null;<br>      }else{<br>        if(obj instanceof Array){<br>          o = [];<br>          for(var i = 0, len = obj.length; i &lt; len; i++){<br>            o.push(clone(obj[i]));<br>          }<br>        }else{<br>          o = {};<br>          for(var k in obj){<br>             o[k] = clone(obj[k]);<br>          }<br>        }<br>     }<br>   }else{<br>     o = obj;<br>   }<br>  return o;<br> }</p>
<p> //测试<br>  var parent = {<br>   data: {<br>    name: ‘jack’,<br>    age: 30,<br>    isMarried: false<br>   },<br>   language: [‘Java’],<br>   show:function(){ return “ok” ;}<br>  }<br>  var Cparent=clone(parent);<br>  alert(Cparent.data.age);<br>  alert(Cparent.language[0]);<br>  alert(Cparent.show());<br>方法2：（点击查看结果）<br>function clone(obj){<br>    var o, obj;<br>    if (obj.constructor == Object){<br>        o = new obj.constructor();<br>    }else{<br>        o = new obj.constructor(obj.valueOf());<br>    }<br>    for(var key in obj){<br>        if ( o[key] != obj[key] ){<br>            if ( typeof(obj[key]) == ‘object’ ){<br>                o[key] = clone(obj[key]);<br>            }else{<br>                o[key] = obj[key];<br>            }<br>        }<br>    }<br>    o.toString = obj.toString;<br>    o.valueOf = obj.valueOf;<br>    return o;<br>  }<br>  //测试<br>  var parent = {<br>   data: {<br>    name: ‘jack’,<br>    age: 30,<br>    isMarried: false<br>   },<br>   language: [‘Java’],<br>   show:function(){ return “ok” ;}<br>  }<br>  var Cparent=clone(parent);<br>  alert(Cparent.data.age);<br>  alert(Cparent.language[0]);<br>  alert(Cparent.show());<br>方法3 （点击查看结果）<br>function clone(obj){<br>    function Fn(){}<br>    Fn.prototype = obj;<br>    var o = new Fn();<br>    for(var a in o){<br>        if(typeof o[a] == “object”) {<br>            o[a] = clone(o[a]);<br>        }<br>    }<br>    return o;<br>   }<br>   //测试<br>  var parent = {<br>   data: {<br>    name: ‘jack’,<br>    age: 30,<br>    isMarried: false<br>   },<br>   language: [‘Java’],<br>   show:function(){ return “ok” ;}<br>  }<br>  var Cparent=clone(parent);<br>  alert(Cparent.data.age);<br>  alert(Cparent.language[0]);<br>  alert(Cparent.show());</p>
<p>  JavaScript原型继承之陷阱  <a href="http://www.108js.com/article/article1/10130.html?id=766" target="_blank" rel="external">http://www.108js.com/article/article1/10130.html?id=766</a></p>
<p>  javascript中的function与感叹号  其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。<br>  javascript中双感叹号的使用<br>  js中的双感叹号判断。他相当于三元运算符，返回boolean值。<br>今天发现一段很奇怪的代码，虽然能领会他的意思，但是不明白双感叹号起到的作用。 代码如下:<br>  function id( name ) {<br>   return !!( typeof document !== “undefined” &amp;&amp; document &amp;&amp; document.getElementById ) &amp;&amp;<br>   document.getElementById( name );<br>  }<br>然后去网上查了些资料，他相当于三元运算符，返回boolean值。<br>   var ret = !!document.getElementById<br>等价于：<br>   var ret = document.getElementById ? true : false;　</p>
<p>当值是非空字符串和非零数字返回true，当值是空字符串、0或者null返回false。<br>代码如下:<br>  var a = “ “; alert(!!a);//true<br>  var a = “s”; alert(!!a);//true<br>  var a = true; alert(!!a);//true<br>  var a = 1; alert(!!a);//true<br>  var a = -1; alert(!!a);//true<br>  var a = -2; alert(!!a);//true</p>
<p>  var a = 0; alert(!!a);//false<br>  var a = “”; alert(!!a);//false<br>  var a = false; alert(!!a);//false<br>  var a = null; alert(!!a);//false</p>
<p>  JS笔试题</p>
<p>  1，考察this (点击查看结果）</p>
<p> var length = 10<br> function fn(){<br>   alert(this.length)<br> }<br> var obj = {<br>  length: 5,<br>  method: function(fn) {<br>  fn() // ?<br>  arguments<a href="">0</a> // ?<br> }<br>}<br>obj.method(fn)</p>
<p>  这里的坑主要是arguments，我们知道取对象属于除了点操作符还可以用中括号，这里fn的scope是arguments，即fn内的this===arguments，调用时仅传了一个参数fn，因此length为1。</p>
<p>  2，函数表达式具名（函数声明同时赋值给另一个变量）或函数声明立即执行时，名仅在该函数内可访问<br>  ~function() {<br>    alert(typeof next) // ?<br>    ~function next() {<br>      alert(typeof next) // ?<br>    }()<br>  }()</p>
<p>外层匿名函数自执行，打印next，接着内层具名函数自执行。会发现具名的next仅在其自身函数体内可访问，即输出为function。外面是不可见的，typeof就为undefined了。（注：此题IE6/7/8中输出为function function， 标准浏览器为undefined function）</p>
<p>同样的情况也发生在将具名函数赋值给一个变量时，如下<br> var func = function a() {<br>   alert(typeof a)<br> }<br> func() // ?<br> alert(typeof a) // ?</p>
<p>   这条规则是标准中(ES3/ES5)都已明确指出，但IE6、7、8没有严格遵从。可参见w3help的分析或李松峰老师的翻译《命名函数表达式探秘》</p>
<p>3，给基本类型数据添加属性，不报错，但取值时是undefined</p>
<p> a = 3<br> a.prop = 4<br> alert(a + a.prop) // ?</p>
<p>  变量a为数字3，给其添加prop属性，值为4（奇怪吧在JS中这是允许的，且不会有语法错误）。然后alert出a+a.prop的结果。结果是NaN。a.prop为undefined，3+undefined为NAN。</p>
<p>举一反三，给字符串添加属性</p>
<p> str = ‘a’<br> str.prop = ‘b’<br> alert(str + str.prop) // ?</p>
<p>结果呢？点击查看结果。</p>
<p>4，隐式的全局变量 （点击查看结果）<br> var a = 1<br> function func() {<br>  a = b = 2<br> }<br> func()<br> alert(a)<br> alert(b) // ?</p>
<p>JS中不用var声明的变量默认是全局变量，而这里的连等使的情况更加隐蔽。这里的b是全局的，因此func外可以访问。</p>
<p>5，变量声明早于代码运行（Scoping and Hoisting）<br> var uname = ‘jack’<br> function change() {<br>   alert(uname) // ?<br>   var uname = ‘lily’<br>   alert(uname)<br> }<br>change()</p>
<p>这里容易犯迷糊的是第一个alert，如果认为函数change外已经声明赋值了，此时应该是jack，实际函数内又var了一次（虽然var在其后），预解析时仍然会将其置undefined。这也是为什么书里都建议变量声明都放在代码块的最前面。</p>
<p>6，函数声明早于变量声明 （点击看结果）<br> function change() {<br>  alert(typeof fn) // ?<br>  function fn() {<br>    alert(‘hello’)<br>  }<br>   var fn<br> }<br>change()；</p>
<p>   change内先alert出fn，后函数声明，再变量声明。如果fn没有函数声明而仅是变量声明，那么结果与5一样是undefined。但这里却是function。即同一个作用域内，函数声明放在代码块后面和前面都没有关系，函数可以正常使用。而变量声明则需先置前，先使用则是undefined。</p>
<p>  变态题<br>  <a href="http://www.108js.com/article/article1/10112.html?id=738" target="_blank" rel="external">http://www.108js.com/article/article1/10112.html?id=738</a><br>  <a href="http://www.108js.com/article/article1/10113.html?id=739" target="_blank" rel="external">http://www.108js.com/article/article1/10113.html?id=739</a><br>  <a href="http://www.108js.com/article/article1/10110.html?id=739" target="_blank" rel="external">http://www.108js.com/article/article1/10110.html?id=739</a><br>  <a href="http://www.108js.com/article/article1/10167.html?id=885" target="_blank" rel="external">http://www.108js.com/article/article1/10167.html?id=885</a></p>
<p>问题：js之Genreator<br>  Generator基础相关知识<br>       Generator是ECMAScript6(代号harmory)中提供的新特性<br>       1、Generator的定义<br>             和普通函数相比，只是在function关键字后加个*号<br>Generator对象具有一个next方法，调用一次next方法才能执行定义的逻辑代码<br>       2、yield关键字<br>             yield关键字让Generator内部的逻辑能够切割成多个部分<br>                  A、切割函数逻辑<br>                        将一个函数的逻辑拆分为n(n=该函数中yield关键字数目)个，且它们共享上下文<br>                  B、yield关键字对next()方法的影响<br>                        每次.next()调用时，返回一个对象，这个对象具备两个属性，其中一个属性是表示这个Generator对象的逻辑块是否执行完成的布尔类型的done，另一个是yield语句后的表达式的结果value。若value属性值为一个函数，能直接通过value属性调用该函数<br>                  C、yield暂停Generator逻辑的理解<br>                        yield只能暂停Generator内部的逻辑，它并不是真正暂停整个线程，Generator外的业务逻辑依然会继续执行下去<br>       3、next()方法<br>             A、next()方法对yield关键字的影响<br>                 可以通过.next()传递参数，赋值给yield关键字前面的变量声明<br>       PS：对于Generator而言，它不仅可以将逻辑的单元切分得更细外，还能在暂停和继续执行的间隔中，动态传入数据，使得代码逻辑可以更灵活</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/js集锦(下)/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-js集锦(中) " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/js集锦(中) /">js集锦（中）</a>
    </h1>
  

        <a href="/2016/12/14/js集锦(中) /" class="archive-article-date">
  	<time datetime="2016-12-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>window.alert window.prompt  window.confirm</p>
<p>保留字：指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。保留字包括关键字和未使用的保留字。关键字则指在语言中有特定含义，成为语法中一部分的那些字。在一些语言中，一些保留字可能并没有应用于当前的语法中，这就成了保留字与关键字的区别。一般出现这种情况可能是由于考虑扩展性。例如，Javascript有一些未来保留字，如abstract、double、goto等等。</p>
<p>document.write()  document.writeln()</p>
<p>“liuhong”==”liuhong”  //true<br>“Liuhong”==”liuhong”  //false</p>
<p>5==5.0  //true<br>“5”==5 //true<br>“5.5”==5.5 //true<br>NaN==NaN  //false</p>
<p>null==null //true<br>-0==+0 //true<br>false==false //true<br>true==1 //true<br>null==undefined //true</p>
<p>“liuhong”===”liuhong”  //true<br>“Liuhong”===”liuhong”  //false</p>
<p>5===5.0  //true<br>“5”===5 //false<br>NaN===NaN  //false</p>
<p>null===null //true<br>-0===+0 //true<br>false===false //true<br>true===1 //false<br>null===undefined //false</p>
<p>闭包是定义在另一个函数中的匿名函数。当外部函数退出时，它会返回内部匿名函数的引用，使得通过引用调用内部函数成为可能。闭包意味着局部变量对内部函数仍然可用即使它已经超出其作用域。闭包可以让变量一直存活到不再需要它们的时候。</p>
<p>js支持多种对象：<br>（1）由程序员定义的用户自定义对象；<br>（2）核心或内置对象，如Date、String及Number<br>(3)浏览器对象，即Bom<br>（4）文档对象，即Dom</p>
<p>js的with语句使用方法<br>1）简要说明<br>       with 语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  </p>
<p>2）语法格式<br>with(object instance)<br>{<br>        //代码块<br>}<br>       有时候，我在一个程序代码中，多次需要使用某对象的属性或方法，照以前的写法，都是通过:对象.属性或者对象.方法这样的方式来分别获得该对象的属性和方法，着实有点麻烦，学习了with语句后，可以通过类似如下的方式来实现：<br>with(objInstance)<br>{<br>       var str = 属性1;<br>…..<br>} 去除了多次写对象名的麻烦。  </p>
<p>3）举例  </p>
<p><script language="javascript"><br><!--  
function Lakers() {  
       this.name = "kobe bryant";  
       this.age = "28";  
       this.gender = "boy";  
}  
var people=new Lakers();  
with(people)  
{  
       var str = "姓名: " + name + "<br>";  
       str += "年龄：" + age + "<br>";  
       str += "性别：" + gender;  
       document.write(str);  
}  
//--><br></script><br>代码执行效果如下:<br>姓名: kobe bryant<br>年龄：28<br>性别：boy</p>
<p>constructor:对创建对象函数的引用<br>prototype:对对象原型的引用。该参数使得对象可以共享属性和方法。</p>
<p>slice()方法将数组的元素复制到另一个新数组中，参数为起始元素和终止元素且不包括该索引表示的元素。<br>splice()将从数组的某一位置开始移除指定书目的元素，并可以使用新元素替代这些元素。</p>
<p>ceil()上取整<br>floor()下取整<br>round()当原数的小数部分为0.5或大于0.5时向上取整否则向下取整。</p>
<p>wrapper:它是js中的一种对象，它与其所代表的基础数组类型同名。每种基础数据类型均有其对应的String对象、Number对象和Boolean对象。这些对象都叫做wrapper.</p>
<p>Function对象的方法<br>apply()可以将一个函数的方法应用于另一个函数<br>call（）通过另一个对象调用一个方法</p>
<div align="center"><br><img src="/images/js/2_1.jpg"><br><img src="/images/js/2_2.jpg"><br><img src="/images/js/2_3.jpg"><br><img src="/images/js/2_4.jpg"><br><img src="/images/js/2_5.jpg"><br><img src="/images/js/2_6.jpg"><br><img src="/images/js/2_7.jpg"><br><img src="/images/js/2_8.jpg"><br><img src="/images/js/2_9.jpg"><br></div>

<div align="center"><br><img src="/images/js/3_1.jpg"><br><img src="/images/js/3_2.jpg"><br><img src="/images/js/3_3.jpg"><br><img src="/images/js/3_4.jpg"><br><img src="/images/js/3_5.jpg"><br><img src="/images/js/3_6.jpg"><br><img src="/images/js/3_7.jpg"><br><img src="/images/js/3_8.jpg"><br><img src="/images/js/3_9.jpg"><br></div>

<div align="center"><br><img src="/images/js/4_1.jpg"><br><img src="/images/js/4_2.jpg"><br><img src="/images/js/4_3.jpg"><br><img src="/images/js/4_4.jpg"><br><img src="/images/js/4_5.jpg"><br><img src="/images/js/4_6.jpg"><br><img src="/images/js/4_7.jpg"><br><img src="/images/js/4_8.jpg"><br><img src="/images/js/4_9.jpg"><br></div>

<div align="center"><br><img src="/images/js/5_1.jpg"><br><img src="/images/js/5_2.jpg"><br><img src="/images/js/5_3.jpg"><br><img src="/images/js/5_4.jpg"><br></div>



<pre><code>var num1 = 3.1415927;
//返回指定的位数的数字
 var num3 = num1.toPrecision(4);


 /**
</code></pre><ul>
<li><p>函数使用技巧<br>*/<br>(function(){<br> //代理函数–&gt;用程序来决定返回的新的函数(他是一个生产函数的函数)<br> //模拟数据库<br> var person = {“jim”:”m”,”lili”:”w”}<br> var test = function(name){</p>
<pre><code>if(person[name] == &quot;m&quot;){

    /**
     * 内科,外科
     */
    return function(nk,wk){
        alert(nk+&quot;  &quot;+wk)
    }

}else if(person[name] == &quot;w&quot;){
    /**
     * 内科,外科,妇科
     */
    return function(nk,wk,fk){
        alert(nk+&quot;  &quot;+wk+&quot; &quot;+fk)
    }            
}
</code></pre><p> }<br> test(“jim”)(“ok”,”ok”)<br> test(“lili”)(“ok”,”ok”,”no”)<br>})()</p>
</li>
</ul>
<p>var cat = {};//cat空类<br>    //默认隐藏的调用下面的代码<br>    Object.getPrototypeOf(cat).name = “MAOMI”;<br>    cat.<strong>proto</strong>.master = “USPCAT.COM”;<br>    //测试<br>    cat.age = 2;<br>    cat[“sex”] = “MAN”;<br>    alert(cat.name +”  “+cat.age+” “+cat[“sex”]+” “+cat.master)</p>
<pre><code>/**
 * 聚合函数
 */
function mixin(receivingClass,givingClass){
    for(methodName in givingClass){
        if(!receivingClass.__proto__[methodName]){
            receivingClass.__proto__[methodName] = givingClass[methodName]
        }
    }
}



桥梁模式在于可以独立的修改，而门面模式的意义在于调用的方便，适配器是为了解决已有接口有的类不兼容的问题。
享元模式是一个为了提高性能(空间复杂度)的设计模式，它适用于程序会生产大量的相类似的对象是耗用大量的内存的问题
代理模式是一个对象(proxy)用它来控制目标对象的访问，它要实现与目标对象相同的接口,但是它不同于装饰者模式
责任链模式消除发送者与接收者之间的耦合1.责任链的发送者知道链的入口是谁 2.每一个链节点知道自己的下一个节点是谁 3.每一个链的传入和传输值是一样的
命令模式：用于消除调用者和接收者直接的耦合的模式，并且可以对(调用这个过程进行留痕操作)真的不要乱用这个模式,因为它使你简单调用写法变得非常的复杂和有些难理解(重点)当你的业务出现了 (回退操作)(重做操作)的需求的时候你就要考虑使用这个模式了。
观察者模式：它分为2个角色1.观察者,2.被观察者2观察者模式的目的对程序的内在变化进行观察,当其有变化的时候3你可以得知,并且可以做出相应的反应
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/js集锦(中) /#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jquery题库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/jquery题库/">jquery题库</a>
    </h1>
  

        <a href="/2016/12/14/jquery题库/" class="archive-article-date">
  	<time datetime="2016-12-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>问题：jQuery的美元符号$有什么作用？</p>
<p>回答：其实美元符号$只是”jQuery”的别名，它是jQuery的选择器，如下代码：</p>
<p>$(document).ready(function(){</p>
<p>});<br>当然你也可以用jQuery来代替$，如下代码：</p>
<p>jQuery(document).ready(function(){</p>
<p>});<br>jQuery中就是通过这个美元符号来实现各种灵活的DOM元素选择的，例如$(“#main”)即选中id为main的元素。</p>
<p>问题：body中的onload()函数和jQuery中的document.ready()有什么区别？</p>
<p>回答：onload()和document.ready()的区别有以下两点：</p>
<p>1、我们可以在页面中使用多个document.ready()，但只能使用一次onload()。</p>
<p>2、document.ready()函数在页面DOM元素加载完以后就会被调用，而onload()函数则要在所有的关联资源（包括图像、音频）加载完毕后才会调用。</p>
<p>问题：jQuery中有哪几种类型的选择器？</p>
<p>回答：从我自己的角度来讲，可以有3种类型的选择器，如下：</p>
<p>1、基本选择器：直接根据id、css类名、元素名返回匹配的dom元素。</p>
<p>2、层次选择器：也叫做路径选择器，可以根据路径层次来选择相应的DOM元素。</p>
<p>3、过滤选择器：在前面的基础上过滤相关条件，得到匹配的dom元素。</p>
<p>问题：请使用jQuery将页面上的所有元素边框设置为2px宽的虚线？</p>
<p>回答：这正是jQuery选择器上场的时候了，代码如下：</p>
<script language="javascript" type="text/javascript">

         $("*").css("border", "2px dotted red"); 

</script>
问题：当CDN上的jQuery文件不可用时，该怎么办？

回答：为了节省带宽和脚本引用的稳定性，我们会使用CDN上的jQuery文件，例如google的jquery cdn服务。但是如果这些CDN上的jQuery服务不可用，我们还可以通过以下代码来切换到本地服务器的jQuery版本：

<script type="text/javascript" language="Javascript" src="http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.1.min.js "></script>

<script type="text/javascript">//<![CDATA[

if (typeof jQuery == 'undefined') {

document.write(unescape("%3Cscript src='/Script/jquery-1.4.1.min.js' type='text/javascript' %3E%3C/script%3E"));

}//]]>

</script>
问题：如何使用jQuery实现点击按钮弹出一个对话框？

回答：代码如下：

HTML：

<input id="inputField" type="text" size="12">
jQuery：

<script type="text/javascript"> $(document).ready(function () { $('#Button1').click(function () { alert($('#inputField').attr("value")); }); }); </script>
问题：jQuery中的Delegate()函数有什么作用？

回答：delegate()会在以下两个情况下使用到：

1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：

$("ul").delegate("li", "click", function(){

$(this).hide();

});
2、当元素在当前页面中不可用时，可以使用delegate()

问题：怎样用jQuery编码和解码URL？

回答：在jQuery中，我们可以使用以下方法实现URL的编码和解码。

encodeURIComponent(url) and decodeURIComponent(url)
问题：如何用jQuery禁用浏览器的前进后退按钮？

回答：实现代码如下：

<script type="text/javascript" language="javascript">

$(document).ready(function() {

     window.history.forward(1);

     //OR

     window.history.forward(-1);

});

</script>


<p>1下面哪种不是jquery的选择器？(单选)<br>A、 基本选择器 B、后代选择器 C、类选择器 D、进一步选择器 考点:jquery的选择器 (C) </p>
<p>2当DOM加载完成后要执行的函数，下面哪个是正确的？(单选)<br>jQuery(expression, [context]) B、jQuery(html, [ownerDocument]) C、jQuery(callback) D、jQuery(elements)<br>考点：jquery的核心函数 (C)<br>3下面哪一个是用来追加到指定元素的末尾的？(单选) A、insertAfter() B、append() C、appendTo() D、after() 考点：jquery的核心函数 (C)<br>4下面哪一个不是jquery对象访问的方法？(单选) A、each(callback) B、size() C、index(subject) D、index() 考点： jquery的核心函数之对象访问 （D）<br>5．jquery访问对象中的size()方法的返回值和jQuery对象的<strong>___</strong>属性一样. 考点：jquery的核心函数之对象访问 （length）<br>6.jquery中$(this).get(0)的写法和<strong><strong>__</strong></strong>是等价的。 考点：jquery的核心函数之对象访问 （$(this)[0]）  </p>
<ol>
<li>有这样一个表单元素<br>，想要找到这个hidden元素，下面哪个是正确的？(单选) A、visible B、hidden C、visible() D、hidden() 考点：jquery的选择器 （B）<br>8.如果需要匹配包含文本的元素，用下面哪种来实现？(单选) A、text() B、contains() C、input() D、attr(name) 考点：jquery的选择器 （B）<br>9.现有一个表格，如果想要匹配所有行数为偶数的，用<strong><em>__</em></strong>实现，奇数的用<strong>___</strong>实现。<br>考点：jquery的选择器 （even,odd）<br>10.如果想要找到一个表格的指定行数的元素，用下面哪个方法可以快速找到指定元素？(单选)<br>A、text() B、get() C、eq() D、contents（） 考点：jquery的选择器 （C）<br>11.在一个表单里，想要找到指定元素的第一个元素用<strong><strong>_</strong></strong>实现，那么第二个元素用<strong><strong>_</strong></strong>实现。<br>考点：jquery的选择器 （first,eq(1)）<br>12.下面哪种不属于jquery的筛选？（单选） A、过滤 B、自动 C、查找 D、串联 考点：jquery的筛选 (B)<br>13.下面哪几种是属于jquery文档处理的？ （多选） A、包裹 B、替换 C、删除 D、内部和外部插入 考点：jquery的文档处理 (ABD)<br>14.如果想在一个指定的元素后添加内容，下面哪个是实现该功能的？（单选） A、append(content) B、appendTo(content) C、insertAfter(content) D、after(content) 考点：jquery的文档处理 (D)<br>15.在jquery中，用一个表达式来检查当前选择的元素集合，使用<strong>__</strong>来实现，如果这个表达式失效，则返回<strong><strong>___</strong></strong>值。 考点：jquery的筛选 （is(expr),false）<br>16.在jquey中，如果想要从DOM中删除所有匹配的元素，下面哪一个是正确的？（单选） A、delete() B、empty() C、remove() D、removeAll() 考点：jquery的文档处理 （C）<br>17.在jquery中，想要给第一个指定的元素添加样式，下面哪一个是正确的？（单选） A、first B、eq(1) C、css(name) D、css(name,value) 考点： jquery的css处理 （C）<br>18.在编写页面的时候，如果想要获取指定元素在当前窗口的相对偏移，用<strong><strong>_</strong></strong>来实现，该方法的返回值有两个属性，分别是<strong><em>__</em></strong>和<strong><strong>__</strong></strong>。 考点：jquery的css处理 （offset,top,left）<br>19.在jquery中，如果想要获取当前窗口的宽度值，下面哪个是实现该功能的？ （单选） A、width() B、width(val) C、width D、innerWidth() 考点：jquery的css处理 （A）   20.在一个表单中，如果将所有的div元素都设置为绿色，实现功能是<strong><strong><strong><strong><strong><strong><em>__</em></strong></strong></strong></strong></strong></strong>。  考点：jquery的css处理 ($(“div”).css(“color”,”green”))   21.为每一个指定元素的指定事件（像click）绑定一个事件处理器函数，下面哪个是用来实现该功能的？ （单选）  A、trigger (type) B、bind(type) C、one(type) D、bind 考点：jquery的事件操作 (B)<br>22．在jquery中，鼠标移动到一个指定的元素上，会触发指定的一个方法，实现该操作的是<strong><strong><strong>__</strong></strong></strong>。<br>考点：jquery的事件操作 (hover(over,out))<br>23.下面哪几个不是属于jquery的事件处理? (多选) A、bind(type) B、click() C、change() D、one(type) 考点：jquery的事件处理 (BC)<br>24.在一个表单中，如果想要给输入框添加一个输入验证，可以用下面的哪个事件实现？ (单选)<br>A、hover(over ,out) B、keypress（fn） C、change() D、change(fn) 考点：jquery的事件处理 (D)<br>25.当一个文本框中的内容被选中时，想要执行指定的方法时，可以使用下面哪个事件来实现？（单选）<br>A、click(fn) B、change(fn) C、select(fn) D、bind(fn) 考点：jquery的事件处理 (C)<br>26.在jquery中，想让一个元素隐藏，用<strong><em>__</em></strong>实现，显示隐藏的元素用<strong><strong>_</strong></strong>实现。 考点：jquery的页面效果 （hide(),show()）<br>27.在一个表单中，用600毫秒缓慢的将段落滑上，用<strong><strong><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></strong></strong>来实现。<br>考点：jquery的页面效果 （$(“p”).slideUp(“slow”)<br>25.当一个文本框中的内容被选中时，想要执行指定的方法时，可以使用下面哪个事件来实现？（单选）<br>A、click(fn) B、change(fn) C、select(fn) D、bind(fn) 考点：jquery的事件处理 (C)<br>26.在jquery中，想让一个元素隐藏，用<strong><em>__</em></strong>实现，显示隐藏的元素用<strong><strong>_</strong></strong>实现。 考点：jquery的页面效果 （hide(),show()）<br>27.在一个表单中，用600毫秒缓慢的将段落滑上，用<strong><strong><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></strong></strong>来实现。<br>考点：jquery的页面效果 （$(“p”).slideUp(“slow”)<br>28.在jquery中，如果想要自定义一个动画，用<strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong>函数来实现。 考点：jquery的页面效果 (animate(params, options))<br>29.在jquery中想要实现通过远程http get请求载入信息功能的是下面的哪一下事件？ (单选)<br>A、$.ajax() B、load(url) C、$.get(url) D、$. getScript(url) 考点：jquery的ajax (C)<br>30.下面不属于ajax事件的是？ (单选)<br>A、ajaxComplete(callback) B、ajaxSuccess(callback) C、$.post(url) D、ajaxSend(callback) 考点：jquery的ajax （C）<br>31.彻底将jQuery变量还原，可以使用<strong><strong><strong><strong>___</strong></strong></strong></strong>方法实现。 考点：jquery的多库共存 ($.noConflict(extreme))<br>32.在一个表单中，查找所有选中的input元素，可以用jquery中的<strong><strong><strong><strong><em>__</em></strong></strong></strong></strong>来实现。<br>考点：jquery的选择器（:not()）<br>33.下面哪几种是jquery中表单的对象属性？（多选）<br>A、:checked B、: enabled C、:hidden D、:selected E、:file F、: disabled 考点：jquery的选择器（ABDF）<br>34.在jquery中如果将一个“名/值”形式的对象设置为所有指定元素的属性，可以用<strong><strong><strong><em>__</em></strong></strong></strong>实现。<br>考点：jquery选择器之属性 （attr(pro)）<br>35.在jquery中指定一个类，如果存在就执行删除功能，如果不存在就执行添加功能，下面哪一个是可以直接完成该功能的？（单选）<br>A、removeClass() B、deleteClass() C、toggleClass(class) D、addClass() 考点：jquery的属性 （C）<br>36.在jquery中想要找到所有元素的同辈元素，下面哪一个是可以实现的？（单选） A、eq(index) B、find(expr) C、siblings([expr]) D、next() 考点：jquery的筛选 （C）</li>
<li>什么是jQuery?<br>jQuery是继prototype之后又一个优秀的Javascrīpt框架。</li>
<li>HTML代码：</li>
</ol>
<p>This is a DIV</p>
<p>1) 把这个HTML元素转化为jQuery对象的语句是？<br>2) 得到div元素内文本的语句可以是哪些？<br>3) 把元素内文本设置为粗体的方法有？<br>4) 清空文本的方法有？</p>
<p>1.$(“div”)<br>2.$(“div”).text(),$(“div”).html ()<br>3.$(“div”).text(“This is DIV”)<br>4.$(“div”).text(“”)</p>
<ol>
<li>HTML代码：</li>
</ol>
<p>窗体顶端</p>
<p>窗体底端</p>
<p>1) $(‘:hidden’).length的值是?<br>1<br>2) $(‘form input’), $(‘form &gt; input’), $(‘form + input’), $(‘form ~ input’)分别返回代表哪些元素的jQuery数组？<br>$(‘form input’) 返回form下的所有input元素<br>$(‘form &gt; input’) 查找以form为父元素所有input子元素<br>$(‘form + input’) 查找以form之外第一个input子元素<br>$(‘form ~ input’) 查找以form之外所有input子元素<br>3) 获取form里第二个input元素的方法有？<br>$(“#div1 input”).eq(1)<br>4) $(‘form input:first’).parent()返回的是？</p>
<p>5) $(‘form input:first’).parents().size()的值是？<br>1<br>6) $(‘#div1’).empty()与$(‘#div1’).remove()的结果有什么不同？<br>$(‘#div1’).empty()清空 div1的内容 结果为</p>
<p>$(“#div1”).remove()删除div1节点 及包含的子节点 </p>
<ol>
<li>有一个button</li>
</ol>
<p>执行以下jQuery语句：<br>$(‘#btn’).click(function(){ alert(‘click me’); });<br>$(‘#btn’).click(function(){ alert(‘click me again.’)});<br>单击这个button会有什么效果？<br>弹出2次对话框 分别是 click me, click meagain</p>
<ol>
<li>HTML代码：</li>
</ol>
<p>Hello how are you?</p>
<p>jQuery 代码:<br>$(“p”).find(“span”).text(‘Hi’).end()<br>结果是？</p>
<p>Hihow are you</p>
<p>1 你在公司是怎么用jquery的？     </p>
<p>答：在项目中是怎么用的是看看你有没有项目经验(根据自己的实际情况来回答)           你用过的选择器啊，复选框啊，表单啊，ajax啊，事件等           配置Jquery环境 下载jquery类库 在jsp页面引用jquery类库即可        <scripttype="text javascript"src="jquery/jquery-1.7.2.min.js">         接下来通过在         <script>             $(function(){                             });           </script></scripttype="text></p>
<pre><code>2你为什么要使用jquery？      
</code></pre><p>答：因为jQuery是轻量级的框架，大小不到30kb,它有强大的选择器，        出色的DOM操作的封装，有可靠的事件处理机制(jQuery在处理事件绑定的时候相当的可靠)，        完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest         对象的创建和使用的问题。) 出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。        行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。</p>
<pre><code>3你觉得jquery有哪些好处？     答案同上

4  你使用jquery遇到过哪些问题，你是怎么解决的？    
</code></pre><p>答：这个答案是开发的，看你是否有相关的项目经验。        例 前台拿不到值，JSON 可是出现的错误(多了一个空格等)这编译是不会报错的        jquery库与其他库冲突：         1&gt;如果其他库在jquery库之前导入的话           1.我们可以通过jquery.noconflict()将变量的$的控制权过度给其他库            2.自定义快捷键,用一个变量接住jquery.noconflict()           3.通过函数传参           2&gt;如果jquery库在其他库之前导入就直接使用jquery         今天在处理一个数据问题时，发现jQuery.ajax()方法返回的值一直有问题，清除缓存后数据无误，          多次测试后发现返回的值都是之前的值，并且一直未执行url(后台为JAVA，设置断点一直未进入)。在网上查找下,发现是未设置type的原因。        如果没设置jQuery.ajax的type=”Post”，那么ajax就会默认type=”Get”，这就会导致之前数据被缓存起来。加上type=”Post”，问题解决！</p>
<pre><code>5  你知道jquery中的选择器吗，请讲一下有哪些选择器？   
</code></pre><p>答 ：jQuery中的选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器</p>
<pre><code>6  jquery中的选择器 和 css中的选择器有区别吗？     
</code></pre><p>答：jQuery选择器支持CSS里的选择器，         jQuery选择器可用来添加样式和添加相应的行为          CSS 中的选择器是只能添加相应的样式</p>
<pre><code>7  你觉得jquery中的选择器有什么优势？   
</code></pre><p>答：简单的写法  $(‘ID’) 来代替document.getElementById()函数          支持CSS1 到CSS3选择器           完善的处理机制(就算写错了id也不会报错)  </p>
<pre><code>8  你在使用选择器的时候有有没有什么觉得要注意的地方？      
</code></pre><p>答: 1 选择器中含有”.”,”#”,”[“ 等特殊字符的时候需要进行转译         2 属性选择器的引号问题          3 选择器中含有空格的注意事项          </p>
<pre><code>9  jquery对象和dom对象是怎样转换的？    
</code></pre><p>答 ：jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的丰富得到相应的DOM对象                     还可以通过get[index]去得到相应的DOM对象。          DOM对象转jQuery对象:$(DOM对象)</p>
<pre><code>10  你是如何使用jquery中的ajax的？     
</code></pre><p>答: 如果是一些常规的ajax程序的话，使用load(),$.get(),$.post(),就可以搞定了，          一般我会使用的是$.post() 方法。          如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)         及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<pre><code>11  你觉得jquery中的ajax好用吗，为什么？      
</code></pre><p>答: 好用的。         因为jQuery提供了一些日常开发中夙瑶的快捷操作，例load，ajax，get，post等等，        所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上         ，不需要去理会那些繁琐的XMLHttpRequest对象了。</p>
<pre><code>12jquery中$.get()提交和$.post()提交有区别吗？     
</code></pre><p>答:        1 $.get() 方法使用GET方法来进行异步请求的。       $.post() 方法使用POST方法来进行异步请求的。      2 get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体         内容发送给Web服务器的，这种传递是对用户不可见的。      3 get方式传输的数据大小不能超过2KB 而POST要大的多       4 GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。      </p>
<pre><code>13  jquery中的load方法一般怎么用的？    
</code></pre><p>答：load方法一般在 载入远程HTML 代码并插入到DOM中的时候用        通常用来从Web服务器上获取静态的数据文件。         如果要传递参数的话，可以使用$.get() 或 $.post() </p>
<pre><code>14  在jquery中你是如何去操作样式的？    
</code></pre><p>答: addClass() 来追加样式          removeClass() 来删除样式        toggle() 来切换样式         </p>
<pre><code>15  简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？

答: 首先去装载文档，在页面家在完毕后，浏览器会通过javascript 为DOM          元素添加事件。

16  你使用过jquery中的动画吗，是怎样用的？      答:使用过。

       hide()和 show() 同时修改多个样式属性。像高度，宽度，不透明度。           fadeIn() 和fadeOut() fadeTo() 只改变不透明度          slideUp() 和slideDown() slideToggle() 只改变高度         animate() 属于自定义动画的方法.       
</code></pre><p>17 你使用过jquery中的插件吗？    答:看个人的实力和经验来回答了。          </p>
<pre><code>18  你一般用什么去提交数据，为什么？     
</code></pre><p>答:一般我会使用的是$.post()方法。        如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)          及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<pre><code>19  在jquery中引入css有几种方式？      
</code></pre><p>答:四种 行内式，内嵌式，导入式，链接式       </p>
<pre><code>20  你在jquery中使用过哪些插入节点的方法，它们的区别是什么？      答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter()      before(),insertBefore()        大致可以分为 内部追加和外部追加       append() 表式向每个元素内部追加内容。          appendTo() 表示 讲所有的元素追加到指定的元素中。        例$(A)appendTo(B) 是将A追加到B中          下面的方法解释类似

21  你使用过包裹节点的方法吗，包裹节点有方法有什么好处？      
</code></pre><p>答: wrapAll(),wrap(), wrapInner()         需要在文档中插入额外的结构化标记的时候可以使用这些包裹的方法        应为它不会帛画原始文档的语义</p>
<pre><code>22  jquery中如何来获取或和设置属性？      jQuery中可以用attr()方法来获取和设置元素属性     removeAttr() 方法来删除元素属性

23  如何来设置和获取HTML 和文本的值？    
</code></pre><p>答：html()方法 类似于innerHTML属性 可以用来读取或者设置某个元素中的HTML内容           注意：html() 可以用于xhtml文档 不能用于xml文档           text()类似于innerText属性 可以用来读取或设置某个元素中文本内容。         val() 可以用来设置和获取元素的值      </p>
<pre><code>24  你jquery中有哪些方法可以遍历节点？      
</code></pre><p>答 ：children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素          next() 取得匹配元素后面紧邻的同辈元素          prev() 取得匹配元素前面紧邻的同辈元素         siblings() 取得匹配元素前后的所有同辈元素         closest() 取得最近的匹配元素           find() 取得匹配元素中的元素集合包括子代和后代       </p>
<p>25 子元素选择器 和后代选择器元素有什么区别？    </p>
<p>答:子代元素是找子节点下的所有元素,后代元素是找子节点或子节点的子节点中的元素       </p>
<p>26 在jquery中可以替换节点吗？    </p>
<p>答：可以 在jQuery中有两者替换节点的方式         replaceWith() 和 replaceAll()          例如在</p><p title="hao are you">hao are you</p>替换成         <strong>I amfine<strong>           $(‘p’).replaceWith(‘<strong>I amfine</strong>‘);           replaceAll与replaceWith的用法前后调换一下即可。  <p></p>
<pre><code>27你觉得beforeSend方法有什么用？    
</code></pre><p>答：发送请求前可以修改XMLHttpRequest对象的函数，在beforeSend中          如果返回false 可以取消本次的Ajax请求。XMLHttpRequest对象是唯一的参数        所以在这个方法里可以做验证         </p>
<p>28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？      </p>
<p>答: $(‘prev~div’) 只能选择’#prev’元素后面的同辈<div>元素           而siblings()方法与前后的文职无关，只要是同辈节点就都能匹配。</div></p>
<pre><code>29你在ajax中使用过JSON吗，你是如何用的？     
</code></pre><p>答:使用过，在$.getJSON()方法的时候就是。     因为 $.getJSON() 就是用于加载JSON文件的     </p>
<p>30 有哪些查询节点的选择器？    </p>
<p>答：我在公司使用过 :first 查询第一个，:last 查询最后一个，:odd查询奇数但是索引从0开始         :even 查询偶数，:eq(index)查询相等的 ,:gt(index)查询大于index的 ,:lt查询小于index         :header 选取所有的标题等   </p>
<p>31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？      </p>
<p>答:能。 使用nextAll()和使用$(‘prev~siblindgs’) 是一样的      </p>
<p>32 jQuery中有几种方法可以来设置和获取 样式      </p>
<p>答 ：addClass() 方法，attr() 方法     </p>
<p>33 $(document).ready()方法和window.onload有什么区别？     </p>
<p>答: 两个方法有相似的功能，但是在实行时机方面是有区别的。           1 window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全             加载到浏览器后才执行的。        2 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用           执行绑定的函数。    </p>
<p>34 jQuery是如何处理缓存的？   </p>
<p>答 ：要处理缓存就是禁用缓存.           1 通过$.post() 方法来获取数据，那么默认就是禁用缓存的。        2 通过$.get()方法 来获取数据，可以通过设置时间戳来避免缓存。              可以在URL后面加上+(+new Date)              例 $.get(‘ajax.xml?’+(+newDate),function () {                  //内容            });        3通过$.ajax 方法来获取数据，只要设置cache:false即可。    </p>
<p>35 $.getScript()方法 和 $.getJson() 方法有什么区别？   </p>
<p>答: 1 $.getScript() 方法可以直接加载.js文件，并且不需要对javascript文件进行处理           ，javascript文件会自动执行。         2 $.getJson() 是用于加载JSON 文件的 ，用法和$.getScript()    </p>
<p>36 你读过有关于jQuery的书吗？     《jquery基础教程》   《jquery实战》   《锋利的jquery》《巧用jquery》  《jQuery用户界面库学习指南》等     </p>
<p>37 $(“#msg”).text(); 和 $(“#msg”).text(“<b>newcontent</b>“);有什么区别？   </p>
<p>答：1 $(“#msg”).text() 是返回id为msg的元素节点的文本内容        2$(“#msg”).text(“<b>new content</b>“); 是 将“<b>new content</b>” 作为普通文本串写入id为msg的元素节点内容中,          页面显示粗体的<b>new content</b></p>
<p>38 radio单选组的第二个元素为当前选中值，该怎么去取？      </p>
<p>答 :$(‘input[name=items]’).get(1).checked = true;     </p>
<p>39 选择器中 id，class有什么区别？    </p>
<p>答：在网页中 每个id名称只能用一次，class可以允许重复使用               </p>
<p>40 你使用过哪些数据格式，它们各有什么特点？     </p>
<p>答: HTML格式  ,JSON格式,javascript格式,XML格式         1HTML片段提供外部数据一般来说是最简单的。        2如果数据需要重用，而且其他应用程序也可能一次受到影响，那么在性能和文件大小方面具有优势的JSON通常是不错的选择。         3 而当远程应用程序未知时，XML则能够为良好的互操作性提供最可靠的保证。      </p>
<p>41 jQuery 能做什么？    </p>
<p>答：1 获取页面的元素            2 修改页面的外观         3 改变页面大的内容          4 响应用户的页面操作         5 为页面添加动态效果        6 无需刷新页面，即可以从服务器获取信息        7 简化常见的javascript任务              </p>
<p>42 在ajax中data主要有几种方式？     </p>
<p>答 ： 三种，html拼接的，json数组，form表单经serialize()序列化的。      </p>
<p>43 ：jQuery中的hover()和toggle()有什么区别？      </p>
<p>答 hover()和toggle()都是jQuery中两个合成事件。         hover()方法用于模拟光标悬停事件。         toggle()方法是连续点击事件。      </p>
<p>44 你知道jQuery中的事件冒泡吗，它是怎么执行的，何如来停止冒泡事件？      答: 知道,        事件冒泡是从里面的往外面开始触发。          在jQuery中提供了stopPropagation()方法可以停止冒泡。      </p>
<p>45 例如 单击超链接后会自动跳转，单击”提交”按钮后表单会提交等，有时候我想阻止这些默认的行为，该怎么办？     </p>
<p>答: 可以用event.preventDefault()         或 在事件处理函数中返回false，即 return false;      </p>
<p>46.jquery表单提交前有几种校验方法？分别为？？      </p>
<p>formData:返回一个数组，可以通过循环调用来校验    jaForm：返回一个jQuery对象，所有需要先转换成dom对象       fieldValue：返回一个数组    beforeSend()     </p>
<p>47.在jquery中你有没有编写过插件，插件有什么好处？你编写过那些插件？它应该注意那些？      </p>
<p>答: 插件的好处：对已有的一系列方法或函数的封装，以便在其他地方重新利用，方便后期维护和提高开发效率          插件的分类：封装对象方法插件、封装全局函数插件、选择器插件        注意的地方：            1.插件的文件名推荐命名为jquery.[插件名].js，以免和其他的javaScript库插件混淆              2.所有的对象方法都应当附加到jQuery.fn对象上，而所有的全局函数都应当附加到jQuery对象本身上             3.插件应该返回一个jQuery对象，以保证插件的可链式操作              4.避免在插件内部使用$作为jQuery对象的别名,而应使用完整的jQuery来表示，这样可以避免冲突或使用闭包来避免              5.所有的方法或函数插件，都应当一分好结尾，否则压缩的时候可能出现问题。在插件头部加上分号，这样可以避免他人的不规范代码给插件带来影响              6.在插件中通过$.extent({})封装全局函数,选择器插件，扩展已有的object对象            通过$.fn.extend({})封装对象方法插件     </p>
<p>48.怎样给jquery动态附加新的元素?那么怎样给新生成的元素绑定事件呢？       jQuery的html()可以给现在元素附加新的元素      直接在元素还未生成前就绑定肯定是无效的，因为所绑定的元素目前根本不存在。     所以我们可以通过live和livequery来动态绑定事件</p>
<p>JQuery试题总结（上篇）<a href="http://blog.csdn.net/dyllove98/article/details/9280527" target="_blank" rel="external">http://blog.csdn.net/dyllove98/article/details/9280527</a><br>jQuery中的text()、html()和val()以及innerText、innerHTML和value</p>
<p>*jQuery中设置或者获取所选内容的值：<br>text();设置或者获取所选元素的文本内容；</p>
<p>html();设置或者获取所选元素的内容（包括html标记）；</p>
<p>val();设置或者获取表单字段的值（前提是表单设置了value属性）；</p>
<p>(text()和html()的区别是：前者是处理的文本内容，只能写文本如果写了上面的标记则会以文本形式输出；后者可以解析文本中的html标记，就是你可以添加像<a></a>、</p><p></p>等标记，最后会解析为其效果。<br>)<p></p>
<p>*JavaScript中设置或者获取所选内容的值</p>
<p>同理innerText、innerHTML和value，</p>
<p>innerText和innerHTML都是将字符串放入hmtl标签中的一个函数<br>但是innerHTMl他可以解析hmtl标记<br>例如 你放入一个<a>斯蒂芬</a>  如果在DIV中它里面就会出现一个带下划线的a元素；<br>但是innerText只支持普通字符串；</p>
<p>*具体代码如下：<br>jQuery中：<br>    <html><br>    <head><br>    <script src="/jquery/jquery-1.11.1.min.js"></script><br>    <script><br>    $(document).ready(function(){<br>      $(“#btn1”).click(function(){<br>        alert(“Text: “ + $(“#test”).text());<br>      });<br>      $(“#btn2”).click(function(){<br>        alert(“HTML: “ + $(“#test”).html());<br>      });<br>    });<br>    </script><br>    </head></html></p>
<pre><code>&lt;body&gt;
&lt;p id=&quot;test&quot;&gt;这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。&lt;/p&gt;
&lt;button id=&quot;btn1&quot;&gt;显示文本&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;显示 HTML&lt;/button&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>JavaScript中：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
function getInnerHTML(){
alert(document.getElementById(&quot;btn1&quot;).value);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p id=&quot;test&quot;&gt;这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。&lt;/p&gt;
&lt;button id=&quot;btn1&quot;  onclick=&quot;getInnerHTML()&quot;  &gt;显示文本&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;显示 HTML&lt;/button&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>jQuery和JavaScript的区别总结：</p>
<p>*前者click事件是获取元素id进行处理；后者是onclick=”getInnerHTML()”;</p>
<p>*前者获取元素值时是text()；后者是innerText,无();设置值时，前者是text(“jing”),后者是innerText=”jing”;</p>
<p>*注意:两者的设置时，会覆盖原有内容，如果想要插入，使用插入方法。</p>
<p>另：</p>
<p>.html()用为读取和修改元素的HTML标签    对应js中的innerHTML</p>
<p> .html()是用来读取元素的HTML内容（包括其Html标签）,.html()方法使用在多个元素上时，只读取第一个元素</p>
<p>.text()用来读取或修改元素的纯文本内容  对应js中的innerText</p>
<p>  text()用来读取元素的纯文本内容，包括其后代元素;.text()方法不能使用在表单元素上</p>
<p>.val()用来读取或修改表单元素的value值</p>
<pre><code>.val()是用来读取表单元素的&quot;value&quot;值,.val()只能使用在表单元素上
</code></pre><p>关于三者的区别</p>
<ol>
<li><p>.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。</p>
<p>2 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。</p>
</li>
</ol>
<p>jQuery中 wrap() wrapAll() 与 wrapInner()的区别：<a href="http://blog.csdn.net/qq_20545159/article/details/48323553" target="_blank" rel="external">http://blog.csdn.net/qq_20545159/article/details/48323553</a></p>
<ol>
<li>jQuery 库中的 $() 是什么？<br>答案：$() 函数是 jQuery() 函数的别称，乍一看这很怪异，还使 jQuery 代码晦涩难懂。一旦你适应了，你会爱上它的简洁。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你甚至可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。这个问题我已经见过好几次被提及，尽管它非常基础，它经常被用来区分一个开发人员是否了解 jQuery。</li>
<li>网页上有 5 个  div  元素，如何使用 jQuery来选择它们？<br>答案：另 一个重要的 jQuery 问题是基于选择器的。jQuery 支持不同类型的选择器，例如 ID 选择器、class 选择器、标签选择器。鉴于这个问题没提到 ID 和 class，你可以用标签选择器来选择所有的 div 元素。jQuery 代码：$(“div”)，这样会返回一个包含所有 5 个 div 标签的 jQuery 对象。更详细的解答参见上面链接的文章。</li>
<li>jQuery 里的 ID 选择器和 class 选择器有何不同？<br>答案：如 果你用过 CSS，你也许就知道 ID 选择器和 class 选择器之间的差异，jQuery 也同样如此。ID 选择器使用 ID 来选择元素，比如 #element1，而 class 选择器使用 CSS class 来选择元素。当你只需要选择一个元素时，使用 ID 选择器，而如果你想要选择一组具有相同 CSS class 的元素，就要用 class 选择器。在面试过程中，你有很大几率会被要求使用 ID 选择器和 class 选择器来写代码。下面的 jQuery 代码使用了 ID 选择器和 class 选择器：<br>$(‘#LoginTextBox’)  // Returns element wrapped as jQuery object with id=’LoginTextBox’<br>$(‘.active’) // Returns all elements with CSS class active.<br>正如你所见，从语法角度来说，ID 选择器和 class 选择器的另一个不同之处是，前者用字符”#”而后者用字符”.”。更详细的分析和讨论参见上面的答案链接。</li>
<li>如何在点击一个按钮时使用 jQuery 隐藏一个图片？<br>答案：这是一个事件处理问题。jQuery为按钮点击之类的事件提供了很好的支持。你可以通过以下代码去隐藏一个通过ID或class定位到的图片。你需要知道如何为按钮设置事件并执行hide() 方法，代码如下所示：<br>$(‘#ButtonToClick’).click(function(){<br> $(‘#ImageToHide’).hide();<br>});<br>我喜欢这个问题，因为很贴近实际使用，代码也不复杂。</li>
<li>$(document).ready() 是个什么函数？为什么要用它？<br>答案：这 个问题很重要，并且常常被问到。 ready() 函数用于在文档进入ready状态时执行代码。当DOM 完全加载（例如HTML被完全解析DOM树构建完成时），jQuery允许你执行代码。使用$(document).ready()的最大好处在于它适用 于所有浏览器，jQuery帮你解决了跨浏览器的难题。需要进一步了解的用户可以点击 answer链接查看详细讨论。</li>
<li>JavaScript window.onload 事件和 jQuery ready 函数有何不同？<br>答案：这 个问答是紧接着上一个的。JavaScript window.onload 事件和 jQuery ready 函数之间的主要区别是，前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。<br>另 一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。</li>
<li>如何找到所有 HTML select 标签的选中项？<br>答案：这是面试里比较棘手的 jQuery 问题之一。这是个基础的问题，但是别期望每个 jQuery 初学者都知道它。你能用下面的 jQuery 选择器获取所有具备 multiple=true 的  select   标签的选中项：<br>$(‘[name=NameOfSelectedTag] :selected’)<br>这段代码结合使用了属性选择器和 :selected 选择器，结果只返回被选中的选项。你可按需修改它，比如用 id 属性而不是 name 属性来获取  select  标签。</li>
<li>jQuery 里的 each() 是什么函数？你是如何使用它的？<br>答案：each() 函数就像是 Java 里的一个 Iterator，它允许你遍历一个元素集合。你可以传一个函数给 each() 方法，被调用的 jQuery 对象会在其每个元素上执行传入的函数。有时这个问题会紧接着上面一个问题，举个例子，如何在 alert 框里显示所有选中项。我们可以用上面的选择器代码找出所有选中项，然后我们在 alert 框中用 each() 方法来一个个打印它们，代码如下：<br>$(‘[name=NameOfSelectedTag] :selected’).each(function(selected) {<br> alert($(selected).text());<br>});<br>其中 text() 方法返回选项的文本。</li>
<li>你是如何将一个 HTML 元素添加到 DOM 树中的？<br>答案：你 可以用 jQuery 方法 appendTo() 将一个 HTML 元素添加到 DOM 树中。这是 jQuery 提供的众多操控 DOM 的方法中的一个。你可以通过 appendTo() 方法在指定的 DOM 元素末尾添加一个现存的元素或者一个新的 HTML 元素。</li>
<li>你能用 jQuery 代码选择所有在段落内部的超链接吗？<br>答案：这是另一个关于选择器的 jQuery 面试题。就像其他问题那样，只需一行 jQuery 代码就能搞定。你可以使用下面这个 jQuery 代码片段来选择所有嵌套在段落（ p 标签）内部的超链接（ a 标签）……</li>
<li>$(this) 和 this 关键字在 jQuery 中有何不同？<br>答案：这 对于很多 jQuery 初学者来说是一个棘手的问题，其实是个简单的问题。$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。</li>
<li>你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href?<br>答案：attr() 方法被用来提取任意一个HTML元素的一个属性的值. 你首先需要利用jQuery选择及选取到所有的链接或者一个特定的链接，然后你可以应用attr()方法来获得他们的href属性的值。下面的代码会找到页面中所有的链接并返回href值：<br>$(‘a’).each(function(){<br>alert($(this).attr(‘href’));<br>});</li>
<li>你如何使用jQuery设置一个属性值?<br>答案：前面这个问题之后额外的一个后续问题是，attr()方法和jQuery中的其它方法一样，能力不止一样. 如果你在调用attr()的同时带上一个值 例如. attr(name, value), 这里name是属性的名称，value是属性的新值。</li>
<li>jQuery中 detach() 和 remove() 方法的区别是什么?<br>答案：尽 管 detach() 和 remove() 方法都被用来移除一个DOM元素, 两者之间的主要不同在于 detach() 会保持对过去被解除元素的跟踪, 因此它可以被取消解除, 而 remove() 方法则会保持过去被移除对象的引用. 你也还可以看看 用来向DOM中添加元素的 appendTo() 方法.</li>
<li>你如何利用jQuery来向一个元素中添加和移除CSS类?<br>答案：通过利用 addClass() 和 removeClass() 这两个 jQuery 方法。动态的改变元素的class属性可以很简单例如. 使用类“.active”来标记它们的未激活和激活状态，等等.</li>
<li>使用 CDN 加载 jQuery 库的主要优势是什么 ?<br>答案：这 是一个稍微高级点儿的jQuery问题。好吧，除了报错节省服务器带宽以及更快的下载速度这许多的好处之外, 最重要的是，如果浏览器已经从同一个CDN下载类相同的 jQuery 版本, 那么它就不会再去下载它一次. 因此今时今日，许多公共的网站都将jQuery用于用户交互和动画, 如果浏览器已经有了下载好的jQuery库，网站就能有非常好的展示机会。</li>
<li>jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?<br>答案：ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。get() 方法是一个只获取一些数据的专门化方法。</li>
<li>jQuery 中的方法链是什么？使用方法链有什么好处？<br>答案：方法链是对一个方法返回的结果调用另一个方法，这使得代码简洁明了，同时由于只对 DOM 进行了一轮查找，性能方面更加出色。</li>
<li>你要是在一个 jQuery 事件处理程序里返回了 false 会怎样？<br>答案：这通常用于阻止事件向上冒泡。</li>
<li>哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？<br>答案：第一种，因为它直接调用了 JavaScript 引擎。<br>由“jQuery笔试题库”收集整理 </li>
</ol>
<p>javascript编程模式：私有函数公有化</p>
<div align="center"><br> <img src="/images/js/1_1.gif"><br> <img src="/images/js/1_2.gif"><br> <img src="/images/js/1_4.gif"><br></div></strong></strong>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/jquery题库/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-js集锦(上)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/js集锦(上)/">js集锦(上)</a>
    </h1>
  

        <a href="/2016/12/14/js集锦(上)/" class="archive-article-date">
  	<time datetime="2016-12-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于鼠标从子元素移动到父元素上时，会触发子元素的移出事件，通过冒泡也会触发父元素移出事件。此时，有两种方法解决该问题。一种是在子元素移出事件中阻止冒泡，另一种是在父元素移出事件设置target判断条件。当target为父元素本身时才执行</p>
<p>透明度<br>　　透明度是一个比较特殊的样式，因为IE8-浏览器不支持opacity，只能通过滤镜的方式写成filter:alpha(opacity=透明值)但是，由于IE浏览器获取计算样式时，可以获得自定义样式，所以虽然opacity属性在IE8-浏览器无法生效，但是可以获得它的值如果透明度做运动的话，则需要对运动函数进行重新封装<br>    [注意]由于透明度涉及小数计算，如0.07*100=&gt; 7.000000000000001，所以需要用Math.round()去掉尾巴</p>
<pre><code>history.go();
</code></pre><p>计算样式的兼容函数getCSS()</p>
<pre><code>function getCSS(obj,style){
   if(window.getComputedStyle){
     return getComputedStyle(obj)[style];
   }
   return obj.currentStyle[style];
 }
</code></pre><p>使用style可以获取行内嵌的样式，却不能得到内联或者链接的样式。但是通过获取或者设置计算后的样式来解决这个问题。之所以可以实现是因为不管你在哪里设置的样式，最终都会驻留在浏览器的计算样式里。<br>DOM2 级样式，window 对象下提供了getComputedStyle()方法。接受两个参数，需要计算的样式元素，第二个伪类(:hover)，如果没有没有伪类，就填null。<br>PS：IE 不支持这个DOM2 级的方法，但有个类似的属性可以使用currentStyle 属性。</p>
<pre><code>var box = document.getElementByIdx_x_x_x(&apos;box&apos;);
var style = window.getComputedStyle ?window.getComputedStyle(box, null) : null || box.currentStyle;//兼容方法
alert(style .color); //颜色在不同的浏览器会有rgb()格式
alert(style .border); //不同浏览器不同的结果
alert(style .fontFamily); //计算显示复合的样式值
alert(box.style.fontFamily); //空
</code></pre><p>还有一个问题就是：通过计算获取元素的大小，无关你是否是行内、内联或者链接，它经过计算后得到的结果返回出来。如果本身设置大小，它会返回元素的大小，如果本身没有设置，非IE浏览器会返回默认的大小，IE 浏览器返回auto。<br>注意：border 属性是一个综合属性，所以他在Chrome 显示了，Firefox 为空，IE 为undefined。<br>所谓综合性属性，就是XHTML 课程里所的简写形式，所以，DOM 在获取CSS 的时候，最<br>好采用完整写法兼容性最好，比如：border-top-color 之类的。<br>多值<br>　　如果一个元素有多个值同时运动时，像下面这样直接调用move()函数是有问题的</p>
<pre><code>move(test,&apos;opacity&apos;,0.1,-0.05);
move(test,&apos;left&apos;,-100,-1);
</code></pre><p>　　因为函数里面定时器的变量timer是一个公共变量，当一个运动停止时，会清除定时器。这时另一个运动即使没有完成，定时器已经停止了，就无法继续运动了所以，合适的做法是在参数对象obj下面设置一个自定义属性timers，timers为一个空对象，然后将定时器返回值储存在timers对象下的attr属性中，此时两个定时器不会相互干扰</p>
<pre><code>  &lt;style&gt;
     #test{width: 100px;height: 100px;background-color: lightblue;text-align:center;position:absolute;top: 0;left:    -100px;opacity:1;} 
     #test-in{width: 30px;height: 60px;background-color: orange;margin-left: 100px;position:relative;top: 20px;}
 &lt;/style&gt;
 &lt;div id=&quot;test&quot;&gt;
   &lt;div id=&quot;test-in&quot;&gt;分享到&lt;/div&gt;
 &lt;/div&gt; 
&lt;script&gt;

 test.onmouseover = function(){
    move(test,&apos;opacity&apos;,0.1,-0.05);
    move(test,&apos;left&apos;,0,10);
 }
 test.onmouseout = function(){
    move(test,&apos;opacity&apos;,1,0.05);
    move(test,&apos;left&apos;,-100,-10);
 }
 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   
 function move(obj,attr,target,speed){
    if(!obj.timers){
        obj.timers = {};
    }
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>多物体<br>　　如果在页面中有多个元素利用运动函数进行运动。由于定时器返回值在不同元素不同属性中都不会受影响。<br>所以，上面的运动函数可以直接使用</p>
<pre><code>&lt;style&gt; 
  div{height: 100px;width: 100px;position: absolute;left: 0;} 
  #test1{background-color: pink;top: 40px;}  
  #test2{background-color: lightblue;top: 150px;} 
 &lt;/style&gt; 
 &lt;div id=&quot;test1&quot;&gt;元素一&lt;/div&gt; 
 &lt;div id=&quot;test2&quot;&gt;元素二&lt;/div&gt; 
 &lt;button id=&quot;btn&quot;&gt;开始运动&lt;/button&gt;  
 &lt;button id=&quot;reset&quot;&gt;还原&lt;/button&gt;    
  &lt;script&gt; 
 reset.onclick = function(){history.go();}
 btn.onclick = function(){
    move(test1,&apos;width&apos;,300,10);
    move(test1,&apos;left&apos;,100,10);
    move(test2,&apos;width&apos;,500,20);
    move(test2,&apos;left&apos;,200,10);
 }

 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   

 function move(obj,attr,target,speed){
    if(!obj.timers){
        obj.timers = {};
    }
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>多物体<br>　　如果在页面中有多个元素利用运动函数进行运动。由于定时器返回值在不同元素不同属性中都不会受影响。<br>所以，上面的运动函数可以直接使用</p>
<pre><code>&lt;style&gt; 
  div{height: 100px;width: 100px;position: absolute;left: 0;} 
  #test1{background-color: pink;top: 40px;}  
  #test2{background-color: lightblue;top: 150px;} 
 &lt;/style&gt; 
 &lt;div id=&quot;test1&quot;&gt;元素一&lt;/div&gt; 
 &lt;div id=&quot;test2&quot;&gt;元素二&lt;/div&gt; 
 &lt;button id=&quot;btn&quot;&gt;开始运动&lt;/button&gt;  
 &lt;button id=&quot;reset&quot;&gt;还原&lt;/button&gt;    
  &lt;script&gt; 
 reset.onclick = function(){history.go();}
 btn.onclick = function(){
    move(test1,&apos;width&apos;,300,10);
    move(test1,&apos;left&apos;,100,10);
    move(test2,&apos;width&apos;,500,20);
    move(test2,&apos;left&apos;,200,10);
 }

 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   

 function move(obj,attr,target,speed){
    if(!obj.timers){
        obj.timers = {};
    }
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>回调<br>　 物体的多个属性可能不是同时运动，可能是一个属性运动完成之后，另一个属性再运动。如果要完成这种需求，就需要用到回调函数在运动函数中，定时器停止时，再调用运动函数，就可以接续运动效果</p>
<pre><code>&lt;style&gt;
 div{height: 100px;width: 100px;position: absolute;left: 0;}
 #test{background-color: pink;top: 40px;}
&lt;/style&gt;
 &lt;div id=&quot;test&quot;&gt;元素&lt;/div&gt;
 &lt;button id=&quot;btn&quot;&gt;开始运动&lt;/button&gt;
 &lt;button id=&quot;reset&quot;&gt;还原&lt;/button&gt; 
 &lt;script&gt;
 reset.onclick = function(){history.go();}
 btn.onclick = function(){
    move(test,&apos;left&apos;,100,20,function(){
        move(test,&apos;width&apos;,300,10)
    });
 }
 function getCSS(obj,style){
    if(window.getComputedStyle){
        return getComputedStyle(obj)[style];
    }
    return obj.currentStyle[style];
 }   
 function move(obj,attr,target,speed,fn){
    if(!obj.timers){obj.timers = {};}
    clearInterval(obj.timers[attr]);
    var cur;
    obj.timers[attr] = setInterval(function(){
        if(attr == &apos;opacity&apos;){
            cur = Math.round(getCSS(obj,attr)*100);
            if((cur - target*100)*speed &lt; 0){
                obj.style.opacity = (cur + speed*100)/100;
                obj.style.filter = &apos;alpha(opacity=&apos; + (cur + speed*100) + &apos;)&apos;;
            }else{
                obj.style.opacity = target;
                obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
                fn &amp;&amp; fn.call(obj);
            }
        }else{
            cur = parseInt(getCSS(obj,attr));
            if((cur - target)*speed &lt; 0){
                obj.style[attr] = cur + speed + &apos;px&apos;;
            }else{
                obj.style[attr] = target + &apos;px&apos;;
                clearInterval(obj.timers[attr]);
                obj.timers[attr] = 0;
                fn &amp;&amp; fn.call(obj);
            }    
        }        
    },30);        
 }    
&lt;/script&gt;
</code></pre><p>函数完善<br>【速度参数】<br>上面封装的函数中，传递速度参数时，需要在速度参数前添加正负号作为方向标识。实际上，这步可以写在函数的程序内，而只传递正的速度参数即可</p>
<pre><code>speed = parseInt(getCSS(obj,attr)) &lt; target ? speed : -speed;
</code></pre><p>【拉回操作】<br>　　还有一个可以升级的地方，就是拉回操作。通过判断元素是否到达目标点，如果超过目标点后，将元素拉回到目标点位置</p>
<pre><code>cur = parseInt(getCSS(obj,attr));
  if((cur - target)*speed &lt; 0){
     obj.style[attr] = cur + speed + &apos;px&apos;;
  }else{
     obj.style[attr] = target + &apos;px&apos;;
     clearInterval(obj.timers[attr]);
     obj.timers[attr] = 0;
     fn &amp;&amp; fn.call(obj);
  } 
</code></pre><p>更合理的操作，应该是元素肯定不能超过目标点<br>　　所以应该把判断条件用来处理speed，当speed是一个合适的值时，再赋值给obj.style[attr]，可更改如下</p>
<pre><code> cur = parseInt(getCSS(obj,attr));
//若速度设置值使得元素超过目标点时，将速度设置值更改为目标点值 - 当前值
 if((cur +speed - target)*speed &gt; 0){
    speed = target - cur; 
 }
//将合适的speed值赋值给元素的样式
obj.style[attr] = cur + speed + &apos;px&apos;;

//当元素到达目标点后，停止定时器
if(speed == target - cur){
  clearInterval(obj.timers[attr]);
  obj.timers[attr] = 0;
  fn &amp;&amp; fn.call(obj); 
}
</code></pre><p>【使用步长】<br>　　其实，把元素的位移变化命名为速度并不合适，只是因为约定俗成的关系才如此起名，将其命名为步长step更为合适，定时器每运行一次，该元素前面一步<br>最终函数</p>
<pre><code>function getCSS(obj,style){
   if(window.getComputedStyle){
       return getComputedStyle(obj)[style];
   }
   return obj.currentStyle[style];
} 
function move(obj,attr,target,step,fn){
   //如果没有建立定时器对象，则在obj下建立定时器对象
   if(!obj.timers){obj.timers = {};}
   //清除定时器
   clearInterval(obj.timers[attr]);
   //声明当前值变量cur
   var cur;
   //判断步长step的正负值
   step = parseInt(getCSS(obj,attr)) &lt; target ? step : -step;
   //开启定时器
   obj.timers[attr] = setInterval(function(){
       //如果样式是透明度
       if(attr == &apos;opacity&apos;){
           //对当前值的取值进行四舍五入，去除由于javascript小数计数中的bug存在的小尾巴
           cur = Math.round(getCSS(obj,attr)*100);
           if((cur - target*100)*step &lt; 0){
               //设置透明度
               obj.style.opacity = (cur + step*100)/100;
               //IE兼容
               obj.style.filter = &apos;alpha(opacity=&apos; + (cur + step*100) + &apos;)&apos;;
           //透明度到达指定目标时
           }else{
               obj.style.opacity = target;
               obj.filter = &apos;alpha(opacity=&apos; + target + &apos;)&apos;;
               //清除定时器
               clearInterval(obj.timers[attr]);
               obj.timers[attr] = 0;
               //设置回调函数
               fn &amp;&amp; fn.call(obj);
           }
       //当样式不是透明度时
       }else{
           //获取样式当前值并赋值给cur
           cur = parseFloat(getCSS(obj,attr));
           ////若步长设置值使得元素超过目标点时，将步长设置值更改为目标点值 - 当前值
           if((cur + step - target)*step &gt; 0){
               step = target - cur;
           }
           //将合适的步长值赋值给元素的样式
           obj.style[attr] = cur + step + &apos;px&apos;;
           //当元素到达目标点后，停止定时器
           if(step == target - cur){
               clearInterval(obj.timers[attr]);
               obj.timers[attr] = 0;
               fn &amp;&amp; fn.call(obj);    
           }
       }        
   },30);        
}
</code></pre><p>【实例】<br>　　下面以一个实例来说明move函数的应用，点击document即可查看效果</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;Document&lt;/title&gt;
   &lt;style&gt;
    div{
     width: 50px;
     height: 50px;
     position: absolute;
     top: 0;
     background-color:lightblue;
    }
    div:nth-child(odd){
      background-color:pink;
    }
   &lt;/style&gt;
  &lt;/head&gt;
 &lt;body&gt;
 &lt;script src=&quot;move.js&quot;&gt;&lt;/script&gt;
 &lt;script&gt;
   var str = &apos;&apos;;
   var len = 10;
   var timer;
   var num = 0;
   for(var i = 0; i &lt; len; i++){
      str+= &apos;&lt;div style=&quot;left:&apos;+60*i+&apos;px;&quot;&gt;&lt;/div&gt;&apos;;
    }
   document.body.innerHTML = str;
   document.onclick = function(){
     var aDiv = document.getElementsByTagName(&apos;div&apos;);
     if(timer) return;
     timer = setInterval(function(){
       move(aDiv[num++],&apos;top&apos;, 200,10,function(){
          var _this = this;
          setTimeout(function(){
            move(_this,&apos;top&apos;, 0,10);
          },1000)
     });
     if(num == len){
       clearInterval(timer);
       num = 0;
       setTimeout(function(){
        timer = 0;
        },2000);
       }
    },100);
   }
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>XML代表可扩展标记语言，是一种比较灵活的数据格式，很多应用程序存储数据都喜欢用到它，结构像HTML，也包含元素，标签以及属性，模型都一样。它的一大优势在于它是一种可扩展的格式，你并不会受制于某种预设的数据结构；并且它还符合DOM标准，使用AJAX调用获取到的数据就像解析HTML一样，通过相应的DOM方法和属性解析它：<br>但是XML的一个严重的缺陷在于它不能用于跨域名的Aiax调用，也就是说每一个Ajax调用的XML数据都必须和执行调用的脚本处于同一域名内，否则请求会失败。<br>HTML存储也相似，它与Ajax结合起来最简单。采用这种方式的数据格式的重要因素是速度，HTML代码段无需在客户端解析就能直接将其输出到DOM之中，所以我们不需要再额外的编写JavaScript代码解析HTML。<br>说说它的缺点，它存储的数据可能和HTML代码混合在一起，所以说可维护性降低。另外在编写处理代码时，开发者可能需要在服务器端做一些精细的控制手段。<br>以下是使用JavaScript进行数据存储的手段，循序渐进…</p>
<p>变量<br> JavaScript最为基础的数据存储方式，它接受字符串、数值、布尔等。最核心的内容是它的作用域问题。<br>于变量相关的性能问题：<br>  变量在声明完之后，就会被缓存到JavaScript文件中，于是在作用域内就可以反复的使用它们了，获取变量的开销微乎其微，只要数据的使用次数大于1，就应该将其存入变量。<br>数组<br>   数组跟普通数组、关联数组和多维数组，它们都是元素列表，这种形式是各种数据存储中非常灵活的一种。掌握了数组最基本的形式，也会对其他复杂形式的运用大有脾益。数组元素的访问合一处是常见的基本交互代码。鉴于数组这种数据存储类型的重要性，JavaScript为数组交互操作提供了大量的专属方法：<br>.join() 方法 可以指定某个字符作为数组内每个元素的连接符；slice() 方法可以输出数组中某个范围内的元素；shift()和unshift() 方法 分别用于在数组头部移除或新增元素；pop() 方法用于移除并返回数组中的最后一个元素；concat() 方法用于将多个数组拼接成一个数组，按参数的先后而定；sort()方法可以按照字母表顺序或自定义顺序来排列数组的元素.</p>
<p>对象<br>  在数据变得更加复杂、更加难以管理的情况下，我就会选择将数组转换为对象。因为对象的存储方式更加易读。<br>  对象对效率的影响<br>  上面的代码只有一层，然而它是可以无限嵌套的。对象能更好的组织代码，提高模块化的程度。不过与此同时，还是需要考虑性能和可维护性的权衡问题，因为它需要寻找这三者中的一个。如果是运用面向对象编程技术，嵌套达到3层及以上，就会引发性能问题；但是在服务器端运用时就不是这样了，所以前端开发者要决定什么时候使用面向对象编程技术。</p>
<p>JSON<br>  JSON是一种易于同jacascript 集成的数据格式，它通常是在用JavaScript调用外部服务器时使用的。JSON数据存放于独立的文件中，而且通常位于另一台完全不同的服务器上。它现在是最常见的一种调用API服务时所使用的数据格式，人们之所以选中它，是因为此格式非常易于阅读。起初，JSON格式是作为一种XML格式的替代方案而出现的，但很快它就在数据交换领域占据了主流的地位。它是一种轻量级的数据格式，易于通过远程Ajax调用进行跨域名访问。尽管JavaScript对JSON格式的解析提供了原生的支持，但它还是一种独立于平台的格式，客户端与服务器端在数据交换时都可以使用。</p>
<p>由于JSON格式具备跨域名访问的能力，所以为了防止一切恶意行为，我们务必只使用从可信的数据源中获取JSON<br>JSON最常见的用途就是配合API调用，在于API为基础的网络程序开发环境中，使用何种后端语言进行开发，数据格式都无需改变.</p>
<p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间，而事件流(又叫事件传播)描述的是从页面中接收事件的顺序。</p>
<p>IE的事件流叫做事件冒泡(event bubbling)，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)<br>[注意]所有现代浏览器都支持事件冒泡，但在具体实现在还是有一些差别。IE9、Firefox、Chrome、Safari将事件一直冒泡到window对象</p>
<p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前就捕获它<br>[注意]IE9、Firefox、Chrome、Safari等现代浏览器都支持事件捕获，但是从window对象开始捕获<br>addEventListener()方法中的第三个参数设置为true时，即为事件捕获阶段<br>事件流<br>　　事件流又称为事件传播，DOM2级事件规定的事件流包括三个阶段：事件捕获阶段(capture phase)、处于目标阶段(target phase)和事件冒泡阶段(bubbling phase)<br>　　首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应</p>
<p>事件处理程序又叫事件侦听器，实际上就是事件的绑定函数。事件发生时会执行函数中相应代码。事件处理程序有HTML事件处理程序、DOM0级事件处理程序、DOM2级事件处理程序和IE事件处理程序四类</p>
<p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。</p>
<p>事件流<br>eventPhase<br>　　eventPhase属性返回一个整数值，表示事件目前所处的事件流阶段</p>
<p>　　0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段</p>
<p>　　[注意]IE8-浏览器不支持</p>
<p>如何判断是手机还是电脑访问网站:<br>   现在由于手机功能的强大，使用手机上网的用户越来越多，那么就需要判断用户是用何种客户端登陆的网站，如果使用的是电脑则使用电脑版本的网页，如果使用的手机则使用手机版本的网页，下面是一段能够判断是手机还是电脑的代码：</p>
<pre><code>function check() { 
 var userAgentInfo=navigator.userAgent; 
 var Agents =new Array(&quot;Android&quot;,&quot;iPhone&quot;,&quot;SymbianOS&quot;,&quot;Windows Phone&quot;,&quot;iPad&quot;,&quot;iPod&quot;); 
 var flag=true; 
 for(var v=0;v&lt;Agents.length;v++) { 
    if(userAgentInfo.indexOf(Agents[v])&gt;0) { 
      flag=false; 
      break; 
    } 
  } 
  return flag; 
 }
</code></pre><p>在以上代码中，如果如果flag返回值为true则说明是电脑客户端，如果是false，则说明使用的是移动客户端，代码比较简单这里就不多介绍了，直接套用就可以了.<br>javascript实现的验证码代码实例<br>代码：<br>    &lt;!DOCTYPE html&gt;<br>     <html><br>      <head><br>       <meta charset="gbk"><br>       <meta name="author" content="http://www.108js.com/"><br>       <title>javascript实现的验证码代码实例</title><br>      </head><br>      <style type="text/css"><br>       .code<br>       {<br>        background:url(code_bg.jpg);<br>        font-family:Arial;<br>        font-style:italic;<br>        color:blue;<br>        font-size:30px;<br>        border:0;<br>        padding:2px 3px;<br>        letter-spacing:3px;<br>        font-weight:bolder;<br>        float:left;<br>        cursor:pointer;<br>        width:150px;<br>        height:60px;<br>        line-height:60px;<br>        text-align:center;<br>        vertical-align:middle;<br>       }<br>      a<br>      {<br>       text-decoration:none;<br>       font-size:12px;<br>       color:#288bc4;<br>      }<br>      a:hover<br>      {<br>       text-decoration:underline;<br>     }<br>     </style><br>     <script type="text/javascript"><br>     var code;<br>     function createCode()<br>     {<br>       code = “”;<br>       var codeLength = 6; //验证码的长度<br>       var checkCode = document.getElementById(“checkCode”);<br>       var codeChars = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9,<br>                ‘a’,’b’,’c’,’d’,’e’,’f’,’g’,’h’,’i’,’j’,’k’,’l’,’m’,’n’,’o’,’p’,’q’,’r’,<br>                ‘s’,’t’,’u’,’v’,’w’,’x’,’y’,’z’,<br>                ‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’, ‘J’, ‘K’, ‘L’, ‘M’, ‘N’, ‘O’,<br>                ‘P’, ‘Q’, ‘R’, ‘S’, ‘T’, ‘U’, ‘V’, ‘W’, ‘X’, ‘Y’, ‘Z’);<br>                 //所有候选组成验证码的字符，当然也可以用中文的<br>      for(var i = 0; i &lt; codeLength; i++)<br>      {<br>        var charNum = Math.floor(Math.random() * 52);<br>        code += codeChars[charNum];<br>      }<br>      if(checkCode)<br>      {<br>        checkCode.className = “code”;<br>        checkCode.innerHTML = code;<br>      }<br>     }<br>     function validateCode()<br>     {<br>       var inputCode=document.getElementById(“inputCode”).value;<br>       if(inputCode.length &lt;= 0)<br>       {<br>         alert(“请输入验证码！”);<br>       }<br>       else if(inputCode.toUpperCase() != code.toUpperCase())<br>       {<br>         alert(“验证码输入有误！”);<br>         createCode();<br>       }<br>       else<br>       {<br>        alert(“验证码正确！”);<br>      }<br>     }<br>     </script><br>     <body onload="createCode()"><br>      <form id="form1" runat="server" onsubmit="validateCode()"><br>       <div><br>        <table border="0" cellspacing="5" cellpadding="5"><br>         <tr><br>          <td></td><br>          <td><div class="code" id="checkCode" onclick="createCode()"></div></td><br>          <td><a href="#" onclick="createCode()">看不清换一张</a></td><br>         </tr><br>         <tr><br>           <td>验证码：</td><br>           <td><input style="float:left;" type="text" id="inputCode"></td><br>           <td>请输入验证码</td><br>         </tr><br>         <tr><br>           <td></td><br>           <td><input id="Button1" onclick="validateCode();" type="button" value="确定"></td><br>           <td></td><br>         </tr><br>        </table><br>       </div><br>      </form><br>     </body><br>    </html></p>
<p>js拖拽DIV到页面任何位置<br>js拖拽到页面任何位置</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;Document&lt;/title&gt;
 &lt;style&gt;
   #main{width:100px;height:100px;background:#ffccff;position:absolute;}
 &lt;/style&gt;
 &lt;script&gt;
  /*1：拖拽的时候有文字选中会有问题；
          原因：这是浏览器的默认拖拽文字的行为
          解决方案：标准浏览器下：阻止默认行为,在onmousedown结尾加上return false即可
                    ie8及其以下版本：设置全局捕获，方法如下设置全局捕获setCapture最后释放releaseCapture*/
       window.onload = function(){
           var oDiv = document.getElementById(&quot;main&quot;);
           var odiv = document.getElementById(&quot;div&quot;);
           oDiv.onmousedown = function(ev){

                   var ev = ev || event;
                   var disX = ev.clientX - this.offsetLeft;
                   var disY = ev.clientY - this.offsetTop;

                   if(oDiv.setCapture){
                     oDiv.setCapture();
                   }
                document.onmousemove = function(ev){
                    //这里为什么使用document，是因为快速拖拽的话会鼠标丢失，
                    var ev = ev || event;
                    oDiv.style.left = ev.clientX - disX+&quot;px&quot;;
                    oDiv.style.top = ev.clientY - disY+&quot;px&quot;;
                }

                document.onmouseup = function(ev){
                    document.onmousemove = document.onmouseup = null;
                    //为何不用oDiv.onmouseup是因为被挡住之后会无视掉遮挡的元素
                    if(oDiv.releaseCapture){

                      oDiv.releaseCapture();
                    }
                }
                return false;
           }
       }
   &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    2015/11/17wf r3qr
   &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰<br>另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。<br>所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。<br>web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题!<br>前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse<em>*</em>等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控.<br>利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理.<br>有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.<br>下面是一个小例子，若我们要对divMain这个div元素里面的内容进行保护:<br>1.对divMain执行setCapture方法:<br>document.getElementById(“divMain”).setCapture()；<br>2.加入一按钮btnChange，可以进行setCapture和releaseCapture切换，定义一全局变量；<br>var isFreeze = true；<br>3.在btnChange的onclick事件中，加入下列代码:<br>代码如下:</p>
<pre><code>function change_capture(obj) { 
isFreeze = !isFreeze; 
if(isFreeze) { 
obj.value = &quot;releaseCapture&quot;; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
obj.value = &quot;setCapture&quot;; 
alert(&apos;保存！&apos;); //可以执行重要操作 
document.getElementById(&quot;divMain&quot;).releaseCapture(); 
} 
} 

divMain的onclick事件中，加入下列代码: 
复制代码 代码如下:

function click_func() 
{ 
if(event.srcElement.id == &quot;divMain&quot;) 
{ 
alert(&quot;处理中...&quot;)； //常规操作 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
else 
{ 
if(isFreeze &amp;&amp; event.srcElement.id != &quot;btnChange&quot;) 
{ 
alert(&apos;未执行releaseCapture，不能点击&apos;)； 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
} 
} 
</code></pre><p>对ALT+F4进行处理，在body的onkeydown事件中加入下列代码:<br>代码如下:</p>
<pre><code>function keydown_func() 
{ 
if (event.keyCode==115 &amp;&amp; event.altKey) //ALT+F4 
{ 
if(isFreeze) 
{ 
alert(&apos;保存！&apos;)； //可以执行重要操作 
} 
//window.showModelessDialog(&quot;about:blank&quot;，&quot;&quot;，&quot;dialogWidth:1px；dialogheight:1px&quot;)； 
//return false； 
} 
document.getElementById(&quot;divMain&quot;).setCapture()； 
} 
</code></pre><p>完整代码如下: </p>
<pre><code>&lt;html&gt; 
&lt;head&gt; 
&lt;title&gt; 
setCapture和releaseCapture的小应用 
&lt;/title&gt; 
&lt;script&gt; 
&lt; !-- 
var isFreeze = true; 
function click_func() { 
if (event.srcElement.id == &quot;divMain&quot;) { 
alert(&quot;处理中...&quot;); //常规操作 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
if (isFreeze &amp;&amp; event.srcElement.id != &quot;btnChange&quot;) { 
alert(&apos;未执行releaseCapture,不能点击&apos;); 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} 
} 
} 
function keydown_func() { 
if (event.keyCode == 115 &amp;&amp; event.altKey) //ALT+F4 
{ 
if (isFreeze) { 
alert(&apos;保存！&apos;); //可以执行重要操作 
} 
//window.showModelessDialog(&quot;about:blank&quot;,&quot;&quot;,&quot;dialogWidth:1px;dialogheight:1px&quot;); 
//return false; 
} 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} 
function change_capture(obj) { 
isFreeze = !isFreeze; 
if (isFreeze) { 
obj.value = &quot;releaseCapture&quot;; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
} else { 
obj.value = &quot;setCapture&quot;; 
alert(&apos;保存！&apos;); //可以执行重要操作 
document.getElementById(&quot;divMain&quot;).releaseCapture(); 
} 
} 
//--&gt; 
&lt;/script&gt; 
&lt;/head&gt; 
&lt;body onkeydown=&quot;keydown_func();&quot;&gt; 
&lt;div id=&quot;divMain&quot; onclick=&quot;click_func();&quot;&gt; 
点一下IE的菜单或者按钮看看:) 又或者IE窗口外的地方 
&lt;input type=&quot;button&quot; value=&quot;releaseCapture&quot; onclick=&quot;change_capture(this);&quot; 
id=&quot;btnChange&quot;&gt; 
&lt;script language=&quot;javascript&quot;&gt; 
document.getElementById(&quot;divMain&quot;).setCapture(); 
&lt;/script&gt; 
&lt;/div&gt; 
&lt;/body&gt; 
&lt;/html&gt; 
</code></pre><p>关于javascript中call和apply函数的应用<br>我们经常在javascipt中的面向对象应用中遇到call和apply函数；有时会被搞糊涂。其实它们可以改变函数或对象中的this保留字的值；this保留字的默认值就是这个类本身。举例说明：<br>代码如下:</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 
&lt;head&gt; 
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html； charset=gb2312&quot; /&gt; 
&lt;script language=&quot;javascript&quot;&gt; 
test = { 
value: &apos;default&apos;，exec: function() { 
alert(this.value)； 
} 
} 
function hhh(obj) { 
test.exec()；test.exec.apply(obj)； 
} 
&lt;/script&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;input type=&quot;button&quot; onclick=&quot;hhh(this)；&quot; value=&quot;test&quot; /&gt; 
&lt;/body&gt; 
&lt;/html&gt; 
</code></pre><p>运行以上的页面就很快明白了.<br>call和apply函数可以处理匿名函数<br>关于类的初始化应用如下：<br>代码如下:</p>
<pre><code>Person = function() { 
this.Init.apply(this, arguments); 
}; 
Person.prototype = { 
first: null, 
last: null, 
Init: function(first, last) { 
this.first = first; 
this.last = last; 
}, 
fullName: function() { 
return this.first + &apos; &apos; + this.last; 
}, 
fullNameReversed: function() { 
return this.last + &apos;, &apos; + this.first; 
} 
}; 
var s = new Person2(&apos;creese&apos;, &apos;yang&apos;); 
alert(s.fullName()); 
alert(s.fullNameReversed()); 
</code></pre><p>call和apply函数可以赋值函数内容（带匿名参数；但不触发）<br>关于函数绑定事件应用如下：<br>代码如下:</p>
<pre><code>Function.prototype.BindForEvent = function() { 
var __m = this， object = arguments[0]， args = new Array()； 
for(var i = 1； i &lt; arguments.length； i++){ 
args.push(arguments[i])； 
} 
return function(event) { 
return __m.apply(object， [( event || window.event)].concat(args))； 
} 
} 
</code></pre><p>call和apply函数关于函数绑定参数应用如下：<br>代码如下:</p>
<pre><code>Function.prototype.Bind = function() { 
var __m = this， object = arguments[0]， args = new Array()； 
for(var i = 1； i &lt; arguments.length； i++){ 
args.push(arguments[i])； 
} 
return function() { 
return __m.apply(object， args)； 
} 
} 
</code></pre><p>call和apply函数功能是一样的；就是参数格式不同；fun.call(obj， arguments)；apply的arguments是数组形式；call则是单数形式。<br>screen对象通常包含下列属性(许多浏览器都加入了自己的属性)：</p>
<p> 1.availHeight : 窗口可以使用的屏幕的高度（以像素计）其中包括操作系统元素（如window工具栏）需要的空间。</p>
<p> 2.availWidth : 窗口可以使用的屏幕的宽度（以像素计）。</p>
<p> 3.colorDepth : 用户表示的颜色的位数，大多数系统采用32位的。</p>
<p> 4.height ：屏幕的高度，以像素计算。</p>
<p> 5.width ： 屏幕的宽度，以像素计算。</p>
<p>确定新窗口的大小时，availHeight和availWidth属性比较有用。比如可以用下面的代码填充用户的屏幕：</p>
<p>  window.moveTo(0,0);<br>  window.resizeTo(screen.availWidth,screen.availHeight);</p>
<p>另外，这些数据与站点的流量工具一起使用，可以判断用户的图形接受能力。</p>
<p>div应该是division的缩写吧！！！！</p>
<ul>
<li>一、任选一题（5分）<br>a) ul、ol、dl的区别？<br>b) div、section、article的区别？</li>
</ul>
<p>a: ul是无序列表，ol是有序列表，dl是定义列表有层次关系。<br>b: div无语义，只是用作布局。<br> section是有一定语义的div，表示一个专题，一般有标题，但是不可以乱用。只有内容明确需要出现在大纲中时才会使用。<br> artical是更特殊的section，他是一个独立完整的内容块。比如用在文章，评论等。</p>
<ul>
<li><p>二、html5对input新增了哪些高级属性？（5分）<br>number ,date,color,range,email,search,tel,url</p>
</li>
<li><p>三、每题都需回答（15分）<br>a) 如何用CSS控制文本单行溢出省略？并且大致说出多行省略的思路。<br>b) 谈谈响应式布局？<br>c) CSS3有哪些高级选择器？<br>a:css实现单行溢出省略是利用text-overflow：ellipsis，white-space：nowrap和overflow：hidden属性实现的。<br>（新版主流浏览器测试通过）<br>b:响应式布局是为了解决现在市场上的浏览器尺寸不一的现状，让用户无论是使用移动端还是电脑端访问都有很好体验。html5也因此加入了媒体查询等一系列针对响应式布局的新元素。<br>c:css3有属性选择器{E[att$=’val’],E[att~=’val’],E[att^=’val’]}<br>伪类选择器{E:not(),E:last-child,E:only-child,E:nth-child(n),E:nth-last-child(),E:empty}<br>伪对象选择器{E::selection}<br>关系选择器{E~F}</p>
</li>
<li><p>四、请逐一解释他们：<br>Node.js、React Native、Angular.js、Grunt/Gulp、Webpack、Git、JSONP（10分）<br>Node.js:<br> Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。<br>React Native:<br>React Native 结合了Web应用和Native应用的优势，可以使用JavaScript来开发iOS和Android原生应用。在JavaScript中用 React抽象操作系统原生的UI组件，代替DOM元素来渲染等。<br>Angular.js: （它有坑吗？？？？）<br> AngularJS诞生于2009年，由Misko Hevery等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。<br>Grunt/Gulp:<br> 自动构建系统，开发者可以使用它在网站开发过程中自动执行常见任务。<br>Webpack：<br> 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。<br>Git：<br> Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。·<br>JSONP：<br> 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端， 然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
</li>
<li><p>五、分别说出下述输出结果（15分）</p>
<pre><code>!function(){
  this.length = 10;
  var fn = function(){
    console.log(this.length);//输出多少？?输出2,this指向数组arr
    console.log(this[1]);//输出多少？输出&quot;hello layui&quot;
  }, arr = [fn, &apos;hello layui&apos;];
  fn.length = 100;
  arr[0]();
}();
</code></pre></li>
<li><p>六、封装一个cont方法，能实现如此调用：</p>
<pre><code>cout(a)(b)(c)(d)(e)… 并且返回的值为参数连剩的结果，即a*b*c*d*e*…。如cout(1)(3)(7) 得到21 （15分）
init=0;  //设置一个全局变量
var muti=function(m)
{
   init=init*m;
   return muti
 }

 muti.toString=function()  //这是关键的一步
 {
     return init;
  }

  function count(m)  //最终我们要调用的函数
  {
     init=m ;// 初始化，否则init是0，那么永远乘 都是 0，也是很关键的一步
     return muti;//最终返回的是 元对象（不是实例化过后的对象哦)
  }
  alert(count(3)(4)(5))
</code></pre></li>
<li><p>七、任选一题（15分）<br>a) 谈谈你对模块化开发的理解？<br>b) 你认为什么是更科学效率的组件化？<br>c) ES6有哪些你觉得不错的特性？</p>
</li>
<li><p>八、任选一题（20分）<br>a) 实现一个手势滑动轮播图，可以直接用代码表述，也可以只说说思路。<br>b) 大致描述如何实现一个基于Express的MVC框架？</p>
</li>
</ul>
<ul>
<li>九、scrollWidth,clientWidth,offsetWidth的区别 <a href="http://www.108js.com/article/article2/20130.html?id=2380" target="_blank" rel="external">http://www.108js.com/article/article2/20130.html?id=2380</a><br>（scrollHeight、offsetHeight、clientHeight 同样可按本文去理解。）<br>这是一个很复杂的问题，让我们想像一下：<br>document.documentElement.scrollWidth<br>document.documentElement.offsetWidth<br>document.documentElement.clientWidth<br>document.body.scrollWidth<br>document.body.offsetWidth<br>document.body.clientWidth<br>有 6 个属性要测，这 6 个属性要放在 4 种情况中：<br>没有指定 DOCTYPE，网页内容没有超过窗口宽度；<br>没有指定 DOCTYPE，网页内容超过窗口宽度；<br>指定 DOCTYPE，网页内容没有超过窗口宽度；<br>指定 DOCTYPE，网页内容超过窗口宽度；<br>然后这 4 种情况要放到几个主流浏览器中，假设只有 3 种浏览器：<br>IE<br>Firefox<br>Chrome<br>算一下，6 <em> 4 </em> 3，有 72 种情况要测试，天啊。并且不要指望 Firefox 和 Chrome 结果是一样的，不要指望 Firefox 不会出现让您费解的结果，所以这真是一件恼火的事。<br>从应用入手简化分析<br>72 种测试情况确实很恼火，但我们回过头来一想，我们到底想要什么？<br>我认为我们想要两个东西：<br> 一是 scrollWidth（scrollHeight），虽然它用处不大，但应该比 offsetWidth（offsetHeight）有用得多。它表示的是文档区的宽度（高度），比如一个网页，特别是门户网站，拖很长，就要把没有显示出来的内容都计算进去。<br> 二是视口 viewport，就是clientWidth，就是窗口中可显示内容的那块区域，就是我们常常看到页面上飞行广告，飞来飞去，碰到边边要反弹的那一块。<br>测试结果<br> 结果很复杂，就不说了(请下载测试代码），这里只说实际中怎么使用：<br>要使用 scrollWidth，取 document.documentElement.scrollWidth 与 document.body.scrollWidth 的最大值；<br>要使用 clientWidth，如果 document.documentElement.clientWidth &gt; 0，则使用 document.documentElement.clientWidth，否则使用 document.body.clientWidth。</li>
</ul>
<p>表达式为：<br>  var scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);<br>  var clientWidth = document.documentElement.clientWidth || document.body.clientWidth<br>Javascript引擎是单线程运行的，浏览器只有一个线程在运行JavaScript程序。因为单线程的设计，所以免去了复杂的多线程同步问题。<br>　　当设置一个定时的时候，浏览器会在设定的时间后将你指定的回调函数插入任务序列，而非立即执行。如果设定定时时间为0，表示立即插入任务序列，而不是立即执行，仍然要等队列中任务执行完毕，轮到你，你才执行。<br>彻底弄清offset<br> <a href="http://www.108js.com/article/article2/20064.html?id=719" target="_blank" rel="external">http://www.108js.com/article/article2/20064.html?id=719</a><br> <a href="http://www.108js.com/article/article2/20063.html?id=718" target="_blank" rel="external">http://www.108js.com/article/article2/20063.html?id=718</a><br> JS对用户隐藏源代码</p>
<pre><code> &lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;例20.4 对用户隐藏源代码&lt;/title&gt;
  &lt;script&gt;
&lt;!--
   function clear(){
    Source=document.body.firstChild.data;
    //这段代码里我们看到一个新鲜的属性--data
    //它引用一个COMMENT_NODE类型的DOM对象的文本内容
    //这里用到了一个技巧，实际上我们把body的内容整个构建为一个COMMENT_NODE
    //然后用data取出内容再回写入body的innerHTML，其结果就是，在页面上
    //用鼠标右键查看源代码的时候查看不到body中的任何源代码
    document.open();
    document.close();
    document.title=&quot;&quot;;
    document.body.innerHTML=Source;
   }
--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=clear()&gt;
&lt;!--
  &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;770&quot; height=&quot;200&quot;&gt;
   &lt;tr&gt;
    &lt;td&gt;看看能不能看到源代码&lt;/td&gt;
   &lt;/tr&gt;
  &lt;/table&gt;
--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>JS浏览器检测代码</p>
<pre><code>&lt;html&gt;
&lt;title&gt;浏览器检测&lt;/title&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;

 function isIE(){   
  return navigator.appName.indexOf(&quot;Microsoft Internet Explorer&quot;)!=-1 &amp;&amp; document.all;   
 }   
 function isIE6() {   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 6.0&quot;)==&quot;-1&quot;?false:true;   
 }   
 function isIE7(){   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 7.0&quot;)==&quot;-1&quot;?false:true;   
 }   

 function isIE8(){   
   return navigator.userAgent.split(&quot;;&quot;)[1].toLowerCase().indexOf(&quot;msie 8.0&quot;)==&quot;-1&quot;?false:true;   
 }   
 function isNN(){   
   return navigator.userAgent.indexOf(&quot;Netscape&quot;)!=-1;   
 }   
 function isOpera(){   
   return navigator.appName.indexOf(&quot;Opera&quot;)!=-1;   
 }   
  function isFF(){   
   return navigator.userAgent.indexOf(&quot;Firefox&quot;)!=-1;   
  }   
  function isChrome(){   
    return navigator.userAgent.indexOf(&quot;Chrome&quot;) &gt; -1;     
   } 

  function showResult(){        
    if(isChrome()){
     alert(&quot;这是谷歌浏览器&quot;);    
    }

    if(isIE()){
     alert(&quot;这是IE&quot;);
    }

    if(isIE6()){
     alert(&quot;这是isIE6&quot;);
    }

    if(isIE7()){
     alert(&quot;这是isIE7&quot;);
    }

    if(isIE8()){
     alert(&quot;这是IisIE8&quot;);
     }

    if(isNN()){
     alert(&quot;这是isNN&quot;);
    }

    if(isOpera()){
     alert(&quot;这是isOpera&quot;);
     }

    if(isFF()){
     alert(&quot;这是Firefox&quot;);
    }
  }

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;center&gt;&lt;input type=&quot;button&quot; onclick=&quot;showResult()&quot; name=&quot;check&quot; value=&quot;检测&quot;&lt;/center&gt;
&lt;/body&gt;&lt;/html&gt;

javaScript防盗链代码

&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;防止盗链&lt;/title&gt;
  &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
   &lt;!--
    //当前文档的URL
    var currentURL = document.URL;
    //上一个文档的URL
    var frontURL = document.referrer;
    //如果上一个文档的URL为空，则是直接打开当前文档，则不存在盗链的问题。否则有可能是盗链。
    if (frontURL!=&quot;&quot;)
    {
     //通过分割，将当前文档的URL各部分存放在currentURLs数组中。
     var currentURLs = currentURL.split(&quot;/&quot;);
     //通过分割，将上一个文档的URL各部分存放在frontURLs数组中。
     var frontURLs = frontURL.split(&quot;/&quot;);
     //两个数组的第3个元素都为URL的域名部分
     //比较两个数组的第3个元素，如果域名相同，则不是盗链，否则就是盗链
     if (currentURLs[2]==frontURLs[2])
     {
      document.write(&quot;不是盗链，可以显示正常文档&quot;);
     }
     else
     {
      document.write(&quot;您不是从本站中访问到该网址，请通过本部访问&quot;);
      //可以使用以下代码跳转到网站的首页
      //history.location = &quot;http://&quot; + currentURLs[2];
     }
    }
    else
    {
     document.write(&quot;您是直接打开该文档的，不存在盗链问题&quot;);
    }
   --&gt;
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/js集锦(上)/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Git和Github错误汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/Git和Github错误汇总/">Git和Github错误汇总</a>
    </h1>
  

        <a href="/2016/12/10/Git和Github错误汇总/" class="archive-article-date">
  	<time datetime="2016-12-09T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.git新建分支时出现错误 fatal: Not a valid object name: ‘master’.<br>解决办法：要先commit一次才会真正建立master分支，此时就可以新建立分支了。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/">Github</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/Git和Github错误汇总/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Github作为远程仓库的使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/Github作为远程仓库的使用详解/">Github作为远程仓库的使用详解</a>
    </h1>
  

        <a href="/2016/12/10/Github作为远程仓库的使用详解/" class="archive-article-date">
  	<time datetime="2016-12-09T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>远程仓库，即可理解为把本地仓库丢到了某个服务器上，然后别人把你的仓库clone(克隆)或者说拷贝下来而已！又或者说是多人协作时，各个人本地仓库更改整合的一个媒介而已！<br>我们可以自己创建远程仓库，搞台服务器，然后自己搭建，也可以将项目托管到代码托管网站，比如Github，GitCafe，Git@OSC，GitLab，coding.net等。介绍下面几款远程仓库：</p>
<ul>
<li>Github：是最大的代码托管网站，大部分的开发者都喜欢使用这个，但是开源项<br>目不收费，而私有项目是要交”保护费”的，而且Github服务器毕竟在国外，国内访<br>问可能会有些缓慢！</li>
<li>GitCafe：同样私有仓库收保护费，开源仓库免费，但是相比起github有点坑，而且是不时会挂掉，不是很推荐…</li>
<li>Git@OSC：开源中国社区的，仓库免费，不过协作功能还没有完全体现。</li>
<li>GitLab：开源的版本管理系统，可以安装Gitlab CE源码，自己搭服务器；也可以使用GitLab EE企业版，GitLab可以配合着其他IM工作使用，比如我司用的瀑布IM，当有人推送更新的时候收到推送信息等！</li>
<li>coding.net：国内体验最接近Github的产品，有免费版和开发版，高级版，内容可自行到官网查看。</li>
</ul>
<p>1.Github账号注册与创建新仓库</p>
<ul>
<li>注册Github账号：<br>注册链接：<a href="https://github.com/join" target="_blank" rel="external">https://github.com/join</a></li>
<li>创建新仓库：Create repository创建一个仓库<br>2.把本地仓库推送到新仓库<br>git init将你所创建的项目变成带有git仓库的项目，then指定远程主机：<a href="https://github.com/hmqqk/hmqqk.github.io.git" target="_blank" rel="external">https://github.com/hmqqk/hmqqk.github.io.git</a> 用git remote查看状态然后将本地仓库push到远程仓库github中（-u参数作为第一次提交使用，作用是把本地master分支和远程master分支关联起来(设置默认远程主机)，后续提交不需要这个参数！）。<br>liuhong@liuhong-PC MINGW64 ~/hmqqk (master)<br>$ git remote add origin <a href="https://github.com/hmqqk/hmqqk.github.io.git" target="_blank" rel="external">https://github.com/hmqqk/hmqqk.github.io.git</a></li>
</ul>
<p>liuhong@liuhong-PC MINGW64 ~/hmqqk (master)<br>$ git remote<br>origin</p>
<p>liuhong@liuhong-PC MINGW64 ~/hmqqk (master)<br>$ git remote -v<br>origin  <a href="https://github.com/hmqqk/hmqqk.github.io.git" target="_blank" rel="external">https://github.com/hmqqk/hmqqk.github.io.git</a> (fetch)<br>origin  <a href="https://github.com/hmqqk/hmqqk.github.io.git" target="_blank" rel="external">https://github.com/hmqqk/hmqqk.github.io.git</a> (push)</p>
<p>则即可看到Github上有我们push的文件。</p>
<p>3.为项目添加SSH Key免去提交输入账号密码的麻烦<br>第一点：使用Https url可以任意克隆Github上的项目；而是用SSH url<br>克隆的话，你必须是项目的拥有者或管理员，而且还要添加SSH Key，否则会无法克隆。<br>还有一点是，Https每次push都需要输入用户名和密码，而使用SSH则不需要输入用户名<br>如果配置SSH Key时设置了密码，则需要输入密码，否则直接git push就可以了！<br>另外，SSH，Secure shell(安全外壳协议)，专为远程登陆会话与其他网络服务提供安全性<br>的协议， 而SSH传输的数据是可以经过压缩的，可以加快传输的速度，出于安全性与速度，<br>我们优先考虑使用SSH协议，而SSH的安全验证规则又分为基于密码和基于密钥两种！<br>我们这里用的是基于第二种的，即在本地创建一对密钥，公钥(id_rsa.pub)和私钥(id_rsa),<br>然后把公钥的内容贴到Github账号的ssh keys中，这样就建立了本地和远程的认证关系，<br>当我们再push到远程仓库，会将你本地的公共密钥与服务器的进行匹配，如果一致验证通过<br>直接推送更新！<br>目录：C:\Users\liuhong.ssh(有.ssh目录则无需创建，否则手动创建该目录) 在此目录下打开Git Bash<br>ssh-keygen -t rsa -C “2442501113@qq.com” 一直回车会生成秘钥SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。将id_rsa.pub添加到github中的ssh keys中去<br>输入之后，可能会看到一下提示：<br>The authenticity of host ‘[ssh.github.com]:443([192.30.252.150]:443)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?<br>不用担心确保fingerprint是对的，然后根据提示输入命令：yes即可.而且，ssh目录下还会多出一个文件：known_hosts<br>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。<br>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到（但只有你自己才能改）。所以，不要把敏感信息放进去。<br>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到，相当简单，公司内部开发必备。<br>4.添加远程库<br>我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。<br>5.将本地库的内容push到远程库中<br>具体内容见Git本地仓库详解部分的介绍<br>6.从远程库克隆到本地<br>先在本地新建一个空的文件夹作为工作目录，我新建的目录是：D:workspace。因为接下来要将远程的文件克隆到这个目录下。<br>然后跳到D:workspace目录下，使用git clone命令开始克隆：<br>git clone git@github.com:hmqqk/hmqqk.github.io.git<br>则回到本地D:workspace目录下即可查看克隆好的文件。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/">Github</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/Github作为远程仓库的使用详解/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-搞科研，不解释" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/搞科研，不解释/">搞科研，不解释</a>
    </h1>
  

        <a href="/2016/12/10/搞科研，不解释/" class="archive-article-date">
  	<time datetime="2016-12-09T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div text-align="center"><br><img src="/images/science/1_1.jpg"><br></div><br>
        <a class="article-more-a"  href="/2016/12/10/搞科研，不解释/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/科研/">科研</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/studies/">studies</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/搞科研，不解释/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-你的名字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/你的名字/">你的名字</a>
    </h1>
  

        <a href="/2016/12/02/你的名字/" class="archive-article-date">
  	<time datetime="2016-12-01T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-02</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div align="center"><br> <img src="/images/essay/1_1.jpg" /><br></div>
        <a class="article-more-a"  href="/2016/12/02/你的名字/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essay/">essay</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/essays/">essays</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/02/你的名字/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-就业~旅程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/就业~旅程/">就业~旅程</a>
    </h1>
  

        <a href="/2016/11/25/就业~旅程/" class="archive-article-date">
  	<time datetime="2016-11-24T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-11-25</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="就业旅程，师姐带你飞"><a href="#就业旅程，师姐带你飞" class="headerlink" title="就业旅程，师姐带你飞"></a>就业旅程，师姐带你飞</h2><h4 id="华为创新俱乐部-精心策划每一场活动，只为那个独一无二的你！瞧瞧-听听师姐如何说-我整个人都励志的不要不要的啦-真有种飞的感觉呀！大家是否和我有同样的感受嘞"><a href="#华为创新俱乐部-精心策划每一场活动，只为那个独一无二的你！瞧瞧-听听师姐如何说-我整个人都励志的不要不要的啦-真有种飞的感觉呀！大家是否和我有同样的感受嘞" class="headerlink" title="华为创新俱乐部~精心策划每一场活动，只为那个独一无二的你！瞧瞧~听听师姐如何说~我整个人都励志的不要不要的啦~真有种飞的感觉呀！大家是否和我有同样的感受嘞"></a>华为创新俱乐部~精心策划每一场活动，只为那个独一无二的你！瞧瞧~听听师姐如何说~我整个人都励志的不要不要的啦~真有种飞的感觉呀！大家是否和我有同样的感受嘞</h4>
        <a class="article-more-a"  href="/2016/11/25/就业~旅程/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/lives/">lives</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/11/25/就业~旅程/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-去年，今日-华为创新俱乐部" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/去年，今日-华为创新俱乐部/">去年，今日@华为创新俱乐部</a>
    </h1>
  

        <a href="/2016/11/06/去年，今日-华为创新俱乐部/" class="archive-article-date">
  	<time datetime="2016-11-05T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-11-06</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因爱，因缘，我们在一起</p>
        <a class="article-more-a"  href="/2016/11/06/去年，今日-华为创新俱乐部/#more"></a>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book"></i>
	<a class="article-category-link" href="/categories/lives/">lives</a>
	
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/11/06/去年，今日-华为创新俱乐部/#more">阅读全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 轻刻美
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten ---&copy 轻刻美
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','JEb1Y8kupG5T1657HWBP','2.0.0');
</script>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
	
</script>
<script src="/./js/jquery-1.10.2.min.js"></script>
<script src="/./js/main.js"></script>
<script src="/./js/myJs.js"></script>



    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Git/" style="font-size: 16px;">Git</a> <a href="/tags/Github/" style="font-size: 12px;">Github</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/essay/" style="font-size: 10px;">essay</a> <a href="/tags/hexo/" style="font-size: 12px;">hexo</a> <a href="/tags/html/" style="font-size: 14px;">html</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/jade/" style="font-size: 12px;">jade</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/jquery/" style="font-size: 18px;">jquery</a> <a href="/tags/js/" style="font-size: 16px;">js</a> <a href="/tags/karma/" style="font-size: 10px;">karma</a> <a href="/tags/life/" style="font-size: 20px;">life</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/swiftype/" style="font-size: 10px;">swiftype</a> <a href="/tags/yilia/" style="font-size: 10px;">yilia</a> <a href="/tags/科研/" style="font-size: 10px;">科研</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
    
  </div>
</body>
</html>